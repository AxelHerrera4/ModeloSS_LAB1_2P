name: üöÄ CI/CD Pipeline Completo - Dev ‚Üí Test ‚Üí Main

# ============================================================================
# TRIGGER: Se activa autom√°ticamente al crear un Pull Request de dev ‚Üí test
# ============================================================================
on:
  pull_request:
    branches: [ test ]
    types: [opened, synchronize, reopened]
  
  # Para testing manual
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

env:
  PYTHON_VERSION: '3.11'
  MODEL_PATH: 'ml_model/vulnerability_detector.pkl'
  RISK_THRESHOLD: '0.70'

jobs:
  # ============================================================================
  # ETAPA 1: REVISI√ìN DE SEGURIDAD CON MODELO DE MACHINE LEARNING
  # ============================================================================
  security-scan:
    name: üîç Etapa 1 - Revisi√≥n de Seguridad ML
    runs-on: ubuntu-latest
    outputs:
      scan_passed: ${{ steps.scan-result.outputs.passed }}
      high_risk: ${{ steps.scan-result.outputs.high_risk }}
      total_files: ${{ steps.scan-result.outputs.total_files }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
      
      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # Notificaci√≥n: Inicio de revisi√≥n de seguridad
      - name: üì¢ Notificar inicio de revisi√≥n de seguridad
        run: |
          python scripts/telegram_notifier.py \
            --type scan_start \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üîç Obtener archivos modificados en el PR
        id: changed-files
        run: |
          echo "Analizando diff del PR..."
          python scripts/get_changed_files.py \
            --base ${{ github.event.pull_request.base.sha }} \
            --head ${{ github.event.pull_request.head.sha }} \
            --output changed_files.json
          
          FILE_COUNT=$(jq -r '.scannable' changed_files.json)
          echo "files_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è No hay archivos Python/JavaScript para escanear"
            echo "has_files=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Archivos a escanear: $FILE_COUNT"
            echo "has_files=true" >> $GITHUB_OUTPUT
          fi
      
      - name: üß† Verificar modelo ML
        if: steps.changed-files.outputs.has_files == 'true'
        run: |
          if [ ! -f "${{ env.MODEL_PATH }}" ]; then
            echo "‚ùå Modelo no encontrado. Entrena el modelo primero."
            exit 1
          fi
          echo "‚úÖ Modelo encontrado: ${{ env.MODEL_PATH }}"
      
      - name: ü§ñ Ejecutar an√°lisis ML en c√≥digo modificado
        id: ml-scan
        if: steps.changed-files.outputs.has_files == 'true'
        run: |
          echo "üîç Clasificando c√≥digo con modelo de Machine Learning..."
          python scripts/vulnerability_scanner.py \
            --files-list changed_files.json \
            --model ${{ env.MODEL_PATH }} \
            --threshold ${{ env.RISK_THRESHOLD }} \
            --output reports/scan_results.json
        continue-on-error: true
      
      - name: üìä Generar reporte HTML
        if: always() && steps.changed-files.outputs.has_files == 'true'
        run: |
          python scripts/report_generator.py \
            reports/scan_results.json \
            reports/scan_results.html
      
      - name: üì§ Subir reportes como artifacts
        if: always() && steps.changed-files.outputs.has_files == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-reports
          path: |
            reports/scan_results.json
            reports/scan_results.html
          retention-days: 90
      
      - name: üìä Analizar resultados del escaneo
        id: scan-result
        if: steps.changed-files.outputs.has_files == 'true'
        run: |
          if [ -f "reports/scan_results.json" ]; then
            PASSED=$(jq -r '.scan_passed' reports/scan_results.json)
            HIGH=$(jq -r '.high_risk_count' reports/scan_results.json)
            MEDIUM=$(jq -r '.medium_risk_count' reports/scan_results.json)
            TOTAL=$(jq -r '.total_files' reports/scan_results.json)
            
            echo "passed=$PASSED" >> $GITHUB_OUTPUT
            echo "high_risk=$HIGH" >> $GITHUB_OUTPUT
            echo "medium_risk=$MEDIUM" >> $GITHUB_OUTPUT
            echo "total_files=$TOTAL" >> $GITHUB_OUTPUT
            
            echo "üìä Resultados: Total=$TOTAL, Alto=$HIGH, Medio=$MEDIUM, Pas√≥=$PASSED"
          else
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "high_risk=0" >> $GITHUB_OUTPUT
            echo "total_files=0" >> $GITHUB_OUTPUT
          fi
      
      # Si VULNERABLE ‚Üí Notificar y RECHAZAR
      - name: üö® Notificar c√≥digo VULNERABLE
        if: steps.scan-result.outputs.passed == 'false'
        run: |
          python scripts/telegram_notifier.py \
            --type vulnerable \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Marcar PR como rechazado y agregar etiqueta
        if: steps.scan-result.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Agregar etiqueta "fixing-required"
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['fixing-required', 'security-vulnerability']
            });
            
            // Comentar en el PR
            const fs = require('fs');
            const scanData = JSON.parse(fs.readFileSync('reports/scan_results.json', 'utf8'));
            
            let comment = `## üö® Vulnerabilidades Detectadas - PR RECHAZADO\n\n`;
            comment += `‚ùå **El modelo de Machine Learning ha detectado c√≥digo vulnerable.**\n\n`;
            comment += `üìä **Resultados del escaneo:**\n`;
            comment += `- Total archivos: ${scanData.total_files}\n`;
            comment += `- üî¥ Alto riesgo: ${scanData.high_risk_count}\n`;
            comment += `- üü† Riesgo medio: ${scanData.medium_risk_count}\n\n`;
            comment += `### Vulnerabilidades detectadas:\n\n`;
            
            for (const file of scanData.files) {
              if (file.risk_level === 'HIGH' || file.risk_level === 'MEDIUM') {
                comment += `**${file.file}**\n`;
                comment += `- Riesgo: ${file.risk_level}\n`;
                comment += `- Probabilidad: ${(file.vulnerability_probability * 100).toFixed(1)}%\n`;
                comment += `- Tipo: ${file.vulnerability_type}\n\n`;
              }
            }
            
            comment += `\n‚ö†Ô∏è **Acci√≥n requerida:**\n`;
            comment += `1. Corregir las vulnerabilidades detectadas\n`;
            comment += `2. Realizar un nuevo commit\n`;
            comment += `3. El pipeline se ejecutar√° autom√°ticamente\n\n`;
            comment += `üè∑Ô∏è Etiquetas aplicadas: \`fixing-required\`, \`security-vulnerability\`\n`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
      
      - name: üìù Crear issue autom√°tica para vulnerabilidad
        if: steps.scan-result.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const scanData = JSON.parse(fs.readFileSync('reports/scan_results.json', 'utf8'));
            
            let body = `## üö® Vulnerabilidades detectadas en PR #${{ github.event.pull_request.number }}\n\n`;
            body += `**Rama:** ${{ github.head_ref }}\n`;
            body += `**Commit:** ${{ github.event.pull_request.head.sha }}\n\n`;
            body += `### Resumen:\n`;
            body += `- üî¥ Alto riesgo: ${scanData.high_risk_count}\n`;
            body += `- üü† Riesgo medio: ${scanData.medium_risk_count}\n\n`;
            body += `Ver detalles completos en el PR #${{ github.event.pull_request.number }}`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Vulnerabilidad detectada en ${scanData.files[0]?.file || 'c√≥digo'}`,
              body: body,
              labels: ['security', 'vulnerability', 'auto-generated']
            });
      
      - name: ‚ùå BLOQUEAR pipeline si es vulnerable
        if: steps.scan-result.outputs.passed == 'false'
        run: |
          echo "‚ùå C√≥digo clasificado como VULNERABLE por el modelo ML"
          echo "‚ùå Merge bloqueado hasta corregir las vulnerabilidades"
          exit 1
      
      # Si SEGURO ‚Üí Notificar y CONTINUAR
      - name: ‚úÖ Notificar c√≥digo SEGURO
        if: steps.scan-result.outputs.passed == 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type secure \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚úÖ Comentar aprobaci√≥n en PR
        if: steps.scan-result.outputs.passed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `## ‚úÖ C√≥digo Seguro - Aprobado por ML\n\n` +
              `ü§ñ El modelo de Machine Learning ha clasificado el c√≥digo como **SEGURO**.\n\n` +
              `üìä **Resultados:**\n` +
              `- Total archivos analizados: ${{ steps.scan-result.outputs.total_files }}\n` +
              `- üü¢ Todos los archivos son seguros\n\n` +
              `‚û°Ô∏è Continuando con el pipeline: Merge a \`test\` y ejecuci√≥n de pruebas.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });

  # ============================================================================
  # ETAPA 2: MERGE AUTOM√ÅTICO A RAMA TEST + PRUEBAS
  # ============================================================================
  merge-to-test:
    name: üîÄ Etapa 2 - Merge a Test + Pruebas
    runs-on: ubuntu-latest
    needs: security-scan
    if: needs.security-scan.outputs.scan_passed == 'true'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîÄ Merge autom√°tico a rama test
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Checkout a test
          git fetch origin test
          git checkout test
          
          # Merge desde la rama del PR
          git merge --no-ff origin/${{ github.head_ref }} -m "Auto-merge: ${{ github.head_ref }} ‚Üí test [security-approved]"
          
          # Push a test
          git push origin test
          
          echo "‚úÖ Merge autom√°tico completado: ${{ github.head_ref }} ‚Üí test"
      
      - name: üì¢ Notificar merge a test
        run: |
          git clone https://github.com/${{ github.repository }}.git temp_repo || true
          cd temp_repo 2>/dev/null || cd .
          python scripts/telegram_notifier.py \
            --type merge_test \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: üß™ Ejecutar pruebas unitarias e integraci√≥n
        id: tests
        run: |
          echo "üß™ Ejecutando pytest..."
          pytest tests/ -v --tb=short --junitxml=test-results.xml || echo "tests_failed=true" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: üìä Publicar resultados de tests
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Test Results
          path: test-results.xml
          reporter: java-junit
        continue-on-error: true
      
      - name: ‚úÖ Notificar tests exitosos
        if: steps.tests.outputs.tests_failed != 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type tests_passed \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Notificar tests fallidos
        if: steps.tests.outputs.tests_failed == 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type tests_failed \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üè∑Ô∏è Agregar etiqueta si tests fallan
        if: steps.tests.outputs.tests_failed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['tests-failed']
            });
      
      - name: ‚ùå BLOQUEAR si tests fallan
        if: steps.tests.outputs.tests_failed == 'true'
        run: |
          echo "‚ùå Algunas pruebas fallaron"
          echo "‚ùå Pipeline bloqueado hasta corregir las pruebas"
          exit 1

  # ============================================================================
  # ETAPA 3: MERGE A MAIN Y DESPLIEGUE EN PRODUCCI√ìN
  # ============================================================================
  deploy-to-production:
    name: üöÄ Etapa 3 - Deploy a Producci√≥n
    runs-on: ubuntu-latest
    needs: [security-scan, merge-to-test]
    if: needs.security-scan.outputs.scan_passed == 'true'
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîÄ Merge autom√°tico a rama main
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          
          # Checkout a main
          git fetch origin main
          git checkout main
          
          # Merge desde test
          git merge --no-ff origin/test -m "Auto-deploy: test ‚Üí main [all-checks-passed]"
          
          # Push a main
          git push origin main
          
          echo "‚úÖ Merge autom√°tico completado: test ‚Üí main"
      
      - name: üì¢ Notificar inicio de despliegue
        run: |
          python scripts/telegram_notifier.py \
            --type deploy_start \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: üîë Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
        continue-on-error: true
      
      - name: üèóÔ∏è Build and push Docker image
        id: docker-build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/vulnerability-scanner:latest
            ${{ secrets.DOCKER_USERNAME }}/vulnerability-scanner:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        continue-on-error: true
      
      - name: üöÄ Deploy to Railway
        id: deploy-railway
        if: secrets.RAILWAY_TOKEN != ''
        run: |
          npm install -g @railway/cli
          railway deploy --service vulnerability-scanner
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
        continue-on-error: true
      
      - name: üöÄ Deploy to Render (alternativo)
        id: deploy-render
        if: secrets.RENDER_API_KEY != '' && steps.deploy-railway.outcome == 'skipped'
        run: |
          curl -X POST "https://api.render.com/v1/services/${{ secrets.RENDER_SERVICE_ID }}/deploys" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json"
        continue-on-error: true
      
      - name: ‚úÖ Notificar despliegue exitoso
        if: steps.docker-build.outcome == 'success'
        run: |
          python scripts/telegram_notifier.py \
            --type deploy_success \
            --repo "${{ github.repository }}" \
            --url "${{ secrets.DEPLOYMENT_URL }}"
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Notificar despliegue fallido
        if: steps.docker-build.outcome == 'failure'
        run: |
          python scripts/telegram_notifier.py \
            --type deploy_failed \
            --repo "${{ github.repository }}"
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üí¨ Comentar resultado final en PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `## üéâ Pipeline Completado Exitosamente\n\n` +
              `‚úÖ **Todas las etapas del pipeline pasaron:**\n` +
              `1. ‚úÖ Revisi√≥n de seguridad ML - APROBADO\n` +
              `2. ‚úÖ Merge a test - COMPLETADO\n` +
              `3. ‚úÖ Pruebas unitarias - TODAS PASARON\n` +
              `4. ‚úÖ Merge a main - COMPLETADO\n` +
              `5. ‚úÖ Despliegue a producci√≥n - EXITOSO\n\n` +
              `üöÄ **La aplicaci√≥n est√° ahora en producci√≥n.**\n` +
              `üåê URL: ${{ secrets.DEPLOYMENT_URL || 'Configurar DEPLOYMENT_URL en secrets' }}\n\n` +
              `üéä ¬°Felicidades por el despliegue exitoso!`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
