name: üöÄ CI/CD Pipeline Completo - Main

# ============================================================================
# TRIGGER: Se activa en push o PR a main
# ============================================================================
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]
  
  # Para testing manual
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

env:
  PYTHON_VERSION: '3.11'
  MODEL_PATH: 'ml_model/vulnerability_detector.pkl'
  RISK_THRESHOLD: '0.70'

jobs:
  # ============================================================================
  # ETAPA 1: REVISI√ìN DE SEGURIDAD CON MODELO DE MACHINE LEARNING
  # ============================================================================
  security-scan:
    name: üîç An√°lisis de Seguridad ML
    runs-on: ubuntu-latest
    outputs:
      scan_passed: ${{ steps.scan-result.outputs.passed }}
      high_risk: ${{ steps.scan-result.outputs.high_risk }}
      total_files: ${{ steps.scan-result.outputs.total_files }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      # Notificaci√≥n: Inicio de revisi√≥n de seguridad
      - name: üì¢ Notificar inicio de revisi√≥n de seguridad
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            python scripts/telegram_notifier.py \
              --type scan_start \
              --repo "${{ github.repository }}" \
              --branch "${{ github.head_ref }}" \
              --pr ${{ github.event.pull_request.number }}
          else
            python scripts/telegram_notifier.py \
              --type scan_start \
              --repo "${{ github.repository }}" \
              --branch "main"
          fi
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üîç Obtener archivos modificados
        id: changed-files
        run: |
          echo "Analizando archivos modificados..."
          
          # Detectar si es PR o push directo
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            # Para push, comparar con el commit anterior
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi
          
          python scripts/get_changed_files.py \
            --base "$BASE_SHA" \
            --head "$HEAD_SHA" \
            --output changed_files.json
          
          FILE_COUNT=$(jq -r '.scannable' changed_files.json)
          echo "files_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$FILE_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è No hay archivos Python/JavaScript para escanear"
            echo "has_files=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Archivos a escanear: $FILE_COUNT"
            echo "has_files=true" >> $GITHUB_OUTPUT
          fi

      - name: üìù Crear reporte vac√≠o si no hay archivos
        if: steps.changed-files.outputs.has_files == 'false'
        run: |
          mkdir -p reports
          echo '{"scan_passed": true, "high_risk_count": 0, "medium_risk_count": 0, "total_files": 0, "files": []}' > reports/scan_results.json
      
      - name: üß† Verificar modelo ML
        if: steps.changed-files.outputs.has_files == 'true'
        run: |
          if [ ! -f "${{ env.MODEL_PATH }}" ]; then
            echo "‚ùå Modelo no encontrado. Entrena el modelo primero."
            exit 1
          fi
          echo "‚úÖ Modelo encontrado: ${{ env.MODEL_PATH }}"
      
      - name: ü§ñ Ejecutar an√°lisis ML en c√≥digo modificado
        id: ml-scan
        if: steps.changed-files.outputs.has_files == 'true'
        run: |
          echo "üîç Clasificando c√≥digo con modelo de Machine Learning..."
          python scripts/vulnerability_scanner.py \
            --files-list changed_files.json \
            --model ${{ env.MODEL_PATH }} \
            --threshold ${{ env.RISK_THRESHOLD }} \
            --output reports/scan_results.json
        continue-on-error: true
      
      - name: üìä Generar reporte HTML
        if: always()
        run: |
          python scripts/report_generator.py \
            reports/scan_results.json \
            --output reports/scan_results.html
      
      - name: üì§ Subir reportes como artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-reports
          path: |
            reports/scan_results.json
            reports/scan_results.html
          retention-days: 90
      
      - name: üìä Analizar resultados del escaneo
        id: scan-result
        if: always()
        run: |
          if [ -f "reports/scan_results.json" ]; then
            PASSED=$(jq -r '.scan_passed' reports/scan_results.json)
            HIGH=$(jq -r '.high_risk_count' reports/scan_results.json)
            MEDIUM=$(jq -r '.medium_risk_count' reports/scan_results.json)
            TOTAL=$(jq -r '.total_files' reports/scan_results.json)
            
            echo "passed=$PASSED" >> $GITHUB_OUTPUT
            echo "high_risk=$HIGH" >> $GITHUB_OUTPUT
            echo "medium_risk=$MEDIUM" >> $GITHUB_OUTPUT
            echo "total_files=$TOTAL" >> $GITHUB_OUTPUT
            
            echo "üìä Resultados: Total=$TOTAL, Alto=$HIGH, Medio=$MEDIUM, Pas√≥=$PASSED"
          else
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "high_risk=0" >> $GITHUB_OUTPUT
            echo "total_files=0" >> $GITHUB_OUTPUT
          fi
      
      # Si VULNERABLE ‚Üí Notificar y RECHAZAR
      - name: üö® Notificar c√≥digo VULNERABLE
        if: steps.scan-result.outputs.passed == 'false'
        run: |
          python scripts/telegram_notifier.py \
            --type vulnerable \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Marcar PR como rechazado y agregar etiqueta
        if: steps.scan-result.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Agregar etiqueta "fixing-required"
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['fixing-required', 'security-vulnerability']
            });
            
            // Comentar en el PR
            const fs = require('fs');
            const scanData = JSON.parse(fs.readFileSync('reports/scan_results.json', 'utf8'));
            
            let comment = `## üö® Vulnerabilidades Detectadas - PR RECHAZADO\n\n`;
            comment += `‚ùå **El modelo de Machine Learning ha detectado c√≥digo vulnerable.**\n\n`;
            comment += `üìä **Resultados del escaneo:**\n`;
            comment += `- Total archivos: ${scanData.total_files}\n`;
            comment += `- üî¥ Alto riesgo: ${scanData.high_risk_count}\n`;
            comment += `- üü† Riesgo medio: ${scanData.medium_risk_count}\n\n`;
            comment += `### Vulnerabilidades detectadas:\n\n`;
            
            const details = Array.isArray(scanData.details) ? scanData.details : [];
            for (const d of details) {
              const nivel = d.risk_level;
              const esAlto = nivel === 'CR√çTICO' || nivel === 'ALTO';
              const esMedio = nivel === 'MEDIO';
              if (esAlto || esMedio) {
                comment += `**${d.file}**\n`;
                comment += `- Riesgo: ${nivel}\n`;
                comment += `- Probabilidad: ${(d.risk_probability * 100).toFixed(1)}%\n`;
                // Factores de riesgo
                const f = d.features || {};
                const riesgos = [];
                if (f.has_eval) riesgos.push('eval()');
                if (f.has_exec) riesgos.push('exec()');
                if (f.has_sql_concat) riesgos.push('SQL injection');
                if (f.has_command_injection_risk) riesgos.push('Command injection');
                if (f.has_hardcoded_secrets) riesgos.push('Secretos hardcodeados');
                if (f.uses_subprocess_shell) riesgos.push('subprocess shell=True');
                if (f.uses_weak_crypto) riesgos.push('Crypto d√©bil');
                if (f.has_path_traversal_risk) riesgos.push('Path traversal');
                if (f.has_pickle_load) riesgos.push('pickle load inseguros');
                if (riesgos.length) comment += `- Factores: ${riesgos.join(', ')}\n`;
                comment += `\n`;
              }
            }
            
            comment += `\n‚ö†Ô∏è **Acci√≥n requerida:**\n`;
            comment += `1. Corregir las vulnerabilidades detectadas\n`;
            comment += `2. Realizar un nuevo commit\n`;
            comment += `3. El pipeline se ejecutar√° autom√°ticamente\n\n`;
            comment += `üè∑Ô∏è Etiquetas aplicadas: \`fixing-required\`, \`security-vulnerability\`\n`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
      
      - name: üìù Crear issue autom√°tica para vulnerabilidad
        if: steps.scan-result.outputs.passed == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const scanData = JSON.parse(fs.readFileSync('reports/scan_results.json', 'utf8'));
            
            let body = `## üö® Vulnerabilidades detectadas en PR #${{ github.event.pull_request.number }}\n\n`;
            body += `**Rama:** ${{ github.head_ref }}\n`;
            body += `**Commit:** ${{ github.event.pull_request.head.sha }}\n\n`;
            body += `### Resumen:\n`;
            body += `- üî¥ Alto riesgo: ${scanData.high_risk_count}\n`;
            body += `- üü† Riesgo medio: ${scanData.medium_risk_count}\n\n`;
            body += `Ver detalles completos en el PR #${{ github.event.pull_request.number }}`;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Vulnerabilidad detectada en ${scanData.details?.[0]?.file || 'c√≥digo'}`,
              body: body,
              labels: ['security', 'vulnerability', 'auto-generated']
            });
      
      - name: ‚ùå BLOQUEAR pipeline si es vulnerable
        if: steps.scan-result.outputs.passed == 'false'
        run: |
          echo "‚ùå C√≥digo clasificado como VULNERABLE por el modelo ML"
          echo "‚ùå Merge bloqueado hasta corregir las vulnerabilidades"
          exit 1
      
      # Si SEGURO ‚Üí Notificar y CONTINUAR
      - name: ‚úÖ Notificar c√≥digo SEGURO
        if: steps.scan-result.outputs.passed == 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type secure \
            --repo "${{ github.repository }}" \
            --branch "${{ github.head_ref }}" \
            --pr ${{ github.event.pull_request.number }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚úÖ Comentar aprobaci√≥n en PR
        if: steps.scan-result.outputs.passed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `## ‚úÖ C√≥digo Seguro - Aprobado por ML\n\n` +
              `ü§ñ El modelo de Machine Learning ha clasificado el c√≥digo como **SEGURO**.\n\n` +
              `üìä **Resultados:**\n` +
              `- Total archivos analizados: ${{ steps.scan-result.outputs.total_files }}\n` +
              `- üü¢ Todos los archivos son seguros\n\n` +
              `‚û°Ô∏è Continuando con pruebas y despliegue.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });

  # ============================================================================
  # ETAPA 2: PRUEBAS AUTOMATIZADAS
  # ============================================================================
  run-tests:
    name: üß™ Pruebas Automatizadas
    runs-on: ubuntu-latest
    needs: security-scan
    if: always()
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: üß™ Ejecutar pruebas unitarias e integraci√≥n
        id: tests
        run: |
          echo "üß™ Ejecutando pytest..."
          pytest tests/ -v --tb=short --junitxml=test-results.xml || echo "tests_failed=true" >> $GITHUB_OUTPUT
        continue-on-error: true
      
      - name: üìä Publicar resultados de tests
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Test Results
          path: test-results.xml
          reporter: java-junit
        continue-on-error: true
      
      - name: ‚úÖ Notificar tests exitosos
        if: steps.tests.outputs.tests_failed != 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type tests_passed \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Notificar tests fallidos
        if: steps.tests.outputs.tests_failed == 'true'
        run: |
          python scripts/telegram_notifier.py \
            --type tests_failed \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üè∑Ô∏è Agregar etiqueta si tests fallan
        if: steps.tests.outputs.tests_failed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              labels: ['tests-failed']
            });
      
      - name: ‚ùå BLOQUEAR si tests fallan
        if: steps.tests.outputs.tests_failed == 'true'
        run: |
          echo "‚ùå Algunas pruebas fallaron"
          echo "‚ùå Pipeline bloqueado hasta corregir las pruebas"
          exit 1

  # ============================================================================
  # ETAPA 3: DESPLIEGUE EN PRODUCCI√ìN
  # ============================================================================
  deploy-to-production:
    name: üöÄ Despliegue a Producci√≥n
    runs-on: ubuntu-latest
    needs: [security-scan, run-tests]
    if: always() && github.event_name == 'push'
    env:
      RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      RENDER_API_KEY: ${{ secrets.RENDER_API_KEY }}
      RENDER_SERVICE_ID: ${{ secrets.RENDER_SERVICE_ID }}
      DEPLOYMENT_URL: ${{ secrets.DEPLOYMENT_URL }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
      
      - name: üêç Set up Python (opcional para notificaciones)
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
        continue-on-error: true
      
      - name: üì¢ Notificar inicio de despliegue
        run: |
          pip install -r requirements.txt || true
          python scripts/telegram_notifier.py \
            --type deploy_start \
            --repo "${{ github.repository }}"
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: üîë Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
        continue-on-error: true
      
      - name: üèóÔ∏è Build and push Docker image
        id: docker-build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/vulnerability-scanner:latest
            ${{ secrets.DOCKER_USERNAME }}/vulnerability-scanner:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        continue-on-error: true
      
      - name: üöÄ Deploy to Railway
        id: deploy-railway
        if: ${{ env.RAILWAY_TOKEN != '' }}
        run: |
          npm install -g @railway/cli
          railway deploy --service vulnerability-scanner
        env:
          RAILWAY_TOKEN: ${{ env.RAILWAY_TOKEN }}
        continue-on-error: true
      
      - name: üöÄ Deploy to Render (alternativo)
        id: deploy-render
        if: ${{ env.RENDER_API_KEY != '' && steps.deploy-railway.outcome == 'skipped' }}
        run: |
          curl -X POST "https://api.render.com/v1/services/${{ env.RENDER_SERVICE_ID }}/deploys" \
            -H "Authorization: Bearer ${{ env.RENDER_API_KEY }}" \
            -H "Content-Type: application/json"
        continue-on-error: true
      
      - name: ‚úÖ Notificar despliegue exitoso
        if: steps.docker-build.outcome == 'success'
        run: |
          python scripts/telegram_notifier.py \
            --type deploy_success \
            --repo "${{ github.repository }}" \
            --url "${{ secrets.DEPLOYMENT_URL }}"
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: ‚ùå Notificar despliegue fallido
        if: steps.docker-build.outcome == 'failure'
        run: |
          python scripts/telegram_notifier.py \
            --type deploy_failed \
            --repo "${{ github.repository }}"
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      - name: üí¨ Comentar resultado final en PR
        if: github.event_name == 'pull_request' && github.event.pull_request.number != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = `## üéâ Pipeline Completado Exitosamente\n\n` +
              `‚úÖ **Todas las etapas del pipeline pasaron:**\n` +
              `1. ‚úÖ Revisi√≥n de seguridad ML - APROBADO\n` +
              `2. ‚úÖ Pruebas automatizadas - TODAS PASARON\n` +
              `3. ‚úÖ Despliegue a producci√≥n - EXITOSO\n\n` +
              `üöÄ **La aplicaci√≥n est√° ahora en producci√≥n.**\n` +
              `üåê URL: ${{ env.DEPLOYMENT_URL || 'Configurar DEPLOYMENT_URL en secrets' }}\n\n` +
              `üéä ¬°Felicidades por el despliegue exitoso!`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: comment
            });
