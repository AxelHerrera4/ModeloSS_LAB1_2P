index,vul_code,is_vulnerable,programming_language,method_name,file_name,repo_url,repo_owner,committer,committer_date,commit_msg,cwe_id,cwe_name,cwe_description,cwe_url,cve_id,patch
1,"def escape_javascript(javascript) javascript = javascript.to_s if javascript.empty? result = """" else result = javascript.gsub(/(\\|<\/|\r\n|\342\200\250|\342\200\251|[\n\r""'])/u, JS_ESCAPE_MAP) end javascript.html_safe? ? result.html_safe : result end",True,Ruby,escape_javascript,javascript_helper.rb,https://github.com/rails/rails,rails,Aaron Patterson,2020-03-19 09:48:08-07:00,"Fix possible XSS vector in JS escape helper

This commit escapes dollar signs and backticks to prevent JS XSS issues
when using the `j` or `javascript_escape` helper

CVE-2020-5267",CWE-80,Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS),"The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as ""<"", "">"", and ""&"" that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.",https://cwe.mitre.org/data/definitions/80.html,CVE-2020-5267,"def escape_javascript(javascript) javascript = javascript.to_s if javascript.empty? result = """" else result = javascript.gsub(/(\\|<\/|\r\n|\342\200\250|\342\200\251|[\n\r""']|[`]|[$])/u, JS_ESCAPE_MAP) end javascript.html_safe? ? result.html_safe : result end"
4,"def quote_column_name(name) #:nodoc: @quoted_column_names[name] ||= ""`#{name}`"" end",True,Ruby,quote_column_name,mysql2_adapter.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:24:42-07:00,prevent sql injection attacks by escaping quotes in column names,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2011-2930,"def quote_column_name(name) #:nodoc: @quoted_column_names[name] ||= ""`#{name.to_s.gsub('`', '``')}`"" end"
6,"def quote_column_name(name) #:nodoc: @quoted_column_names[name] ||= ""`#{name}`"" end",True,Ruby,quote_column_name,mysql_adapter.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:24:42-07:00,prevent sql injection attacks by escaping quotes in column names,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2011-2930,"def quote_column_name(name) #:nodoc: @quoted_column_names[name] ||= ""`#{name.to_s.gsub('`', '``')}`"" end"
9,"def quote_column_name(name) #:nodoc: %Q(""#{name}"") end",True,Ruby,quote_column_name,sqlite_adapter.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:24:42-07:00,prevent sql injection attacks by escaping quotes in column names,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2011-2930,"def quote_column_name(name) #:nodoc: %Q(""#{name.to_s.gsub('""', '""""')}"")"
12,"def parse(parent, line, pos, content, strict=true) if content !~ /^<\S/ Text.new(parent, line, pos, content) else scanner = StringScanner.new(content) unless scanner.skip(/</) if strict raise ""expected <"" else return Text.new(parent, line, pos, content) end end if scanner.skip(/!\[CDATA\[/) unless scanner.skip_until(/\]\]>/) if strict raise ""expected ]]> (got #{scanner.rest.inspect} for #{content})"" else scanner.skip_until(/\Z/) end end return CDATA.new(parent, line, pos, scanner.pre_match.gsub(/<!\[CDATA\[/, '')) end closing = ( scanner.scan(/\//) ? :close : nil ) return Text.new(parent, line, pos, content) unless name = scanner.scan(/[\w:-]+/) name.downcase! unless closing scanner.skip(/\s*/) attributes = {} while attr = scanner.scan(/[-\w:]+/) value = true if scanner.scan(/\s*=\s*/) if delim = scanner.scan(/['""]/) value = """" while text = scanner.scan(/[^#{delim}\\]+|./) case text when ""\\"" then value << text break if scanner.eos? value << scanner.getch when delim break else value << text end end else value = scanner.scan(/[^\s>\/]+/) end end attributes[attr.downcase] = value scanner.skip(/\s*/) end closing = ( scanner.scan(/\//) ? :self : nil ) end unless scanner.scan(/\s*>/) if strict raise ""expected > (got #{scanner.rest.inspect} for #{content}, #{attributes.inspect})"" else # throw away all text until we find what we're looking for scanner.skip_until(/>/) or scanner.terminate end end Tag.new(parent, line, pos, name, attributes, closing) end",True,Ruby,parse,node.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:24:48-07:00,"Tags with invalid names should also be stripped in order to prevent
XSS attacks.  Thanks Sascha Depold for the report.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2011-2931,"def parse(parent, line, pos, content, strict=true) if content !~ /^<\S/ Text.new(parent, line, pos, content) else scanner = StringScanner.new(content) unless scanner.skip(/</) if strict raise ""expected <"" else return Text.new(parent, line, pos, content) end end if scanner.skip(/!\[CDATA\[/) unless scanner.skip_until(/\]\]>/) if strict raise ""expected ]]> (got #{scanner.rest.inspect} for #{content})"" else scanner.skip_until(/\Z/) end end return CDATA.new(parent, line, pos, scanner.pre_match.gsub(/<!\[CDATA\[/, '')) end closing = ( scanner.scan(/\//) ? :close : nil ) return Text.new(parent, line, pos, content) unless name = scanner.scan(/[^\s!>\/]+/) name.downcase! unless closing scanner.skip(/\s*/) attributes = {} while attr = scanner.scan(/[-\w:]+/) value = true if scanner.scan(/\s*=\s*/) if delim = scanner.scan(/['""]/) value = """" while text = scanner.scan(/[^#{delim}\\]+|./) case text when ""\\"" then value << text break if scanner.eos? value << scanner.getch when delim break else value << text end end else value = scanner.scan(/[^\s>\/]+/) end end attributes[attr.downcase] = value scanner.skip(/\s*/) end closing = ( scanner.scan(/\//) ? :self : nil ) end unless scanner.scan(/\s*>/) if strict raise ""expected > (got #{scanner.rest.inspect} for #{content}, #{attributes.inspect})"" else # throw away all text until we find what we're looking for scanner.skip_until(/>/) or scanner.terminate end end Tag.new(parent, line, pos, name, attributes, closing) end"
15,"def html_escape(s) s = s.to_s if s.html_safe? s else s.gsub(/[&""><]/) { |special| HTML_ESCAPE[special] }.html_safe end end",True,Ruby,html_escape,output_safety.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:24:58-07:00,properly escape html to avoid invalid utf8 causing XSS attacks,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2011-2932,"def html_escape(s) s = s.to_s if s.html_safe? s else s.to_s.gsub(/&/, ""&amp;"").gsub(/\""/, ""&quot;"").gsub(/>/, ""&gt;"").gsub(/</, ""&lt;"").html_safe end end"
19,"def build_query(path, details) query = @pattern.dup query.gsub!(/\:prefix(\/)?/, path.prefix.empty? ? """" : ""#{path.prefix}\\1"") # prefix can be empty... query.gsub!(/\:action/, path.partial? ? ""_#{path.name}"" : path.name) details.each do |ext, variants| query.gsub!(/\:#{ext}/, ""{#{variants.compact.uniq.join(',')}}"") end File.expand_path(query, @path) end",True,Ruby,build_query,resolver.rb,https://github.com/rails/rails,rails,Aaron Patterson,2011-08-16 15:28:27-07:00,Properly escape glob characters.,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2011-2929,"def build_query(path, details) query = @pattern.dup prefix = path.prefix.empty? ? """" : ""#{escape_entry(path.prefix)}\\1"" query.gsub!(/\:prefix(\/)?/, prefix) partial = escape_entry(path.partial? ? ""_#{path.name}"" : path.name) query.gsub!(/\:action/, partial) details.each do |ext, variants| query.gsub!(/\:#{ext}/, ""{#{variants.compact.uniq.join(',')}}"") end File.expand_path(query, @path) end"
25,"def authorized?(request) origin_host = request.get_header(""HTTP_HOST"")&.slice(VALID_ORIGIN_HOST, 1) || """" forwarded_host = request.x_forwarded_host&.slice(VALID_FORWARDED_HOST, 1) || """" @permissions.allows?(origin_host) && (forwarded_host.blank? || @permissions.allows?(forwarded_host)) end",True,Ruby,authorized?,host_authorization.rb,https://github.com/rails/rails,rails,Aaron Patterson,2021-12-14 12:25:10-08:00,"Fix invalid forwarded host vulnerability

Prior to this commit, it was possible to pass an unvalidated host
through the `X-Forwarded-Host` header. If the value of the header
was prefixed with a invalid domain character (for example a `/`),
it was always accepted as the actual host of that request.

Since this host is used for all url helpers, an attacker could change
generated links and redirects. If the header is set to
`X-Forwarded-Host: //evil.hacker`, a redirect will be send to
`https:////evil.hacker/`. Browsers will ignore these four slashes
and redirect the user.

[CVE-2021-44528]",CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",https://cwe.mitre.org/data/definitions/601.html,CVE-2021-44528,"def authorized?(request) origin_host = request.get_header(""HTTP_HOST"") forwarded_host = request.x_forwarded_host&.split(/,\s?/)&.last @permissions.allows?(origin_host) && (forwarded_host.blank? || @permissions.allows?(forwarded_host)) end"
26,"def sanitize_string(host) if host.start_with?(""."") /\A(.+\.)?#{Regexp.escape(host[1..-1])}\z/i else /\A#{Regexp.escape host}\z/i end end",True,Ruby,sanitize_string,host_authorization.rb,https://github.com/rails/rails,rails,Aaron Patterson,2021-12-14 12:25:10-08:00,"Fix invalid forwarded host vulnerability

Prior to this commit, it was possible to pass an unvalidated host
through the `X-Forwarded-Host` header. If the value of the header
was prefixed with a invalid domain character (for example a `/`),
it was always accepted as the actual host of that request.

Since this host is used for all url helpers, an attacker could change
generated links and redirects. If the header is set to
`X-Forwarded-Host: //evil.hacker`, a redirect will be send to
`https:////evil.hacker/`. Browsers will ignore these four slashes
and redirect the user.

[CVE-2021-44528]",CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",https://cwe.mitre.org/data/definitions/601.html,CVE-2021-44528,"def sanitize_string(host) if host.start_with?(""."") /\A([a-z0-9-]+\.)?#{Regexp.escape(host[1..-1])}\z/i else /\A#{Regexp.escape host}\z/i end end"
28,def self.run! # :nodoc: if check! super else Null end end,True,Ruby,self.run!,reloader.rb,https://github.com/rails/rails,rails,Aaron Patterson,2022-02-11 11:48:19-08:00,"Fix reloader to work with new Executor signature

This is a follow up to [CVE-2022-23633].",CWE-212,Improper Removal of Sensitive Information Before Storage or Transfer,"The product stores, transfers, or shares a resource that contains sensitive information, but it does not properly remove that information before the product makes the resource available to unauthorized actors.",https://cwe.mitre.org/data/definitions/212.html,CVE-2022-23633,def self.run!(reset: false) # :nodoc: if check! super else Null end end
29,def remote_address @request.forwarded_for || socket_address rescue Exception log_error nil end,True,Ruby,remote_address,connection.rb,https://github.com/macournoyer/thin,macournoyer,macournoyer,2009-08-12 17:28:38-04:00,Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov],CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2009-3287,def remote_address socket_address rescue Exception log_error nil end
31,def forwarded_for @env[FORWARDED_FOR] end,True,Ruby,forwarded_for,request.rb,https://github.com/macournoyer/thin,macournoyer,macournoyer,2009-08-12 17:28:38-04:00,Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov],CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2009-3287,"def create exists = true if params.has_key?(:inflated_object) params[:name] ||= params[:inflated_object].name params[:admin] ||= params[:inflated_object].admin end # We can only create clients if we're the admin or the validator. # But only allow creating admin clients if we're already an admin. if params[:admin] == true && @auth_user.admin != true raise Forbidden, ""You are not allowed to take this action."" end begin Chef::ApiClient.cdb_load(params[:name]) rescue Chef::Exceptions::CouchDBNotFound exists = false end raise Conflict, ""Client already exists"" if exists @client = Chef::ApiClient.new @client.name(params[:name]) @client.admin(params[:admin]) if params[:admin] @client.create_keys @client.cdb_save self.status = 201 headers['Location'] = absolute_url(:client, @client.name) display({ :uri => absolute_url(:client, @client.name), :private_key => @client.private_key }) end"
33,"it ""should return HTTP_X_FORWARDED_FOR as remote_address"" do @connection.request.env['HTTP_X_FORWARDED_FOR'] = '1.2.3.4' @connection.remote_address.should == '1.2.3.4' end",True,Ruby,"""should return HTTP_X_FORWARDED_FOR as remote_address""",connection_spec.rb,https://github.com/macournoyer/thin,macournoyer,macournoyer,2009-08-12 17:28:38-04:00,Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov],CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2009-3287,"def rebuild_time required_parameters :repository, :arch load_packages_mainpage @repository = params[:repository] @arch = params[:arch] @hosts = begin Integer(params[:hosts] || '40') rescue 40 end @scheduler = params[:scheduler] || 'needed' unless [""fifo"", ""lifo"", ""random"", ""btime"", ""needed"", ""neededb"", ""longest_data"", ""longested_triedread"", ""longest""].include? @scheduler flash[:error] = ""Invalid scheduler type, check mkdiststats docu - aehm, source"" redirect_to :action => :show, :project => @project return end bdep = find_cached(BuilddepInfo, :project => @project.name, :repository => @repository, :arch => @arch) jobs = find_cached(Jobhislist , :project => @project.name, :repository => @repository, :arch => @arch, :limit => @packages.each.size * 3, :code => ['succeeded', 'unchanged']) unless bdep and jobs flash[:error] = ""Could not collect infos about repository #{@repository}/#{@arch}"" redirect_to :action => :show, :project => @project return end indir = Dir.mktmpdir f = File.open(indir + ""/_builddepinfo.xml"", 'w') f.write(bdep.dump_xml) f.close f = File.open(indir + ""/_jobhistory.xml"", 'w') f.write(jobs.dump_xml) f.close outdir = Dir.mktmpdir logger.debug ""cd #{RAILS_ROOT}/vendor/diststats && perl ./mkdiststats --srcdir=#{indir} --destdir=#{outdir} --outfmt=xml #{@project.name}/#{@repository}/#{@arch} --width=910 --buildhosts=#{@hosts} --scheduler=#{@scheduler}"" fork do Dir.chdir(""#{RAILS_ROOT}/vendor/diststats"") system(""perl"", ""./mkdiststats"", ""--srcdir=#{indir}"", ""--destdir=#{outdir}"", ""--outfmt=xml"", ""#{@project.name}/#{@repository}/#{@arch}"", ""--width=910"", ""--buildhosts=#{@hosts}"", ""--scheduler=#{@scheduler}"") end Process.wait f=File.open(outdir + ""/rebuild.png"") png=f.read f.close @pngkey = Digest::MD5.hexdigest( params.to_s ) Rails.cache.write(""rebuild-%s.png"" % @pngkey, png) f=File.open(outdir + ""/longest.xml"") longest = ActiveXML::LibXMLNode.new(f.read) @timings = Hash.new longest.timings.each_package do |p| @timings[p.value(:name)] = [p.value(:buildtime), p.value(:finished)] end @rebuildtime = Integer(longest.value :rebuildtime) f.close @longestpaths = Array.new longest.longestpath.each_path do |path| currentpath = Array.new path.each_package do |p| currentpath << p.text end @longestpaths << currentpath end # we append 4 empty paths, so there are always at least 4 in the array # to simplify the view code 4.times { @longestpaths << Array.new } FileUtils.rm_rf indir FileUtils.rm_rf outdir end"
45,"def rebuild_time required_parameters :repository, :arch load_packages_mainpage @repository = params[:repository] @arch = params[:arch] @hosts = begin Integer(params[:hosts] || '40') rescue 40 end @scheduler = params[:scheduler] || 'needed' bdep = find_cached(BuilddepInfo, :project => @project.name, :repository => @repository, :arch => @arch) jobs = find_cached(Jobhislist , :project => @project.name, :repository => @repository, :arch => @arch, :limit => @packages.each.size * 3, :code => ['succeeded', 'unchanged']) unless bdep and jobs flash[:error] = ""Could not collect infos about repository #{@repository}/#{@arch}"" redirect_to :action => :show, :project => @project return end indir = Dir.mktmpdir f = File.open(indir + ""/_builddepinfo.xml"", 'w') f.write(bdep.dump_xml) f.close f = File.open(indir + ""/_jobhistory.xml"", 'w') f.write(jobs.dump_xml) f.close outdir = Dir.mktmpdir cmd=""perl ./mkdiststats '--srcdir=#{indir}' '--destdir=#{outdir}' --outfmt=xml #{@project.name}/#{@repository}/#{@arch} --width=910 --buildhosts=#{@hosts} --scheduler=#{@scheduler}"" logger.debug ""cd #{RAILS_ROOT}/vendor/diststats && #{cmd}"" system(""cd #{RAILS_ROOT}/vendor/diststats && #{cmd}"") f=File.open(outdir + ""/rebuild.png"") png=f.read f.close @pngkey = Digest::MD5.hexdigest( params.to_s ) Rails.cache.write(""rebuild-%s.png"" % @pngkey, png) f=File.open(outdir + ""/longest.xml"") longest = ActiveXML::LibXMLNode.new(f.read) @timings = Hash.new longest.timings.each_package do |p| @timings[p.value(:name)] = [p.value(:buildtime), p.value(:finished)] end @rebuildtime = Integer(longest.value :rebuildtime) f.close @longestpaths = Array.new longest.longestpath.each_path do |path| currentpath = Array.new path.each_package do |p| currentpath << p.text end @longestpaths << currentpath end # we append 4 empty paths, so there are always at least 4 in the array # to simplify the view code 4.times { @longestpaths << Array.new } FileUtils.rm_rf indir FileUtils.rm_rf outdir end",True,Ruby,rebuild_time,project_controller.rb,https://github.com/openSUSE/open-build-service,openSUSE,Stephan Kulow,2011-09-02 14:50:54+02:00,[webui] check the value of the scheduler parameter,CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2011-3178,"def index valid_http_methods :get, :post # for permission check if params[:package] and not [""_repository"", ""_jobhistory""].include?(params[:package]) pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false ) else prj = DbProject.get_by_name params[:project] end if request.get? pass_to_backend return end if @http_user.is_admin? # check for a local package instance DbPackage.get_by_project_and_name( params[:project], params[:package], follow_project_links=false ) pass_to_backend else render_error :status => 403, :errorcode => ""execute_cmd_no_permission"", :message => ""Upload of binaries is only permitted for administrators"" end end"
49,"def index valid_http_methods :get, :post, :put # for permission check if params[:package] and not [""_repository"", ""_jobhistory""].include?(params[:package]) pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false ) else prj = DbProject.get_by_name params[:project] end pass_to_backend end",True,Ruby,index,build_controller.rb,https://github.com/openSUSE/open-build-service,openSUSE,Adrian Schröter,2011-12-12 15:51:03+01:00,[api] support binary package upload for the admin,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2011-4181,"def index valid_http_methods :get, :post # for permission check if params[:package] and not [""_repository"", ""_jobhistory""].include?(params[:package]) pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false ) else prj = DbProject.get_by_name params[:project] end if request.get? pass_to_backend return end if @http_user.is_admin? # check for a local package instance DbPackage.get_by_project_and_name( params[:project], params[:package], follow_project_links=false ) pass_to_backend else render_error :status => 403, :errorcode => ""execute_cmd_no_permission"", :message => ""Upload of binaries is only permitted for administrators"" end end"
50,"def index valid_http_methods :get, :post, :put # for permission check if params[:package] and not [""_repository"", ""_jobhistory""].include?(params[:package]) pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false ) else prj = DbProject.get_by_name params[:project] end pass_to_backend end",True,Ruby,index,build_controller.rb,https://github.com/openSUSE/open-build-service,openSUSE,Adrian Schröter,2011-12-12 15:51:03+01:00,[api] support binary package upload for the admin,CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2011-4183,"def index valid_http_methods :get, :post # for permission check if params[:package] and not [""_repository"", ""_jobhistory""].include?(params[:package]) pkg = DbPackage.get_by_project_and_name( params[:project], params[:package], use_source=false ) else prj = DbProject.get_by_name params[:project] end if request.get? pass_to_backend return end if @http_user.is_admin? # check for a local package instance DbPackage.get_by_project_and_name( params[:project], params[:package], follow_project_links=false ) pass_to_backend else render_error :status => 403, :errorcode => ""execute_cmd_no_permission"", :message => ""Upload of binaries is only permitted for administrators"" end end"
51,"def package_index valid_http_methods :get required_parameters :project, :repository, :arch, :package # read access permission check if params[:package] == ""_repository"" prj = DbProject.get_by_name params[:project], use_source=false else pkg = DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false end pass_to_backend end",True,Ruby,package_index,build_controller.rb,https://github.com/openSUSE/open-build-service,openSUSE,Adrian Schröter,2011-12-12 15:51:03+01:00,[api] support binary package upload for the admin,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2011-4181,"def do_project_copy( params ) # set user if nil, needed for delayed job in Package model User.current ||= User.find_by_login(params[:user]) check_write_access! # copy entire project in the backend begin path = ""/source/#{URI.escape(self.name)}"" path << Suse::Backend.build_query_from_hash(params, [:cmd, :user, :comment, :oproject, :withbinaries, :withhistory, :makeolder]) Suse::Backend.post path, nil rescue Suse::Backend::HTTPError => e logger.debug ""copy failed: #{e.message}"" # we need to check results of backend in any case (also timeout error eg) end # restore all package meta data objects in DB backend_pkgs = Collection.find :package, :match => ""@project='#{self.name}'"" backend_pkgs.each_package do |package| path = ""/source/#{URI.escape(self.name)}/#{package.name}/_meta"" p = self.packages.new(name: package.name) p.update_from_xml(Xmlhash.parse(Suse::Backend.get(path).body)) p.save! # do not store end packages.each { |p| p.sources_changed } end"
52,"def package_index valid_http_methods :get required_parameters :project, :repository, :arch, :package # read access permission check if params[:package] == ""_repository"" prj = DbProject.get_by_name params[:project], use_source=false else pkg = DbPackage.get_by_project_and_name params[:project], params[:package], use_source=false end pass_to_backend end",True,Ruby,package_index,build_controller.rb,https://github.com/openSUSE/open-build-service,openSUSE,Adrian Schröter,2011-12-12 15:51:03+01:00,[api] support binary package upload for the admin,CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2011-4183,"def self.new_from_xml_hash(hash) r = Review.new r.state = :new hash.delete('state') r.by_user = hash.delete('by_user') r.by_group = hash.delete('by_group') r.by_project = hash.delete('by_project') r.by_package = hash.delete('by_package') r.reviewer = r.creator = hash.delete('who') r.reason = hash.delete('comment') begin r.created_at = Time.zone.parse(hash.delete('when')) rescue TypeError # no valid time -> ignore end raise ArgumentError, ""too much information #{hash.inspect}"" if hash.present? r end"
78,"def do_project_copy( params ) # copy entire project in the backend begin path = ""/source/#{URI.escape(self.name)}"" path << Suse::Backend.build_query_from_hash(params, [:cmd, :user, :comment, :oproject, :withbinaries, :withhistory, :makeolder]) Suse::Backend.post path, nil rescue Suse::Backend::HTTPError => e logger.debug ""copy failed: #{e.message}"" # we need to check results of backend in any case (also timeout error eg) end # set user if nil, needed for delayed job in Package model User.current ||= User.find_by_login(params[:user]) # restore all package meta data objects in DB backend_pkgs = Collection.find :package, :match => ""@project='#{self.name}'"" backend_pkgs.each_package do |package| path = ""/source/#{URI.escape(self.name)}/#{package.name}/_meta"" p = self.packages.new(name: package.name) p.update_from_xml(Xmlhash.parse(Suse::Backend.get(path).body)) p.save! # do not store end packages.each { |p| p.sources_changed } end",True,Ruby,do_project_copy,project.rb,https://github.com/openSUSE/open-build-service,openSUSE,Adrian Schröter,2013-07-05 17:21:21+02:00,"[api] move write permission checks from controller to package and project model

This is just the first part doing the checks. Removing the old ones is another step.",CWE-275,Permission Issues,Weaknesses in this category are related to improper assignment or handling of permissions.,https://cwe.mitre.org/data/definitions/275.html,CVE-2013-3703,"def test_parse_bigger xml = <<-XML.strip_heredoc <request id=""1027"" creator=""Iggy""> <action type=""submit""> <source project=""home:Iggy"" package=""TestPack"" rev=""1""/> <target project=""kde4"" package=""mypackage""/> <options> <sourceupdate>cleanup</sourceupdate> </options> <acceptinfo rev=""1"" srcmd5=""806a6e27ed7915d1bb8d8a989404fd5a"" osrcmd5=""d41d8cd98f00b204e9800998ecf8427e""/> </action> <priority>critical</priority> <state name=""review"" who=""Iggy"" when=""2012-11-07T21:13:12""> <comment>No comment</comment> </state> <review state=""new"" when=""2017-09-01T09:11:11"" by_user=""adrian""/> <review state=""new"" when=""2017-09-01T09:11:11"" by_group=""test_group""/> <review state=""accepted"" when=""2012-11-07T21:13:12"" who=""tom"" by_user=""tom""> <comment>review1</comment> </review> <review state=""new"" when=""2012-11-07T21:13:13"" who=""tom"" by_user=""tom""> <comment>please accept</comment> </review> <description>Left blank</description> </request> XML req = BsRequest.new_from_xml(xml) req.save! # number got increased by one assert_equal 1027, req.number newxml = req.render_xml expected = <<-XML.strip_heredoc <request id=""1027"" creator=""Iggy""> <action type=""submit""> <source project=""home:Iggy"" package=""TestPack"" rev=""1""/> <target project=""kde4"" package=""mypackage""/> <options> <sourceupdate>cleanup</sourceupdate> </options> <acceptinfo rev=""1"" srcmd5=""806a6e27ed7915d1bb8d8a989404fd5a"" osrcmd5=""d41d8cd98f00b204e9800998ecf8427e""/> </action> <priority>critical</priority> <state name=""review"" who=""Iggy"" when=""2012-11-07T21:13:12""> <comment>No comment</comment> </state> <review state=""new"" when=""2017-09-01T09:11:11"" by_user=""adrian""/> <review state=""new"" when=""2017-09-01T09:11:11"" by_group=""test_group""/> <review state=""new"" when=""2012-11-07T21:13:12"" who=""tom"" by_user=""tom""> <comment>review1</comment> </review> <review state=""new"" when=""2012-11-07T21:13:13"" who=""tom"" by_user=""tom""> <comment>please accept</comment> </review> <description>Left blank</description> </request> XML assert_equal expected, newxml wi = req.webui_infos(diffs: false) # iggy is *not* target maintainer assert_equal false, wi['is_target_maintainer'] assert_equal wi['actions'][0], type: :submit, sprj: 'home:Iggy', spkg: 'TestPack', srev: '1', tprj: 'kde4', tpkg: 'mypackage', name: 'Submit TestPack' end"
88,"def self.new_from_xml_hash(hash) r = Review.new r.state = hash.delete('state') { raise ArgumentError, 'no state' } r.state = r.state.to_sym r.by_user = hash.delete('by_user') r.by_group = hash.delete('by_group') r.by_project = hash.delete('by_project') r.by_package = hash.delete('by_package') r.reviewer = r.creator = hash.delete('who') r.reason = hash.delete('comment') begin r.created_at = Time.zone.parse(hash.delete('when')) rescue TypeError # no valid time -> ignore end raise ArgumentError, ""too much information #{hash.inspect}"" if hash.present? r end",True,Ruby,self.new_from_xml_hash,review.rb,https://github.com/openSUSE/open-build-service,openSUSE,Christian Bruckmayer,2018-05-30 11:26:15+02:00,"[api] Initialize review state with :new

to have the request review always in a sane state.

https://bugzilla.suse.com/show_bug.cgi?id=1094820

Signed-off-by: Christian Bruckmayer <cbruckmayer@suse.com>
Co-authored-by: Christian Bruckmayer <cbruckmayer@suse.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2018-7688,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package opts = { follow_project_links: false } source_package = Package.get_by_project_and_name!(source_project, self.source_package, opts) return if User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end"
90,"def test_parse_bigger xml = <<-XML.strip_heredoc <request id=""1027"" creator=""Iggy""> <action type=""submit""> <source project=""home:Iggy"" package=""TestPack"" rev=""1""/> <target project=""kde4"" package=""mypackage""/> <options> <sourceupdate>cleanup</sourceupdate> </options> <acceptinfo rev=""1"" srcmd5=""806a6e27ed7915d1bb8d8a989404fd5a"" osrcmd5=""d41d8cd98f00b204e9800998ecf8427e""/> </action> <priority>critical</priority> <state name=""review"" who=""Iggy"" when=""2012-11-07T21:13:12""> <comment>No comment</comment> </state> <review state=""new"" when=""2017-09-01T09:11:11"" by_user=""adrian""/> <review state=""new"" when=""2017-09-01T09:11:11"" by_group=""test_group""/> <review state=""accepted"" when=""2012-11-07T21:13:12"" who=""tom"" by_user=""tom""> <comment>review1</comment> </review> <review state=""new"" when=""2012-11-07T21:13:13"" who=""tom"" by_user=""tom""> <comment>please accept</comment> </review> <description>Left blank</description> </request> XML req = BsRequest.new_from_xml(xml) req.save! # number got increased by one assert_equal 1027, req.number newxml = req.render_xml assert_equal xml, newxml wi = req.webui_infos(diffs: false) # iggy is *not* target maintainer assert_equal false, wi['is_target_maintainer'] assert_equal wi['actions'][0], type: :submit, sprj: 'home:Iggy', spkg: 'TestPack', srev: '1', tprj: 'kde4', tpkg: 'mypackage', name: 'Submit TestPack' end",True,Ruby,test_parse_bigger,bs_request_test.rb,https://github.com/openSUSE/open-build-service,openSUSE,Christian Bruckmayer,2018-05-30 11:26:15+02:00,"[api] Initialize review state with :new

to have the request review always in a sane state.

https://bugzilla.suse.com/show_bug.cgi?id=1094820

Signed-off-by: Christian Bruckmayer <cbruckmayer@suse.com>
Co-authored-by: Christian Bruckmayer <cbruckmayer@suse.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2018-7688,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package opts = { follow_project_links: false } source_package = Package.get_by_project_and_name!(source_project, self.source_package, opts) return if User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end"
97,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package source_package = Package.get_by_project_and_name(source_project, self.source_package) return if !source_package || User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end",True,Ruby,check_action_permission!,bs_request_action_submit.rb,https://github.com/openSUSE/open-build-service,openSUSE,Björn Geuken,2018-07-24 09:42:22+02:00,"Ignore a project link in BsRequestAction.check_action_permission!

This makes sure that we check the permissions of the correct package. For
instance, assume that the project ""Staging"" is a link project where the
link points to the ""Base"" project. Also, assume that there exists a
""Base/foo"" package, but there exists no explicit ""Staging/foo"" package.
Moreover, assume we check the permissions for the following ""submit""
action:

<action type=""submit"">
  <source project=""Staging"" package=""foo""/>
  <target project=""an_arbitrary_project"" package=""foo""/>
</action>

In this case, the old code checks if request acceptor can modify the
""Base/foo"" package (since it follows the project link). This is wrong
because the ""Staging/foo"" package would be turned into a branch during
accept.
The new code checks the correct package because it does not follow the
project link and requires that the source package exists in the source
project. Requiring the existence of the source package potentially
breaks artificial requests (for instance, a request where the ""submit""
action from above is preceded by a ""submit"" action that creates a
""Staging/foo"" package).

Note: so far I was unable to exploit the old code - so this is just
to avoid a potential future headache.

Fixes: commit 990ef7ccc (""[api][webui] Check access to source package"")",CWE-732,Incorrect Permission Assignment for Critical Resource,The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.,https://cwe.mitre.org/data/definitions/732.html,CVE-2018-12466,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package opts = { follow_project_links: false } source_package = Package.get_by_project_and_name!(source_project, self.source_package, opts) return if User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end"
98,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package source_package = Package.get_by_project_and_name(source_project, self.source_package) return if !source_package || User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end",True,Ruby,check_action_permission!,bs_request_action_submit.rb,https://github.com/openSUSE/open-build-service,openSUSE,Björn Geuken,2018-07-24 09:42:22+02:00,"Ignore a project link in BsRequestAction.check_action_permission!

This makes sure that we check the permissions of the correct package. For
instance, assume that the project ""Staging"" is a link project where the
link points to the ""Base"" project. Also, assume that there exists a
""Base/foo"" package, but there exists no explicit ""Staging/foo"" package.
Moreover, assume we check the permissions for the following ""submit""
action:

<action type=""submit"">
  <source project=""Staging"" package=""foo""/>
  <target project=""an_arbitrary_project"" package=""foo""/>
</action>

In this case, the old code checks if request acceptor can modify the
""Base/foo"" package (since it follows the project link). This is wrong
because the ""Staging/foo"" package would be turned into a branch during
accept.
The new code checks the correct package because it does not follow the
project link and requires that the source package exists in the source
project. Requiring the existence of the source package potentially
breaks artificial requests (for instance, a request where the ""submit""
action from above is preceded by a ""submit"" action that creates a
""Staging/foo"" package).

Note: so far I was unable to exploit the old code - so this is just
to avoid a potential future headache.

Fixes: commit 990ef7ccc (""[api][webui] Check access to source package"")",CWE-732,Incorrect Permission Assignment for Critical Resource,The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.,https://cwe.mitre.org/data/definitions/732.html,CVE-2018-12467,"def check_action_permission!(skip_source = nil) super(skip_source) # only perform the following check, if we are called from # BsRequest.permission_check_change_state! (that is, if # skip_source is set to true). Always executing this check # would be a regression, because this code is also executed # if a new request is created (which could fail if User.current # cannot modify the source_package). return unless skip_source target_project = Project.get_by_name(self.target_project) return unless target_project && target_project.is_a?(Project) target_package = target_project.packages.find_by_name(self.target_package) initialize_devel_package = target_project.find_attribute('OBS', 'InitializeDevelPackage') return if target_package || !initialize_devel_package opts = { follow_project_links: false } source_package = Package.get_by_project_and_name!(source_project, self.source_package, opts) return if User.current.can_modify?(source_package) msg = 'No permission to initialize the source package as a devel package' raise PostRequestNoPermission, msg end"
102,"def deliver!(mail) envelope_from = mail.return_path || mail.sender || mail.from_addrs.first return_path = ""-f \""#{envelope_from.to_s.shellescape}\"""" if envelope_from arguments = [settings[:arguments], return_path].compact.join("" "") self.class.call(settings[:location], arguments, mail) end",True,Ruby,deliver!,exim.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-06 18:59:38+11:00,Fix security vulnerability allowing command line exploit when using exim or sendmail from the command line,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2012-2140,"def deliver!(mail) envelope_from = mail.return_path || mail.sender || mail.from_addrs.first return_path = ""-f "" + '""' + envelope_from.escape_for_shell + '""' if envelope_from arguments = [settings[:arguments], return_path].compact.join("" "") self.class.call(settings[:location], arguments, mail.destinations.collect(&:shellescape).join("" ""), mail) end"
103,"def Sendmail.call(path, arguments, destinations, mail) IO.popen(""#{path} #{arguments} #{destinations}"", ""w+"") do |io| io.puts mail.encoded.to_lf io.flush end end",True,Ruby,Sendmail.call,sendmail.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-06 18:59:38+11:00,Fix security vulnerability allowing command line exploit when using exim or sendmail from the command line,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2012-2140,"def deliver!(mail) envelope_from = mail.return_path || mail.sender || mail.from_addrs.first return_path = ""-f "" + '""' + envelope_from.escape_for_shell + '""' if envelope_from arguments = [settings[:arguments], return_path].compact.join("" "") self.class.call(settings[:location], arguments, mail.destinations.collect(&:escape_for_shell).join("" ""), mail) end"
104,"def deliver!(mail) envelope_from = mail.return_path || mail.sender || mail.from_addrs.first return_path = ""-f \""#{envelope_from.to_s.gsub('""', '\""')}\"""" if envelope_from arguments = [settings[:arguments], return_path].compact.join("" "") Sendmail.call(settings[:location], arguments, mail.destinations.collect(&:shellescape).join("" ""), mail) end",True,Ruby,deliver!,sendmail.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-06 18:59:38+11:00,Fix security vulnerability allowing command line exploit when using exim or sendmail from the command line,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2012-2140,"it ""should escape evil haxxor attemptes"" do Mail.defaults do delivery_method :sendmail, :arguments => nil end mail = Mail.new do from '""foo\"";touch /tmp/PWNED;\""""@blah.com' to '""foo\"";touch /tmp/PWNED;\""""@blah.com' subject 'invalid RFC2822' end Mail::Sendmail.should_receive(:call).with('/usr/sbin/sendmail', ""-f \""\\\""foo\\\\\\\""\\;touch /tmp/PWNED\\;\\\\\\\""\\\""@blah.com\"""", ""\\\""foo\\\\\\\""\\;touch /tmp/PWNED\\;\\\\\\\""\\\""@blah.com"", mail) mail.deliver! end"
115,"def deliver!(mail) envelope_from = mail.return_path || mail.sender || mail.from_addrs.first return_path = ""-f "" + '""' + envelope_from.escape_for_shell + '""' if envelope_from arguments = [settings[:arguments], return_path].compact.join("" "") self.class.call(settings[:location], arguments, mail.destinations.collect(&:shellescape).join("" ""), mail) end",True,Ruby,deliver!,sendmail.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-06 19:45:23+11:00,Making sure that destinations are also properly escaped in all version of ruby,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2012-2140,"def deliver!(mail) if ::File.respond_to?(:makedirs) ::File.makedirs settings[:location] else ::FileUtils.mkdir_p settings[:location] end mail.destinations.uniq.each do |to| ::File.open(::File.join(settings[:location], File.basename(to.to_s)), 'a') { |f| ""#{f.write(mail.encoded)}\r\n\r\n"" } end end"
118,"it ""should escape evil haxxor attemptes"" do Mail.defaults do delivery_method :sendmail, :arguments => nil end mail = Mail.new do from '""foo\"";touch /tmp/PWNED;\""""@blah.com' to 'marcel@test.lindsaar.net' subject 'invalid RFC2822' end Mail::Sendmail.should_receive(:call).with('/usr/sbin/sendmail', ""-f \""\\\""foo\\\\\\\""\\;touch /tmp/PWNED\\;\\\\\\\""\\\""@blah.com\"""", 'marcel@test.lindsaar.net', mail) mail.deliver! end",True,Ruby,"""should escape evil haxxor attemptes""",sendmail_spec.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-06 19:45:23+11:00,Making sure that destinations are also properly escaped in all version of ruby,CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2012-2140,def name @name end
119,"def deliver!(mail) if ::File.respond_to?(:makedirs) ::File.makedirs settings[:location] else ::FileUtils.mkdir_p settings[:location] end mail.destinations.uniq.each do |to| ::File.open(::File.join(settings[:location], to), 'a') { |f| ""#{f.write(mail.encoded)}\r\n\r\n"" } end end",True,Ruby,deliver!,file_delivery.rb,https://github.com/mikel/mail,mikel,Mikel Lindsaar,2012-03-14 22:44:27+11:00,Preventing file system traversal in file_delivery method,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2012-2139,"def initialize(name, value = nil, charset = 'utf-8') case when name =~ /:/ # Field.new(""field-name: field data"") @charset = value.blank? ? charset : value @name = name[FIELD_PREFIX] @raw_value = name when name !~ /:/ && value.blank? # Field.new(""field-name"") @name = name @value = nil @charset = charset else # Field.new(""field-name"", ""value"") @name = name @value = value @charset = charset end"
124,def name FIELD_NAME_MAP[@name.to_s.downcase] || @name end,True,Ruby,name,field.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,def split_header self.fields = raw_source.split(HEADER_SPLIT) end
126,"def initialize(name, value = nil, charset = 'utf-8') case when name =~ /:/ # Field.new(""field-name: field data"") @charset = value.blank? ? charset : value @name, @value = split(name) when name !~ /:/ && value.blank? # Field.new(""field-name"") @name = name @value = nil @charset = charset else # Field.new(""field-name"", ""value"") @name = name @value = value @charset = charset end",True,Ruby,initialize,field.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,"it ""should raise a warning (and keep parsing) on having an incorrectly formatted header"" do STDERR.should_receive(:puts).with(""WARNING: Could not parse (and so ignoring) 'quite Delivered-To: xxx@xxx.xxx'"") Mail.read(fixture('emails', 'plain_emails', 'raw_email_incorrect_header.eml')).to_s end"
129,"def unfold(string) string.gsub(/#{CRLF}#{WSP}+/, ' ').gsub(/#{WSP}+/, ' ') end",True,Ruby,unfold,header.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,"def match?(name, ip) if ip? if pattern.include?(IPAddr.new(ip)) Puppet.deprecation_warning ""Authentication based on IP address is deprecated; please use certname-based rules instead"" true else false end else matchname?(name) end end"
131,def unfolded_header @unfolded_header ||= unfold(raw_source) end,True,Ruby,unfolded_header,header.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,"def request(args = {}) args = { :key => 'key', :node => 'host.domain.com', :ip => '10.1.1.1', :authenticated => true }.merge(args) ['test', :find, args[:key], args] end"
132,def split_header self.fields = unfolded_header.split(CRLF) end,True,Ruby,split_header,header.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,"def split_path(request) # Reparse the configuration if necessary. readconfig mount_name, path = request.key.split(File::Separator, 2) raise(ArgumentError, ""Cannot find file: Invalid mount '#{mount_name}'"") unless mount_name =~ %r{^[-\w]+$} return nil unless mount = find_mount(mount_name, request.environment) if mount.name == ""modules"" and mount_name != ""modules"" # yay backward-compatibility path = ""#{mount_name}/#{path}"" end if path == """" path = nil elsif path # Remove any double slashes that might have occurred path = path.gsub(/\/+/, ""/"") end return mount, path end"
133,"it ""should raise a warning (and keep parsing) on having an incorrectly formatted header"" do STDERR.should_receive(:puts).with(""WARNING: Could not parse (and so ignoring) 'quite Delivered-To: xxx@xxx.xxx'"") Mail.read(fixture('emails', 'plain_emails', 'raw_email_incorrect_header.eml')) end",True,Ruby,"""should raise a warning (and keep parsing) on having an incorrectly formatted header""",message_spec.rb,https://github.com/mikel/mail,mikel,Conrad Irwin,2013-02-01 23:32:24-08:00,"Also unfold and split lazily

This has little effect on the specs, but on my header reading example it
makes about a 10x performance difference, finally bringing it within one
order of magnitude of the ""fast hacky solution"" at
https://gist.github.com/5901bbd810c08ed3d0b1",CWE-93,Improper Neutralization of CRLF Sequences ('CRLF Injection'),"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",https://cwe.mitre.org/data/definitions/93.html,CVE-2015-9097,"it ""should use the rest terminus when the 'puppet' URI scheme is used and a host name is present"" do uri = ""puppet://myhost/fakemod/my/file"" # It appears that the mocking somehow interferes with the caching subsystem. # This mock somehow causes another terminus to get generated. @indirection.terminus(:rest).expects(:find) @indirection.find(uri) end"
136,"def munge_name(name) # LAK:NOTE http://snurl.com/21zf8 [groups_google_com] # Change to name.downcase.split(""."",-1).reverse for FQDN support name.downcase.split(""."").reverse end",True,Ruby,munge_name,authstore.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:37-07:00,"Deprecate IP-based authentication

This will need to be made explicit in a future version, so it's good to
get people to stop using it if possible.",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2012-3408,"it ""should choose :rest when the Settings name isn't 'puppet'"" do @request.stubs(:protocol).returns ""puppet"" # We have to stub this because we can't set name Puppet.settings.stubs(:value).with(:name).returns ""foo"" @object.select(@request).should == :rest end"
137,"def match?(name, ip) ip? ? pattern.include?(IPAddr.new(ip)) : matchname?(name) end",True,Ruby,match?,authstore.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:37-07:00,"Deprecate IP-based authentication

This will need to be made explicit in a future version, so it's good to
get people to stop using it if possible.",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2012-3408,"it ""should return :file if the request key is fully qualified"" do @request.expects(:key).returns File.expand_path('/foo') @object.select(@request).should == :file end"
141,"def request(args = {}) { :ip => '10.1.1.1', :node => 'host.domain.com', :key => 'key', :authenticated => true }.each do |k,v| args[k] ||= v end ['test', :find, args[:key], args] end",True,Ruby,request,rest_authconfig_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:37-07:00,"Deprecate IP-based authentication

This will need to be made explicit in a future version, so it's good to
get people to stop using it if possible.",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2012-3408,"it ""should fail when a protocol other than :puppet or :file is used"" do @request.stubs(:protocol).returns ""http"" proc { @object.select(@request) }.should raise_error(ArgumentError) end"
143,"def split_path(request) # Reparse the configuration if necessary. readconfig mount_name, path = request.key.split(File::Separator, 2) raise(ArgumentError, ""Cannot find file: Invalid path '#{mount_name}'"") unless mount_name =~ %r{^[-\w]+$} return nil unless mount = find_mount(mount_name, request.environment) if mount.name == ""modules"" and mount_name != ""modules"" # yay backward-compatibility path = ""#{mount_name}/#{path}"" end if path == """" path = nil elsif path # Remove any double slashes that might have occurred path = path.gsub(/\/+/, ""/"") end return mount, path end",True,Ruby,split_path,configuration.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should return :file if the URI protocol is set to 'file'"" do @request.expects(:protocol).returns ""file"" @object.select(@request).should == :file end"
145,"def select_terminus(request) # We rely on the request's parsing of the URI. # Short-circuit to :file if it's a fully-qualified path or specifies a 'file' protocol. return PROTOCOL_MAP[""file""] if Puppet::Util.absolute_path?(request.key) return PROTOCOL_MAP[""file""] if request.protocol == ""file"" # We're heading over the wire the protocol is 'puppet' and we've got a server name or we're not named 'apply' or 'puppet' if request.protocol == ""puppet"" and (request.server or ![""puppet"",""apply""].include?(Puppet.settings[:name])) return PROTOCOL_MAP[""puppet""] end if request.protocol and PROTOCOL_MAP[request.protocol].nil? raise(ArgumentError, ""URI protocol '#{request.protocol}' is not currently supported for file serving"") end # If we're still here, we're using the file_server or modules. :file_server end",True,Ruby,select_terminus,terminus_selector.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should choose :rest when a server is specified"" do @request.stubs(:protocol).returns ""puppet"" @request.expects(:server).returns ""foo"" @object.select(@request).should == :rest end"
156,"it ""should use the rest terminus when the 'puppet' URI scheme is used and a host name is present"" do uri = ""puppet://myhost/fakemod/my/file"" # It appears that the mocking somehow interferes with the caching subsystem. # This mock somehow causes another terminus to get generated. term = @indirection.terminus(:rest) @indirection.stubs(:terminus).with(:rest).returns term term.expects(:find) @indirection.find(uri) end",True,Ruby,"""should use the rest terminus when the 'puppet' URI scheme is used and a host name is present""",file_serving.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should choose :file_server when the settings name is 'puppet' and no server is specified"" do modules = mock 'modules' @request.expects(:protocol).returns ""puppet"" @request.expects(:server).returns nil @object.select(@request).should == :file_server end"
157,"it ""should should be a subclass of Base"" do Puppet::FileServing::Content.superclass.should equal(Puppet::FileServing::Base) end",True,Ruby,"""should should be a subclass of Base""",content_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should use a certificate type of :ca"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[0].should == :ca end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end"
158,"it ""should should include the IndirectionHooks module in its indirection"" do Puppet::FileServing::Content.indirection.singleton_class.included_modules.should include(Puppet::FileServing::IndirectionHooks) end",True,Ruby,"""should should include the IndirectionHooks module in its indirection""",content_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject a non-critical extension that isn't on the whitelist"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""peach"", ""value"" => ""meh"", ""critical"" => false }] expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end"
160,"it ""should should be a subclass of Base"" do Puppet::FileServing::Metadata.superclass.should equal(Puppet::FileServing::Base) end",True,Ruby,"""should should be a subclass of Base""",metadata_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should use the provided CSR's content as the issuer"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[2].subject.to_s.should == ""/CN=myhost"" end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end"
162,"it ""should should include the IndirectionHooks module in its indirection"" do Puppet::FileServing::Metadata.indirection.singleton_class.included_modules.should include(Puppet::FileServing::IndirectionHooks) end",True,Ruby,"""should should include the IndirectionHooks module in its indirection""",metadata_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject a wildcard subjectAltName"" do @request.stubs(:subject_alt_names).returns ['DNS:foo', 'DNS:*.bar'] expect { @ca.check_internal_signing_policies(@name, @request, true) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /subjectAltName contains a wildcard/ ) end"
163,"it ""should choose :rest when the Settings name isn't 'puppet'"" do @request.stubs(:protocol).returns ""puppet"" @request.stubs(:server).returns ""foo"" Puppet.settings.stubs(:value).with(:name).returns ""foo"" @object.select_terminus(@request).should == :rest end",True,Ruby,"""should choose :rest when the Settings name isn't 'puppet'""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should pass the provided CSR as the CSR"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[1].should == @request end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end"
164,"it ""should return :file if the request key is fully qualified"" do @request.expects(:key).returns File.expand_path('/foo') @object.select_terminus(@request).should == :file end",True,Ruby,"""should return :file if the request key is fully qualified""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject a wildcard subject"" do @request.content.stubs(:subject). returns(OpenSSL::X509::Name.new([[""CN"", ""*.local""]])) expect { @ca.check_internal_signing_policies('*.local', @request, false) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /subject contains a wildcard/ ) end"
165,"it ""should fail when a protocol other than :puppet or :file is used"" do @request.stubs(:protocol).returns ""http"" proc { @object.select_terminus(@request) }.should raise_error(ArgumentError) end",True,Ruby,"""should fail when a protocol other than :puppet or :file is used""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject a subjectAltName for a non-DNS value"" do @request.stubs(:subject_alt_names).returns ['DNS:foo', 'email:bar@example.com'] expect { @ca.check_internal_signing_policies(@name, @request, true) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /subjectAltName outside the DNS label space/ ) end"
167,"it ""should return :file if the URI protocol is set to 'file'"" do @request.expects(:protocol).returns ""file"" @object.select_terminus(@request).should == :file end",True,Ruby,"""should return :file if the URI protocol is set to 'file'""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject a critical extension that isn't on the whitelist"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""banana"", ""value"" => ""yumm"", ""critical"" => true }] expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end"
169,"it ""should choose :rest when a server is specified"" do @request.stubs(:protocol).returns ""puppet"" @request.expects(:server).returns ""foo"" @object.select_terminus(@request).should == :rest end",True,Ruby,"""should choose :rest when a server is specified""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should reject non-whitelist extensions even if a valid extension is present"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""peach"", ""value"" => ""meh"", ""critical"" => false }, { ""oid"" => ""subjectAltName"", ""value"" => ""DNS:foo"", ""critical"" => true }] expect { @ca.check_internal_signing_policies(@name, @request, false) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end"
174,"it ""should choose :file_server when the settings name is 'puppet' and no server is specified"" do modules = mock 'modules' @request.expects(:protocol).returns ""puppet"" @request.expects(:server).returns nil Puppet.settings.expects(:value).with(:name).returns ""puppet"" @object.select_terminus(@request).should == :file_server end",True,Ruby,"""should choose :file_server when the settings name is 'puppet' and no server is specified""",terminus_selector_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:11:57-07:00,"Add Selector terminus for file_content/file_metadata

This terminus is now the default, and encapsulates the behavior that was
previously in the IndirectionHooks. That is, we dynamically select the
terminus to use for a file request based on the key. However, for the
puppet master, we instead explicitly always use the FileServer terminus,
so that *all* requests for files from the master will go through
the file server. This ensures that we will never accidentally
serve local files on the puppet master.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2012-3864,"it ""should pass the next serial as the serial number"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[3].should == @serial end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end"
177,"it ""should use a certificate type of :ca"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[0] == :ca end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end",True,Ruby,"""should use a certificate type of :ca""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.destroy(host) if host =~ Regexp.union(/[#{SEPARATOR}]/, /\A\.\.?\Z/) raise ArgumentError, ""Invalid node name #{host.inspect}"" end dir = File.join(Puppet[:reportdir], host) if File.exists?(dir) Dir.entries(dir).each do |file| next if ['.','..'].include?(file) file = File.join(dir, file) File.unlink(file) if File.file?(file) end Dir.rmdir(dir) end end"
181,"it ""should reject a non-critical extension that isn't on the whitelist"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""peach"", ""value"" => ""meh"", ""critical"" => false }] expect { @ca.sign(@name) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end",True,Ruby,"""should reject a non-critical extension that isn't on the whitelist""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def process # We don't want any tracking back in the fs. Unlikely, but there # you go. if host =~ Regexp.union(/[#{SEPARATOR}]/, /\A\.\.?\Z/) raise ArgumentError, ""Invalid node name #{host.inspect}"" end dir = File.join(Puppet[:reportdir], host) if ! FileTest.exists?(dir) FileUtils.mkdir_p(dir) FileUtils.chmod_R(0750, dir) end # Now store the report. now = Time.now.gmtime name = %w{year month day hour min}.collect do |method| # Make sure we're at least two digits everywhere ""%02d"" % now.send(method).to_s end.join("""") + "".yaml"" file = File.join(dir, name) f = Tempfile.new(name, dir) begin begin f.chmod(0640) f.print to_yaml ensure f.close end FileUtils.mv(f.path, file) rescue => detail puts detail.backtrace if Puppet[:trace] Puppet.warning ""Could not write report for #{host} at #{file}: #{detail}"" end # Only testing cares about the return value file end"
182,"it ""should use the provided CSR's content as the issuer"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[2].subject == ""myhost"" end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end",True,Ruby,"""should use the provided CSR's content as the issuer""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.search_by_user(key, operator, value) key_name = key.sub(/^.*\./,'') condition = sanitize_sql_for_conditions([""? #{operator} ?"", key_name, value_to_sql(operator, value)]) users = User.all(:conditions => condition) hosts = users.map(&:hosts).flatten opts = hosts.empty? ? ""< 0"" : ""IN (#{hosts.map(&:id).join(',')})"" return {:conditions => "" hosts.id #{opts} "" } end"
190,"it ""should pass the provided CSR as the CSR"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[1] == @request end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end",True,Ruby,"""should pass the provided CSR as the CSR""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.search_by_puppetclass(key, operator, value) conditions = sanitize_sql_for_conditions([""puppetclasses.name #{operator} ?"", value_to_sql(operator, value)]) hosts = Host.my_hosts.all(:conditions => conditions, :joins => :puppetclasses, :select => 'DISTINCT hosts.id').map(&:id) host_groups = Hostgroup.all(:conditions => conditions, :joins => :puppetclasses, :select => 'DISTINCT hostgroups.id').map(&:id) opts = '' opts += ""hosts.id IN(#{hosts.join(',')})"" unless hosts.blank? opts += "" OR "" unless hosts.blank? || host_groups.blank? opts += ""hostgroups.id IN(#{host_groups.join(',')})"" unless host_groups.blank? opts = ""hosts.id < 0"" if hosts.blank? && host_groups.blank? return {:conditions => opts, :include => :hostgroup} end"
191,"it ""should reject a wildcard subject"" do @request.content.stubs(:subject). returns(OpenSSL::X509::Name.new([[""CN"", ""*.local""]])) expect { @ca.sign(@name) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /subject contains a wildcard/ ) end",True,Ruby,"""should reject a wildcard subject""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.search_by_params(key, operator, value) key_name = key.sub(/^.*\./,'') condition = sanitize_sql_for_conditions([""name = ? and value #{operator} ?"", key_name, value_to_sql(operator, value)]) opts = {:conditions => condition, :order => :priority} p = Parameter.all(opts) return {:conditions => '1 = 0'} if p.blank? max = p.first.priority condition = sanitize_sql_for_conditions([""name = ? and NOT(value #{operator} ?) and priority > ?"",key_name,value_to_sql(operator, value), max]) negate_opts = {:conditions => condition, :order => :priority} n = Parameter.all(negate_opts) conditions = param_conditions(p) negate = param_conditions(n) conditions += "" AND "" unless conditions.blank? || negate.blank? conditions += "" NOT(#{negate})"" unless negate.blank? return {:conditions => conditions} end"
192,"it ""should reject a subjectAltName for a non-DNS value"" do @request.stubs(:subject_alt_names).returns ['DNS:foo', 'email:bar@example.com'] expect { @ca.sign(@name, true) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /subjectAltName outside the DNS label space/ ) end",True,Ruby,"""should reject a subjectAltName for a non-DNS value""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.search_by_host(key, operator, value) conditions = sanitize_sql_for_conditions([""hosts.name #{operator} ?"", value_to_sql(operator, value)]) direct = Puppetclass.joins(:hosts).where(conditions).select('puppetclasses.id').map(&:id).uniq hostgroup = Hostgroup.joins(:hosts).where(conditions).first indirect = HostgroupClass.where(:hostgroup_id => hostgroup.path_ids).pluck(:puppetclass_id).uniq return { :conditions => ""1=0"" } if direct.blank? && indirect.blank? puppet_classes = (direct + indirect).uniq { :conditions => ""puppetclasses.id IN(#{puppet_classes.join(',')})"" } end"
195,"it ""should reject a critical extension that isn't on the whitelist"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""banana"", ""value"" => ""yumm"", ""critical"" => true }] expect { @ca.sign(@name) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end",True,Ruby,"""should reject a critical extension that isn't on the whitelist""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def self.prepare_rdoc root debug, verbose = false, false prepare_script = Pathname.new(Rails.root) + ""script/rdoc_prepare_script.rb"" if prepare_script.executable? dirs = Environment.puppetEnvs.values.join("":"").split("":"").uniq.sort.join("" "") puts ""Running #{prepare_script} #{dirs}"" if debug location = %x{#{prepare_script} #{dirs}} if $? == 0 root = location.chomp puts ""Relocated modules to #{root}"" if verbose end else puts ""No executable #{prepare_script} found so using the uncopied module sources"" if verbose end root end def as_json(options={}) super({:only => [:name, :id], :include => [:lookup_keys]}) end def self.search_by_host(key, operator, value) conditions = sanitize_sql_for_conditions([""hosts.name #{operator} ?"", value_to_sql(operator, value)]) direct = Puppetclass.joins(:hosts).where(conditions).select('puppetclasses.id').map(&:id).uniq hostgroup = Hostgroup.joins(:hosts).where(conditions).first indirect = HostgroupClass.where(:hostgroup_id => hostgroup.path_ids).pluck(:puppetclass_id).uniq return { :conditions => ""1=0"" } if direct.blank? && indirect.blank? puppet_classes = (direct + indirect).uniq { :conditions => ""puppetclasses.id IN(#{puppet_classes.join(',')})"" } end def self.value_to_sql(operator, value) return value if operator !~ /LIKE/i return value.tr_s('%*', '%') if (value ~ /%|\*/) return ""%#{value}%"" end end"
196,"it ""should reject non-whitelist extensions even if a valid extension is present"" do @request.stubs(:request_extensions).returns [{ ""oid"" => ""peach"", ""value"" => ""meh"", ""critical"" => false }, { ""oid"" => ""subjectAltName"", ""value"" => ""DNS:foo"", ""critical"" => true }] expect { @ca.sign(@name) }.to raise_error( Puppet::SSL::CertificateAuthority::CertificateSigningError, /request extensions that are not permitted/ ) end",True,Ruby,"""should reject non-whitelist extensions even if a valid extension is present""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,"def add_label options, f, attr label_size = options.delete(:label_size) || ""col-md-2"" required_mark = check_required(options, f, attr) label = options[:label] == :none ? '' : options.delete(:label) label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) && s_(clazz.gettext_translation_for_attribute_name attr)) if f label = label.present? ? label_tag(attr, ""#{label}#{required_mark}"", :class => label_size + "" control-label"") : '' label end"
197,"it ""should pass the next serial as the serial number"" do Puppet::SSL::CertificateFactory.expects(:build).with do |*args| args[3] == @serial end.returns ""my real cert"" @ca.sign(@name, :ca, @request) end",True,Ruby,"""should pass the next serial as the serial number""",certificate_authority_spec.rb,https://github.com/puppetlabs/puppet,puppetlabs,Nick Lewis,2012-06-26 17:12:28-07:00,"Validate CSR CN and provided certname before signing

This adds a few new checks when signing CSRs, to validate the CN. First,
it must conform to a small set of characters, which are the printable
ASCII characters, except for '/' (because we store these in files). This
prevents attacks such as a CN ""foo^H^H^Hbar"", which appears as ""bar"" to
""puppet cert list"".

The other check is that the certname for the SSL::Host that we think
we're signing must match the CN. This prevents a CSR with the CN ""foo""
from being submitted as a CSR for ""bar"", which would cause it to appear
as ""bar"" to ""puppet cert list"", but to issue a certificate for ""foo"".",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2012-3867,def require_smart_proxy_or_login(features = nil) features = features.call if features.respond_to?(:call) allowed_smart_proxies = if features.blank? SmartProxy.unscoped.all else SmartProxy.unscoped.with_features(*features) end
199,"def self.destroy(host) client = host.gsub("".."",""."") dir = File.join(Puppet[:reportdir], client) if File.exists?(dir) Dir.entries(dir).each do |file| next if ['.','..'].include?(file) file = File.join(dir, file) File.unlink(file) if File.file?(file) end Dir.rmdir(dir) end end",True,Ruby,self.destroy,store.rb,https://github.com/puppetlabs/puppet,puppetlabs,Patrick Carlisle,2012-06-28 14:13:19-07:00,Reject directory traversal in store report processor,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2012-3865,"def auth_smart_proxy(proxies = SmartProxy.unscoped.all, require_cert = true) request_hosts = nil if request.ssl? # If we have the client certficate in the request environment we can extract the dn and sans from there # if not we use the dn in the request environment # SAN validation requires ""SSLOptions +ExportCertData"" in Apache httpd if request.env.has_key?(Setting[:ssl_client_cert_env]) && request.env[Setting[:ssl_client_cert_env]].present? logger.debug ""Examining client certificate to extract dn and sans"" cert_raw = request.env[Setting[:ssl_client_cert_env]] certificate = CertificateExtract.new(cert_raw) logger.debug ""Client sent certificate with subject '#{certificate.subject}' and subject alt names '#{certificate.subject_alternative_names.inspect}'"" else dn = request.env[Setting[:ssl_client_dn_env]] end if (dn && dn =~ /CN=([^\s\/,]+)/i) || certificate verify = request.env[Setting[:ssl_client_verify_env]] if verify == 'SUCCESS' # If the client sent certificate contains a subject or sans, use them for request_hosts, else fall back to the dn set in the request environment request_hosts = [] if certificate if certificate.subject_alternative_names.present? request_hosts += certificate.subject_alternative_names elsif certificate.subject request_hosts << certificate.subject end else request_hosts << $1 if $1 end else logger.warn ""SSL cert has not been verified (#{verify}) - request from #{request.ip}, #{dn}"" end elsif require_cert logger.warn ""No SSL cert with CN supplied - request from #{request.ip}, #{dn}"" else request_hosts = Resolv.new.getnames(request.ip) end elsif SETTINGS[:require_ssl] logger.warn ""SSL is required - request from #{request.ip}"" else request_hosts = Resolv.new.getnames(request.ip) end return false unless request_hosts hosts = Hash[proxies.map { |p| [URI.parse(p.url).host, p] }] allowed_hosts = hosts.keys.push(*Setting[:trusted_puppetmaster_hosts]) logger.debug { (""Verifying request from #{request_hosts.inspect} against #{allowed_hosts.inspect}"") } if (host = detect_matching_host(allowed_hosts, request_hosts)) @detected_proxy = hosts[host] if host true else logger.warn ""No smart proxy server found on #{request_hosts.inspect} and is not in trusted_puppetmaster_hosts"" false end end"
200,"def process # We don't want any tracking back in the fs. Unlikely, but there # you go. client = self.host.gsub("".."",""."") dir = File.join(Puppet[:reportdir], client) if ! FileTest.exists?(dir) FileUtils.mkdir_p(dir) FileUtils.chmod_R(0750, dir) end # Now store the report. now = Time.now.gmtime name = %w{year month day hour min}.collect do |method| # Make sure we're at least two digits everywhere ""%02d"" % now.send(method).to_s end.join("""") + "".yaml"" file = File.join(dir, name) f = Tempfile.new(name, dir) begin begin f.chmod(0640) f.print to_yaml ensure f.close end FileUtils.mv(f.path, file) rescue => detail puts detail.backtrace if Puppet[:trace] Puppet.warning ""Could not write report for #{client} at #{file}: #{detail}"" end # Only testing cares about the return value file end",True,Ruby,process,store.rb,https://github.com/puppetlabs/puppet,puppetlabs,Patrick Carlisle,2012-06-28 14:13:19-07:00,Reject directory traversal in store report processor,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2012-3865,"def verify_active_session if !request.post? && params[:status].blank? && User.unscoped.exists?(session[:user].presence) warning _(""You have already logged in"") redirect_back_or_to hosts_path return end end"
204,"def self.search_by_user(key, operator, value) key_name = key.sub(/^.*\./,'') users = User.all(:conditions => ""#{key_name} #{operator} '#{value_to_sql(operator, value)}'"") hosts = users.map(&:hosts).flatten opts = hosts.empty? ? ""= 'nil'"" : ""IN (#{hosts.map(&:id).join(',')})"" return {:conditions => "" hosts.id #{opts} "" } end",True,Ruby,self.search_by_user,search.rb,https://github.com/theforeman/foreman,theforeman,Ohad Levy,2012-12-19 12:38:18+02:00,Fix Foreman SQL injection through search mechanism CVE-2012-5648,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2012-5648,"def taxable_ids(loc = which_location, org = which_organization, inner_method = which_ancestry_method) # Return everything (represented by nil), including objects without # taxonomies. This value should only be returned for admin users. return nil if any_context?(loc) && any_context?(org) && User.current.try(:admin?) ids = unscoped.pluck(:id) ids &= inner_ids(loc, Location, inner_method) if SETTINGS[:locations_enabled] ids &= inner_ids(org, Organization, inner_method) if SETTINGS[:organizations_enabled] if self == User # In the case of users we want the taxonomy scope to get both the users # of the taxonomy, admins, and the current user. ids.concat(admin_ids) ids << User.current.id if User.current.present? end ids end"
206,"def self.search_by_puppetclass(key, operator, value) conditions = ""puppetclasses.name #{operator} '#{value_to_sql(operator, value)}'"" hosts = Host.my_hosts.all(:conditions => conditions, :joins => :puppetclasses, :select => 'DISTINCT hosts.id').map(&:id) host_groups = Hostgroup.all(:conditions => conditions, :joins => :puppetclasses, :select => 'DISTINCT hostgroups.id').map(&:id) opts = '' opts += ""hosts.id IN(#{hosts.join(',')})"" unless hosts.blank? opts += "" OR "" unless hosts.blank? || host_groups.blank? opts += ""hostgroups.id IN(#{host_groups.join(',')})"" unless host_groups.blank? opts = ""hosts.id < 0"" if hosts.blank? && host_groups.blank? return {:conditions => opts, :include => :hostgroup} end",True,Ruby,self.search_by_puppetclass,search.rb,https://github.com/theforeman/foreman,theforeman,Ohad Levy,2012-12-19 12:38:18+02:00,Fix Foreman SQL injection through search mechanism CVE-2012-5648,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2012-5648,def self.taxonomy_conditions org = Organization.expand(Organization.current) if SETTINGS[:organizations_enabled] loc = Location.expand(Location.current) if SETTINGS[:locations_enabled] conditions = {} conditions[:organization_id] = Array(org).map { |o| o.subtree_ids }.flatten.uniq unless org.nil? conditions[:location_id] = Array(loc).map { |l| l.subtree_ids }.flatten.uniq unless loc.nil? conditions end
211,"def self.search_by_params(key, operator, value) key_name = key.sub(/^.*\./,'') opts = {:conditions => ""name = '#{key_name}' and value #{operator} '#{value_to_sql(operator, value)}'"", :order => :priority} p = Parameter.all(opts) return {:conditions => '1 = 0'} if p.blank? max = p.first.priority negate_opts = {:conditions => ""name = '#{key_name}' and NOT(value #{operator} '#{value_to_sql(operator, value)}') and priority > #{max}"", :order => :priority} n = Parameter.all(negate_opts) conditions = param_conditions(p) negate = param_conditions(n) conditions += "" AND "" unless conditions.blank? || negate.blank? conditions += "" NOT(#{negate})"" unless negate.blank? return {:conditions => conditions} end",True,Ruby,self.search_by_params,search.rb,https://github.com/theforeman/foreman,theforeman,Ohad Levy,2012-12-19 12:38:18+02:00,Fix Foreman SQL injection through search mechanism CVE-2012-5648,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2012-5648,def current_user User.unscoped.except_hidden.find_by_login(self.user) end
213,"def self.search_by_host(key, operator, value) conditions = ""hosts.name #{operator} '#{value_to_sql(operator, value)}'"" direct = Puppetclass.all(:conditions => conditions, :joins => :hosts, :select => 'puppetclasses.id').map(&:id).uniq hostgroup = Hostgroup.joins(:hosts).where(conditions).first indirect = HostgroupClass.where(:hostgroup_id => hostgroup.path_ids).pluck(:puppetclass_id).uniq return { :conditions => ""1=0"" } if direct.blank? && indirect.blank? puppet_classes = (direct + indirect).uniq { :conditions => ""puppetclasses.id IN(#{puppet_classes.join(',')})"" } end",True,Ruby,self.search_by_host,puppetclass.rb,https://github.com/theforeman/foreman,theforeman,Ohad Levy,2012-12-19 12:38:18+02:00,Fix Foreman SQL injection through search mechanism CVE-2012-5648,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2012-5648,"def authenticate! unless Setting['oauth_active'] Rails.logger.warn 'Trying to authenticate with OAuth, but OAuth is not active' return nil end unless (incoming_key = OAuth::RequestProxy.proxy(request).oauth_consumer_key) == Setting['oauth_consumer_key'] Rails.logger.warn ""oauth_consumer_key should be '#{Setting['oauth_consumer_key']}' but was '#{incoming_key}'"" return nil end if OAuth::Signature.verify(request, :consumer_secret => Setting['oauth_consumer_secret']) if Setting['oauth_map_users'] user_name = request.headers['HTTP_FOREMAN_USER'].to_s User.unscoped.find_by_login(user_name).tap do |obj| Rails.logger.warn ""Oauth: mapping to user '#{user_name}' failed"" if obj.nil? end.try(:login) else User::ANONYMOUS_API_ADMIN end else Rails.logger.warn ""OAuth signature verification failed."" return nil end end"
215,"def self.prepare_rdoc root debug, verbose = false, false prepare_script = Pathname.new(Rails.root) + ""script/rdoc_prepare_script.rb"" if prepare_script.executable? dirs = Environment.puppetEnvs.values.join("":"").split("":"").uniq.sort.join("" "") puts ""Running #{prepare_script} #{dirs}"" if debug location = %x{#{prepare_script} #{dirs}} if $? == 0 root = location.chomp puts ""Relocated modules to #{root}"" if verbose end else puts ""No executable #{prepare_script} found so using the uncopied module sources"" if verbose end root end def as_json(options={}) super({:only => [:name, :id], :include => [:lookup_keys]}) end def self.search_by_host(key, operator, value) conditions = ""hosts.name #{operator} '#{value_to_sql(operator, value)}'"" direct = Puppetclass.all(:conditions => conditions, :joins => :hosts, :select => 'puppetclasses.id').map(&:id).uniq hostgroup = Hostgroup.joins(:hosts).where(conditions).first indirect = HostgroupClass.where(:hostgroup_id => hostgroup.path_ids).pluck(:puppetclass_id).uniq return { :conditions => ""1=0"" } if direct.blank? && indirect.blank? puppet_classes = (direct + indirect).uniq { :conditions => ""puppetclasses.id IN(#{puppet_classes.join(',')})"" } end def self.value_to_sql(operator, value) return value if operator !~ /LIKE/i return value.tr_s('%*', '%') if (value ~ /%|\*/) return ""%#{value}%"" end end",True,Ruby,self.prepare_rdoc,puppetclass.rb,https://github.com/theforeman/foreman,theforeman,Ohad Levy,2012-12-19 12:38:18+02:00,Fix Foreman SQL injection through search mechanism CVE-2012-5648,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2012-5648,"def selected_ids return @selected_ids if @selected_ids ids = default_ids_hash #types NOT ignored - get ids that are selected hash_keys.each do |col| ids[col] = Array(taxonomy.send(col)).uniq end #types that ARE ignored - get ALL ids for object Array(taxonomy.ignore_types).each do |taxonomy_type| ids[""#{taxonomy_type.tableize.singularize}_ids""] = taxonomy_type.constantize.pluck(:id).uniq end ids[""#{opposite_taxonomy_type}_ids""] = Array(taxonomy.send(""#{opposite_taxonomy_type}_ids"")) @selected_ids = ids end"
216,"def add_label options, f, attr label_size = options.delete(:label_size) || ""col-md-2"" required_mark = check_required(options, f, attr) label = options[:label] == :none ? '' : options.delete(:label) label ||= ((clazz = f.object.class).respond_to?(:gettext_translation_for_attribute_name) && s_(clazz.gettext_translation_for_attribute_name attr)) if f label = label.present? ? label_tag(attr, ""#{label}#{required_mark}"".html_safe, :class => label_size + "" control-label"") : '' label end",True,Ruby,add_label,form_helper.rb,https://github.com/theforeman/foreman,theforeman,Daniel Lobato,2016-08-10 12:26:59+02:00,Fixes #16024 - escape labels of form fields,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2016-6319,def default_ids_hash(populate_values = false) ids = HashWithIndifferentAccess.new hash_keys.each do |col| ids[col] = populate_values ? Array(self.send(col)).uniq : [] end ids end
219,"def auth_smart_proxy(proxies = SmartProxy.all, require_cert = true) request_hosts = nil if request.ssl? # If we have the client certficate in the request environment we can extract the dn and sans from there # if not we use the dn in the request environment # SAN validation requires ""SSLOptions +ExportCertData"" in Apache httpd if request.env.has_key?(Setting[:ssl_client_cert_env]) && request.env[Setting[:ssl_client_cert_env]].present? logger.debug ""Examining client certificate to extract dn and sans"" cert_raw = request.env[Setting[:ssl_client_cert_env]] certificate = CertificateExtract.new(cert_raw) logger.debug ""Client sent certificate with subject '#{certificate.subject}' and subject alt names '#{certificate.subject_alternative_names.inspect}'"" else dn = request.env[Setting[:ssl_client_dn_env]] end if (dn && dn =~ /CN=([^\s\/,]+)/i) || certificate verify = request.env[Setting[:ssl_client_verify_env]] if verify == 'SUCCESS' # If the client sent certificate contains a subject or sans, use them for request_hosts, else fall back to the dn set in the request environment request_hosts = [] if certificate if certificate.subject_alternative_names.present? request_hosts += certificate.subject_alternative_names elsif certificate.subject request_hosts << certificate.subject end else request_hosts << $1 if $1 end else logger.warn ""SSL cert has not been verified (#{verify}) - request from #{request.ip}, #{dn}"" end elsif require_cert logger.warn ""No SSL cert with CN supplied - request from #{request.ip}, #{dn}"" else request_hosts = Resolv.new.getnames(request.ip) end elsif SETTINGS[:require_ssl] logger.warn ""SSL is required - request from #{request.ip}"" else request_hosts = Resolv.new.getnames(request.ip) end return false unless request_hosts hosts = Hash[proxies.map { |p| [URI.parse(p.url).host, p] }] allowed_hosts = hosts.keys.push(*Setting[:trusted_puppetmaster_hosts]) logger.debug { (""Verifying request from #{request_hosts.inspect} against #{allowed_hosts.inspect}"") } if (host = detect_matching_host(allowed_hosts, request_hosts)) @detected_proxy = hosts[host] if host true else logger.warn ""No smart proxy server found on #{request_hosts.inspect} and is not in trusted_puppetmaster_hosts"" false end end",True,Ruby,auth_smart_proxy,smart_proxy_auth.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def setup_user(operation, type = """", search = nil, user = :one) @one = users(user) as_admin do permission = Permission.find_by_name(""#{operation}_#{type}"") || FactoryGirl.create(:permission, :name => ""#{operation}_#{type}"") filter = FactoryGirl.build(:filter, :search => search) filter.permissions = [ permission ] role = Role.where(:name => ""#{operation}_#{type}"").first_or_create role.filters = [ filter ] role.save! filter.role = role filter.save! @one.roles << role yield(@one) if block_given? @one.save! end User.current = @one end"
222,"def verify_active_session if !request.post? && params[:status].blank? && User.exists?(session[:user].presence) warning _(""You have already logged in"") redirect_back_or_to hosts_path return end end",True,Ruby,verify_active_session,users_controller.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"it ""requires an account with mail"" do as_admin do @user = FactoryGirl.create(:user) end get :index, {}, set_session_user.merge(:user => @user.id) assert_response :redirect assert_redirected_to edit_user_path(@user) assert_equal ""An email address is required, please update your account details"", flash[:error] end"
225,"def taxable_ids(loc = which_location, org = which_organization, inner_method = which_ancestry_method) if SETTINGS[:locations_enabled] && loc.present? inner_ids_loc = if Location.ignore?(self.to_s) self.unscoped.pluck(""#{table_name}.id"") else inner_select(loc, inner_method) end end",True,Ruby,taxable_ids,taxonomix.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_invalid AuthSourceLdap.any_instance.stubs(:valid?).returns(false) put :update, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user assert_template 'edit' end"
227,"def with_taxonomy_scope(loc = Location.current, org = Organization.current, inner_method = :subtree_ids) self.which_ancestry_method = inner_method self.which_location = Location.expand(loc) if SETTINGS[:locations_enabled] self.which_organization = Organization.expand(org) if SETTINGS[:organizations_enabled] scope = block_given? ? yield : where('1=1') scope = scope_by_taxable_ids(scope) scope.readonly(false) end",True,Ruby,with_taxonomy_scope,taxonomix.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_destroy auth_source_ldap = AuthSourceLdap.unscoped.first User.unscoped.where(:auth_source_id => auth_source_ldap.id).update_all(:auth_source_id => nil) delete :destroy, {:id => auth_source_ldap}, set_session_user assert_redirected_to auth_source_ldaps_url refute AuthSourceLdap.unscoped.exists?(auth_source_ldap.id) end"
231,def self.taxonomy_conditions org = Organization.expand(Organization.current) if SETTINGS[:organizations_enabled] loc = Location.expand(Location.current) if SETTINGS[:locations_enabled] conditions = {} conditions[:organization_id] = Array(org).map { |o| o.subtree_ids }.flatten.uniq if org.present? conditions[:location_id] = Array(loc).map { |l| l.subtree_ids }.flatten.uniq if loc.present? conditions end,True,Ruby,self.taxonomy_conditions,base.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_create_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(true) post :create, {:auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name}}, set_session_user assert_redirected_to auth_source_ldaps_url end"
233,def current_user User.except_hidden.find_by_login(self.user) end,True,Ruby,current_user,base.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_formats_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(false) put :update, {:id => AuthSourceLdap.unscoped.first.id, :format => ""weird"", :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user assert_response :success wierd_id = ""#{AuthSourceLdap.unscoped.first.id}.weird"" put :update, {:id => wierd_id, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user assert_response :success parameterized_id = ""#{AuthSourceLdap.unscoped.first.id}-#{AuthSourceLdap.unscoped.first.name.parameterize}"" put :update, {:id => parameterized_id, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user assert_response :success end"
234,"def authenticate! unless Setting['oauth_active'] Rails.logger.warn 'Trying to authenticate with OAuth, but OAuth is not active' return nil end unless (incoming_key = OAuth::RequestProxy.proxy(request).oauth_consumer_key) == Setting['oauth_consumer_key'] Rails.logger.warn ""oauth_consumer_key should be '#{Setting['oauth_consumer_key']}' but was '#{incoming_key}'"" return nil end if OAuth::Signature.verify(request, :consumer_secret => Setting['oauth_consumer_secret']) if Setting['oauth_map_users'] user_name = request.headers['HTTP_FOREMAN_USER'].to_s User.find_by_login(user_name).tap do |obj| Rails.logger.warn ""Oauth: mapping to user '#{user_name}' failed"" if obj.nil? end.try(:login) else User::ANONYMOUS_API_ADMIN end else Rails.logger.warn ""OAuth signature verification failed."" return nil end end",True,Ruby,authenticate!,oauth.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(true) put :update, {:id => AuthSourceLdap.unscoped.first, :auth_source_ldap => {:name => AuthSourceLdap.unscoped.first.name} }, set_session_user assert_redirected_to auth_source_ldaps_url end"
236,"def selected_ids return @selected_ids if @selected_ids ids = default_ids_hash #types NOT ignored - get ids that are selected hash_keys.each do |col| ids[col] = Array(taxonomy.send(col)) end #types that ARE ignored - get ALL ids for object Array(taxonomy.ignore_types).each do |taxonomy_type| ids[""#{taxonomy_type.tableize.singularize}_ids""] = taxonomy_type.constantize.pluck(:id) end ids[""#{opposite_taxonomy_type}_ids""] = Array(taxonomy.send(""#{opposite_taxonomy_type}_ids"")) @selected_ids = ids end",True,Ruby,selected_ids,tax_host.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def user_with_viewer_rights_should_fail_to_edit_a_domain setup_users get :edit, {:id => @model.id} assert @response.status == '403 Forbidden' end"
239,def default_ids_hash(populate_values = false) ids = HashWithIndifferentAccess.new hash_keys.each do |col| ids[col] = populate_values ? Array(self.send(col)) : [] end ids end,True,Ruby,default_ids_hash,tax_host.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_invalid Domain.any_instance.stubs(:valid?).returns(false) put :update, {:id => @model.to_param, :domain => {:name => @model.name }}, set_session_user assert_template 'edit' end"
244,"def setup_user(operation, type = """", search = nil, user = :one) @one = users(user) as_admin do permission = Permission.find_by_name(""#{operation}_#{type}"") || FactoryGirl.create(:permission, :name => ""#{operation}_#{type}"") filter = FactoryGirl.build(:filter, :search => search) filter.permissions = [ permission ] role = Role.where(:name => ""#{operation}_#{type}"").first_or_create role.filters = [ filter ] role.save! filter.role = role filter.save! @one.roles << role yield(@one) if block_given? @one.save! end User.current = @one end",True,Ruby,setup_user,active_support_test_case_helper.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_destroy domain = @model domain.hosts.clear domain.hostgroups.clear domain.subnets.clear delete :destroy, {:id => domain}, set_session_user assert_redirected_to domains_url assert !Domain.exists?(domain.id) end"
246,"it ""requires an account with mail"" do user = FactoryGirl.create(:user) get :index, {}, set_session_user.merge(:user => user.id) assert_response :redirect assert_redirected_to edit_user_path(user) assert_equal ""An email address is required, please update your account details"", flash[:error] end",True,Ruby,"""requires an account with mail""",application_controller_subclass_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_edit get :edit, {:id => hostgroups(:common)}, set_session_user assert_template 'edit' end"
247,"def test_update_invalid AuthSourceLdap.any_instance.stubs(:valid?).returns(false) put :update, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user assert_template 'edit' end",True,Ruby,test_update_invalid,auth_source_ldaps_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_invalid put :update, {:id => hostgroups(:common), :hostgroup => { :name => '' }}, set_session_user assert_template 'edit' end"
249,"def test_destroy auth_source_ldap = AuthSourceLdap.first User.where(:auth_source_id => auth_source_ldap.id).update_all(:auth_source_id => nil) delete :destroy, {:id => auth_source_ldap}, set_session_user assert_redirected_to auth_source_ldaps_url assert !AuthSourceLdap.exists?(auth_source_ldap.id) end",True,Ruby,test_destroy,auth_source_ldaps_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_clone get :clone, {:id => hostgroups(:common)}, set_session_user assert_template 'new' end"
250,"def test_create_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(true) post :create, {:auth_source_ldap => {:name => AuthSourceLdap.first.name}}, set_session_user assert_redirected_to auth_source_ldaps_url end",True,Ruby,test_create_valid,auth_source_ldaps_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"it ""updates a hostgroup with a parent parameter, allows empty values"" do child = FactoryGirl.create(:hostgroup, :parent => @base) as_admin do assert_equal ""original"", child.parameters[""x""] end post :update, {""id"" => child.id, ""hostgroup"" => {""name"" => child.name, :group_parameters_attributes => {""0"" => {:name => ""x"", :value => """", :_destroy => """"}, ""1"" => {:name => ""y"", :value => ""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url as_admin do child.reload assert_equal ""overridden"", child.parameters[""y""] assert_equal """", child.parameters[""x""] end end"
251,"def test_formats_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(false) put :update, {:id => AuthSourceLdap.first.id, :format => ""weird"", :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user assert_response :success wierd_id = ""#{AuthSourceLdap.first.id}.weird"" put :update, {:id => wierd_id, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user assert_response :success parameterized_id = ""#{AuthSourceLdap.first.id}-#{AuthSourceLdap.first.name.parameterize}"" put :update, {:id => parameterized_id, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user assert_response :success end",True,Ruby,test_formats_valid,auth_source_ldaps_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"it ""creates a hostgroup with a parent parameter"" do post :create, {""hostgroup"" => {""name""=>""test_it"", ""parent_id"" => @base.id, :realm_id => realms(:myrealm).id, :group_parameters_attributes => {""0"" => {:name => ""x"", :value =>""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url hostgroup = Hostgroup.unscoped.where(:name => ""test_it"").last as_admin do assert_equal ""overridden"", hostgroup.parameters[""x""] end end"
252,"def test_update_valid AuthSourceLdap.any_instance.stubs(:valid?).returns(true) put :update, {:id => AuthSourceLdap.first, :auth_source_ldap => {:name => AuthSourceLdap.first.name} }, set_session_user assert_redirected_to auth_source_ldaps_url end",True,Ruby,test_update_valid,auth_source_ldaps_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid put :update, {:id => hostgroups(:common), :hostgroup => { :name => hostgroups(:common).name }}, set_session_user assert_redirected_to hostgroups_url end"
257,"def user_with_viewer_rights_should_fail_to_edit_a_domain setup_users get :edit, {:id => Domain.first.id} assert @response.status == '403 Forbidden' end",True,Ruby,user_with_viewer_rights_should_fail_to_edit_a_domain,domains_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"it ""updates a hostgroup with a parent parameter"" do child = FactoryGirl.create(:hostgroup, :parent => @base) as_admin do assert_equal ""original"", child.parameters[""x""] end post :update, {""id"" => child.id, ""hostgroup"" => {""name"" => child.name, :group_parameters_attributes => {""0"" => {:name => ""x"", :value =>""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url as_admin do child.reload assert_equal ""overridden"", child.parameters[""x""] end end"
258,"def test_update_invalid Domain.any_instance.stubs(:valid?).returns(false) put :update, {:id => Domain.first.to_param, :domain => {:name => Domain.first.name }}, set_session_user assert_template 'edit' end",True,Ruby,test_update_invalid,domains_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_nest get :nest, {:id => hostgroups(:common).id}, set_session_user assert_template 'new' end"
260,"def test_update_valid Domain.any_instance.stubs(:valid?).returns(true) put :update, {:id => Domain.first.to_param, :domain => {:name => Domain.first.name }}, set_session_user assert_redirected_to domains_url end",True,Ruby,test_update_valid,domains_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid Medium.any_instance.stubs(:valid?).returns(true) put :update, {:id => @model, :medium => {:name => ""MyUpdatedMedia""}}, set_session_user assert_redirected_to media_url end"
262,"def test_destroy domain = Domain.first domain.hosts.clear domain.hostgroups.clear domain.subnets.clear delete :destroy, {:id => domain}, set_session_user assert_redirected_to domains_url assert !Domain.exists?(domain.id) end",True,Ruby,test_destroy,domains_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_invalid Medium.any_instance.stubs(:valid?).returns(false) put :update, {:id => @model, :medium => {:name => nil}}, set_session_user assert_template 'edit' end"
266,"def test_edit get :edit, {:id => Hostgroup.first}, set_session_user assert_template 'edit' end",True,Ruby,test_edit,hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid Realm.any_instance.stubs(:valid?).returns(true) realm_id = Realm.unscoped.first.id proxy_id = SmartProxy.unscoped.first.id put :update, {:id => realm_id, :realm => { :realm_proxy_id => proxy_id } }, set_session_user assert_equal proxy_id, Realm.unscoped.find(realm_id).realm_proxy_id assert_redirected_to realms_url end"
270,"def test_update_invalid put :update, {:id => Hostgroup.first, :hostgroup => { :name => '' }}, set_session_user assert_template 'edit' end",True,Ruby,test_update_invalid,hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid SmartProxy.any_instance.stubs(:valid?).returns(true) put :update, {:id => SmartProxy.unscoped.first, :smart_proxy => {:url => ""http://elsewhere.com:8443""}}, set_session_user assert_equal ""http://elsewhere.com:8443"", SmartProxy.unscoped.first.url assert_redirected_to smart_proxies_url end"
273,"def test_clone get :clone, {:id => Hostgroup.first}, set_session_user assert_template 'new' end",True,Ruby,test_clone,hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_destroy @model.hosts.clear @model.interfaces.clear @model.domains.clear delete :destroy, {:id => @model}, set_session_user assert_redirected_to subnets_url refute Subnet.exists?(@model.id) end"
274,"it ""updates a hostgroup with a parent parameter, allows empty values"" do child = FactoryGirl.create(:hostgroup, :parent => @base) as_admin do assert_equal ""original"", child.parameters[""x""] end post :update, {""id"" => child.id, ""hostgroup"" => {""name"" => child.name, :group_parameters_attributes => {""0"" => {:name => ""x"", :value => """", :_destroy => """"}, ""1"" => {:name => ""y"", :value => ""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url child.reload assert_equal ""overridden"", child.parameters[""y""] assert_equal """", child.parameters[""x""] end",True,Ruby,"""updates a hostgroup with a parent parameter, allows empty values""",hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_valid Subnet.any_instance.stubs(:valid?).returns(true) put :update, {:id => @model, :subnet => {:network => '192.168.100.10'}}, set_session_user assert_equal '192.168.100.10', Subnet.unscoped.find(@model).network assert_redirected_to subnets_url end"
276,"it ""creates a hostgroup with a parent parameter"" do post :create, {""hostgroup"" => {""name""=>""test_it"", ""parent_id"" => @base.id, :realm_id => realms(:myrealm).id, :group_parameters_attributes => {""0"" => {:name => ""x"", :value =>""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url hostgroup = Hostgroup.where(:name => ""test_it"").last assert_equal ""overridden"", hostgroup.parameters[""x""] end",True,Ruby,"""creates a hostgroup with a parent parameter""",hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_should_not_destroy_if_used_by_hosts subnet = subnets(:one) delete :destroy, {:id => subnet}, set_session_user assert_redirected_to subnets_url assert Subnet.unscoped.exists?(subnet.id) end"
277,"def test_update_valid put :update, {:id => Hostgroup.first, :hostgroup => { :name => Hostgroup.first.name }}, set_session_user assert_redirected_to hostgroups_url end",True,Ruby,test_update_valid,hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def test_update_invalid Subnet.any_instance.stubs(:valid?).returns(false) subnet_id = @model put :update, {:id => subnet_id, :subnet => {:network => nil}}, set_session_user assert_template 'edit' end"
278,"it ""updates a hostgroup with a parent parameter"" do child = FactoryGirl.create(:hostgroup, :parent => @base) as_admin do assert_equal ""original"", child.parameters[""x""] end post :update, {""id"" => child.id, ""hostgroup"" => {""name"" => child.name, :group_parameters_attributes => {""0"" => {:name => ""x"", :value =>""overridden"", :_destroy => """"}}}}, set_session_user assert_redirected_to hostgroups_url child.reload assert_equal ""overridden"", child.parameters[""x""] end",True,Ruby,"""updates a hostgroup with a parent parameter""",hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def setup FactoryGirl.create(:host, :location => nil) end"
280,"def test_nest get :nest, {:id => Hostgroup.first.id}, set_session_user assert_template 'new' end",True,Ruby,test_nest,hostgroups_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def setup FactoryGirl.create(:host, :organization => nil) end"
281,"def test_update_valid Medium.any_instance.stubs(:valid?).returns(true) put :update, {:id => Medium.first, :medium => {:name => ""MyUpdatedMedia""}}, set_session_user assert_redirected_to media_url end",True,Ruby,test_update_valid,media_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def seed # Authorisation is disabled usually when run from a rake db:* task User.current = FactoryGirl.build(:user, :admin => true, :organizations => [], :locations => []) load File.expand_path('../../../../db/seeds.rb', __FILE__) end"
284,"def test_update_invalid Medium.any_instance.stubs(:valid?).returns(false) put :update, {:id => Medium.first, :medium => {:name => nil}}, set_session_user assert_template 'edit' end",True,Ruby,test_update_invalid,media_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def fast_forward_to_first_boundary loop do content = @io.read(BUFSIZE) raise EOFError, ""bad content body"" unless content @buf << content while @buf.gsub!(/\A([^\n]*\n)/, '') read_buffer = $1 return if read_buffer == full_boundary end raise EOFError, ""bad content body"" if Utils.bytesize(@buf) >= BUFSIZE end end"
286,"def test_update_valid Realm.any_instance.stubs(:valid?).returns(true) put :update, {:id => Realm.first.name, :realm => { :realm_proxy_id => SmartProxy.first.id } }, set_session_user assert_equal SmartProxy.first.id, Realm.first.realm_proxy_id assert_redirected_to realms_url end",True,Ruby,test_update_valid,realms_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def digest_match?(data, digest) return unless data && digest @secrets.any? do |secret| Rack::Utils.secure_compare(digest, generate_hmac(data, secret)) end end"
288,"def test_update_valid SmartProxy.any_instance.stubs(:valid?).returns(true) put :update, {:id => SmartProxy.first,:smart_proxy => {:url => ""http://elsewhere.com:8443""}}, set_session_user assert_equal ""http://elsewhere.com:8443"", SmartProxy.first.url assert_redirected_to smart_proxies_url end",True,Ruby,test_update_valid,smart_proxies_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def _call(env) unless ALLOWED_VERBS.include? env[""REQUEST_METHOD""] return fail(405, ""Method Not Allowed"") end path_info = Utils.unescape(env[""PATH_INFO""]) parts = path_info.split SEPS clean = [] parts.each do |part| next if part.empty? || part == '.' part == '..' ? clean.pop : clean << part end @path = F.join(@root, *clean) available = begin F.file?(@path) && F.readable?(@path) rescue SystemCallError false end if available serving(env) else fail(404, ""File not found: #{path_info}"") end end"
292,"def test_destroy subnet = Subnet.first subnet.hosts.clear subnet.interfaces.clear subnet.domains.clear delete :destroy, {:id => subnet}, set_session_user assert_redirected_to subnets_url assert !Subnet.exists?(subnet.id) end",True,Ruby,test_destroy,subnets_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"it 'should only print each format once with an exception' do lambda do @klass.format :foobar end.should raise_error(HTTParty::UnsupportedFormat, ""':foobar' Must be one of: html, json, plain, xml"") end"
293,"def test_update_valid Subnet.any_instance.stubs(:valid?).returns(true) put :update, {:id => Subnet.first, :subnet => {:network => '192.168.100.10'}}, set_session_user assert_equal '192.168.100.10', Subnet.first.network assert_redirected_to subnets_url end",True,Ruby,test_update_valid,subnets_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def render_step(the_step, options = {}) if the_step.nil? || the_step.to_s == Wicked::FINISH_STEP redirect_to_finish_wizard options else render ERB::Util.url_encode(the_step), options end end"
294,"def test_should_not_destroy_if_used_by_hosts subnet = subnets(:one) delete :destroy, {:id => subnet}, set_session_user assert_redirected_to subnets_url assert Subnet.exists?(subnet.id) end",True,Ruby,test_should_not_destroy_if_used_by_hosts,subnets_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def create File.open(resource[:path], ""w"", mode) { |f| f << expected_content } end"
295,"def test_update_invalid Subnet.any_instance.stubs(:valid?).returns(false) put :update, {:id => Subnet.first, :subnet => {:network => nil}}, set_session_user assert_template 'edit' end",True,Ruby,test_update_invalid,subnets_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def call(exception, locale, key, options) if exception.is_a?(MissingTranslation) # # TODO: this block is to be replaced by `exception.message` when # rescue_format is removed if options[:rescue_format] == :html if @rescue_format_deprecation $stderr.puts ""[DEPRECATED] I18n's :recue_format option will be removed from a future release. All exception messages will be plain text. If you need the exception handler to return an html format please set or pass a custom exception handler."" @rescue_format_deprecation = true end exception.html_message else exception.message end elsif exception.is_a?(Exception) raise exception else throw :exception, exception end end"
297,"def setup_user @request.session[:user] = users(:one).id users(:one).roles = [Role.default, Role.find_by_name('Viewer')] end",True,Ruby,setup_user,variable_lookup_keys_controller_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def initialize(locale, key, options = nil) @key, @locale, @options = key, locale, options.dup || {} options.each { |k, v| self.options[k] = v.inspect if v.is_a?(Proc) } end def html_message key = CGI.escape_html titleize(keys.last) path = CGI.escape_html keys.join('.') %(<span class=""translation_missing"" title=""translation missing: #{path}"">#{key}</span>) end def keys @keys ||= I18n.normalize_keys(locale, key, options[:scope]).tap do |keys| keys << 'no key' if keys.size < 2 end end def message ""translation missing: #{keys.join('.')}"" end alias :to_s :message def to_exception MissingTranslationData.new(locale, key, options) end protected # TODO : remove when #html_message is removed def titleize(key) key.to_s.gsub('_', ' ').gsub(/\b('?[a-z])/) { $1.capitalize } end end include Base end"
298,def setup FactoryGirl.create(:host) end,True,Ruby,setup,location_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,"def html_message key = CGI.escape_html titleize(keys.last) path = CGI.escape_html keys.join('.') %(<span class=""translation_missing"" title=""translation missing: #{path}"">#{key}</span>) end def keys @keys ||= I18n.normalize_keys(locale, key, options[:scope]).tap do |keys| keys << 'no key' if keys.size < 2 end end def message ""translation missing: #{keys.join('.')}"" end alias :to_s :message def to_exception MissingTranslationData.new(locale, key, options) end protected # TODO : remove when #html_message is removed def titleize(key) key.to_s.gsub('_', ' ').gsub(/\b('?[a-z])/) { $1.capitalize } end end"
301,def setup FactoryGirl.create(:host) end,True,Ruby,setup,organization_test.rb,https://github.com/theforeman/foreman,theforeman,Tomer Brisker,2017-02-22 10:26:06+02:00,"Fixes #16982 - Scope properly when no taxonomies are set

The default scope for hosts and other objects did not restrict
properly by taxonomies. An user without organizations or
locations, could do anything it's permissions allow to.
The list of hosts was unrestricted and showed hosts in
any location or organization.

This is fixed to work so that:

Users without taxonomies, when set to 'any context' cannot see
anything (at all)

Users with taxonomies, when set to 'any context' can see
everything within all of their taxonomies context (including
children taxonomies).

Admins set to 'any context' can see everything - regardless
of whether it has a taxonomy or not.

Users or admins set to some organization/location scope
can only see stuff within scope.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-7078,def authorize_params super.tap do |params| %w[display scope].each do |v| if request.params[v] params[v.to_sym] = request.params[v] end end params[:scope] ||= DEFAULT_SCOPE end end
305,"def fast_forward_to_first_boundary loop do read_buffer = @io.gets break if read_buffer == full_boundary raise EOFError, ""bad content body"" if read_buffer.nil? end end",True,Ruby,fast_forward_to_first_boundary,parser.rb,https://github.com/rack/rack,rack,James Tucker,2013-01-07 10:17:35-08:00,"multipart/parser: avoid unbounded #gets method

Malicious clients may send excessively long lines
to trigger out-of-memory errors in a Rack web server.",CWE-119,Improper Restriction of Operations within the Bounds of a Memory Buffer,"The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.",https://cwe.mitre.org/data/definitions/119.html,CVE-2013-0183,"def index respond_to do |format| format.json do dir = params[:dir] dir = 'DESC' unless SORT_DIRECTIONS.include?(dir.try(:upcase)) @occurrences = @bug.occurrences.order(""occurred_at #{dir}"").limit(50) last = params[:last].present? ? @bug.occurrences.find_by_number(params[:last]) : nil @occurrences = @occurrences.where(infinite_scroll_clause('occurred_at', dir, last, 'occurrences.number')) if last render json: decorate(@occurrences) end format.atom { @occurrences = @bug.occurrences.order('occurred_at DESC').limit(100) } # index.atom.builder end end"
310,"def digest_match?(data, digest) return unless data && digest @secrets.any? do |secret| digest == generate_hmac(data, secret) end end",True,Ruby,digest_match?,cookie.rb,https://github.com/rack/rack,rack,James Tucker,2013-02-07 14:47:10-08:00,"Use secure_compare for hmac comparison

 * Closes CVE-2013-0263",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2013-0263,def create_event(comment) Event.create! do |event| event.bug_id = comment.bug_id event.kind = 'comment' event.data = {'comment_id' => comment.id} event.user_id = comment.user_id end end
313,"def _call(env) unless ALLOWED_VERBS.include? env[""REQUEST_METHOD""] return fail(405, ""Method Not Allowed"") end path_info = Utils.unescape(env[""PATH_INFO""]) parts = path_info.split SEPS parts.inject(0) do |depth, part| case part when '', '.' depth when '..' return fail(404, ""Not Found"") if depth - 1 < 0 depth - 1 else depth + 1 end end",True,Ruby,_call,file.rb,https://github.com/rack/rack,rack,James Tucker,2013-02-07 18:36:09-08:00,"Prevent symlink path traversals

 * Closes CVE-2013-0262",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2013-0262,"def timeline state = params[:state].to_s if %w(Collapsed Expanded).include?(state) if (model_type = params[:type].to_s).present? if %w(comment email).include?(model_type) model = model_type.camelize.constantize item = model.find(params[:id]) item.update_attribute(:state, state) end else comments, emails = params[:id].split(""+"") Comment.where(:id => comments.split(',')).update_all(:state => state) unless comments.blank? Email.where(:id => emails.split(',')).update_all(:state => state) unless emails.blank? end end render :nothing => true end"
314,def yaml YAML.load(body) end,True,Ruby,yaml,parser.rb,https://github.com/jnunemaker/httparty,jnunemaker,John Nunemaker,2013-01-10 15:45:09-05:00,Remove yaml due to possible security risk.,CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-1801,"it ""should not display completed tasks"" do task_1 = FactoryGirl.create(:task, :user_id => current_user.id, :name => ""Your first task"", :bucket => ""due_asap"", :assigned_to => current_user.id) task_2 = FactoryGirl.create(:task, :user_id => current_user.id, :name => ""Completed task"", :bucket => ""due_asap"", :completed_at => 1.days.ago, :completed_by => current_user.id, :assigned_to => current_user.id) get :index assigns[:my_tasks].should == [task_1] end"
315,"it ""parses yaml"" do YAML.should_receive(:load).with('body') subject.send(:yaml) end",True,Ruby,"""parses yaml""",parser_spec.rb,https://github.com/jnunemaker/httparty,jnunemaker,John Nunemaker,2013-01-10 15:45:09-05:00,Remove yaml due to possible security risk.,CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-1801,"def activity_user user = current_user.pref[:activity_user] if user && user != ""all_users"" user = if user =~ /@/ # email User.where(:email => user).first else # first_name middle_name last_name any_name name_query = if user.include?("" "") user.name_permutations.map{ |first, last| User.where(:first_name => first, :last_name => last) }.map(&:to_a).flatten.first else [User.where(:first_name => user), User.where(:last_name => user)].map(&:to_a).flatten.first end end"
316,"it 'should handle yaml automatically' do yaml = ""books: \n book: \n name: Foo Bar!\n id: \""1234\""\n"" @request.options[:format] = :yaml @request.send(:parse_response, yaml).should == {'books' => {'book' => {'id' => '1234', 'name' => 'Foo Bar!'}}} end",True,Ruby,'should handle yaml automatically',request_spec.rb,https://github.com/jnunemaker/httparty,jnunemaker,John Nunemaker,2013-01-10 15:45:09-05:00,Remove yaml due to possible security risk.,CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-1801,"it ""should find a user by first name or last name"" do @cur_user.stub(:pref).and_return(:activity_user => 'Billy') controller.instance_variable_set(:@current_user, @cur_user) User.should_receive(:where).with(:first_name => 'Billy').and_return([@user]) User.should_receive(:where).with(:last_name => 'Billy').and_return([@user]) controller.send(:activity_user).should == 1 end"
317,"it ""should allow yaml"" do @klass.format :yaml @klass.default_options[:format].should == :yaml end",True,Ruby,"""should allow yaml""",httparty_spec.rb,https://github.com/jnunemaker/httparty,jnunemaker,John Nunemaker,2013-01-10 15:45:09-05:00,Remove yaml due to possible security risk.,CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-1801,"it ""should find a user by first name and last name"" do @cur_user.stub(:pref).and_return(:activity_user => 'Billy Elliot') controller.instance_variable_set(:@current_user, @cur_user) User.should_receive(:where).with(:first_name => 'Billy', :last_name => ""Elliot"").and_return([@user]) User.should_receive(:where).with(:first_name => 'Elliot', :last_name => ""Billy"").and_return([@user]) controller.send(:activity_user).should == 1 end"
318,"it 'should only print each format once with an exception' do lambda do @klass.format :foobar end.should raise_error(HTTParty::UnsupportedFormat, ""':foobar' Must be one of: html, json, plain, xml, yaml"") end",True,Ruby,'should only print each format once with an exception',httparty_spec.rb,https://github.com/jnunemaker/httparty,jnunemaker,John Nunemaker,2013-01-10 15:45:09-05:00,Remove yaml due to possible security risk.,CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-1801,"def tags_for_index(model) model.tags.inject("""".html_safe) do |out, tag| query = controller.send(:current_query) || """" hashtag = ""##{tag}"" if query.empty? query = hashtag elsif !query.include?(hashtag) query += "" #{hashtag}"" end out << link_to_function(tag, ""crm.search_tagged('#{escape_javascript(query)}', '#{model.class.to_s.tableize}')"", title: tag) end end"
327,"def render_step(the_step, options = {}) if the_step.nil? || the_step.to_s == Wicked::FINISH_STEP redirect_to_finish_wizard options else render the_step, options end end",True,Ruby,render_step,render_redirect.rb,https://github.com/schneems/wicked,schneems,schneems,2013-10-08 12:03:12-05:00,"[close #94] Security Update

Prevent specially crafted url strings from being used to access unintended files via an escaped slash character `%2e`",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2013-4413,"def generate(type, str) case type when :md5 attribute_value = '{MD5}' + Base64.encode64(Digest::MD5.digest(str)).chomp! when :sha attribute_value = '{SHA}' + Base64.encode64(Digest::SHA1.digest(str)).chomp! when :ssha srand; salt = SecureRandom.random_bytes(16) attribute_value = '{SSHA}' + Base64.encode64(Digest::SHA1.digest(str + salt) + salt).chomp! else raise Net::LDAP::HashTypeUnsupportedError, ""Unsupported password-hash type (#{type})"" end"
330,"def create File.open(resource[:path], ""w"") { |f| f << expected_content } end",True,Ruby,create,katello_ssl_tool.rb,https://github.com/Katello/katello-installer,Katello,Ivan Necas,2013-10-22 09:04:02+02:00,"1021119 - make sure private keys are never world readable

This should prevent similar mistakes in future.",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2013-4455,"def build_command_line(command, params = nil) CommandLineBuilder.new.build(command, params) end"
334,"def initialize(locale, key, options = nil) @key, @locale, @options = key, locale, options.dup || {} options.each { |k, v| self.options[k] = v.inspect if v.is_a?(Proc) } end def html_message key = keys.last.to_s.gsub('_', ' ').gsub(/\b('?[a-z])/) { $1.capitalize } %(<span class=""translation_missing"" title=""translation missing: #{keys.join('.')}"">#{key}</span>) end def keys @keys ||= I18n.normalize_keys(locale, key, options[:scope]).tap do |keys| keys << 'no key' if keys.size < 2 end end def message ""translation missing: #{keys.join('.')}"" end",True,Ruby,initialize,exceptions.rb,https://github.com/svenfuchs/i18n,svenfuchs,Christopher Dell,2013-12-03 17:24:04+01:00,"The I18n::MissingTranslation exception escapes key names for its html_message

Also added deprecation message for the :rescue_format option",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2013-4492,"def execute(statement, bind_vars = []) Environment.logger.info(""Executing: "" + statement) super(statement, bind_vars) end"
336,"def html_message key = keys.last.to_s.gsub('_', ' ').gsub(/\b('?[a-z])/) { $1.capitalize } %(<span class=""translation_missing"" title=""translation missing:",True,Ruby,html_message,exceptions.rb,https://github.com/svenfuchs/i18n,svenfuchs,Christopher Dell,2013-12-03 17:24:04+01:00,"The I18n::MissingTranslation exception escapes key names for its html_message

Also added deprecation message for the :rescue_format option",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2013-4492,"def self.execute_and_instantiate(statement, bind_vars = []) rows = Environment.database_connection.execute(statement, bind_vars) results = [] rows.each do |row| results << Injury.new(row[""name""]) end results end"
340,def authorize_params super.tap do |params| %w[display state scope].each do |v| if request.params[v] params[v.to_sym] = request.params[v] # to support omniauth-oauth2's auto csrf protection session['omniauth.state'] = params[:state] if v == 'state' end end params[:scope] ||= DEFAULT_SCOPE end end,True,Ruby,authorize_params,facebook.rb,https://github.com/mkdynamic/omniauth-facebook,mkdynamic,Mark Dodwell,2013-11-12 13:15:58-08:00,fix CSRF vulnerability. prepare 1.5.0 release,CWE-352,Cross-Site Request Forgery (CSRF),"The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.",https://cwe.mitre.org/data/definitions/352.html,CVE-2013-4562,"def self.find_by_name(name) statement = ""Select * from injuries where name = ?;"" execute_and_instantiate(statement, name)[0] end"
345,"def index respond_to do |format| format.json do dir = params[:dir] dir = 'desc' unless SORT_DIRECTIONS.include?(dir.try(:upcase)) @occurrences = @bug.occurrences.order(""occurred_at #{dir}"").limit(50) last = params[:last].present? ? @bug.occurrences.find_by_number(params[:last]) : nil @occurrences = @occurrences.where(infinite_scroll_clause('occurred_at', dir, last, 'occurrences.number')) if last render json: decorate(@occurrences) end format.atom { @occurrences = @bug.occurrences.order('occurred_at DESC').limit(100) } # index.atom.builder end end",True,Ruby,index,occurrences_controller.rb,https://github.com/SquareSquash/web,SquareSquash,Tim Morgan,2013-06-24 20:05:30-07:00,CodeClimate-recommended security fixes,CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2013-5036,def current_user_existing_vote @vote = current_user.votes.find_by(votable_id: params[:id]) end
346,"def create_event(comment) Event.create! bug_id: comment.bug_id, kind: 'comment', data: {'comment_id' => comment.id}, user_id: comment.user_id end",True,Ruby,create_event,comment_observer.rb,https://github.com/SquareSquash/web,SquareSquash,Tim Morgan,2013-06-24 20:05:30-07:00,CodeClimate-recommended security fixes,CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2013-5036,def current_user_existing_vote # @vote = current_user.votes.find_by(post_id: params[:id]) @vote = current_user.votes.find_by(votable_id: params[:id]) end
356,"it ""recognizes and generates #index"" do { :get => ""/users"" }.should route_to(:controller => ""users"", :action => ""index"") end",True,Ruby,"""recognizes and generates #index""",users_routing_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 13:57:00+08:00,Add custom serializers for xml and json.,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2013-7224,"def select_transfer_files(transfer_id) sql = "" SELECT fb_file_status.transfer_id, fb_file_status.filename, fb_file_status.status_time, fb_file_status_dict.status_id, fb_file_status_dict.status_desc, fb_file_status_dict.status_type FROM public.fb_file_status, public.fb_file_status_dict WHERE fb_file_status.status_id = fb_file_status_dict.status_id AND fb_file_status.transfer_id = $1::int ORDER BY fb_file_status.filename ASC"" @db.exec(sql, [transfer_id]) end"
357,"it ""recognizes and generates #index"" do { :get => ""/users"" }.should route_to(:controller => ""users"", :action => ""index"") end",True,Ruby,"""recognizes and generates #index""",users_routing_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 13:57:00+08:00,Add custom serializers for xml and json.,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2013-7249,"def update_file_status(transfer_id, file, status_id, status_time) sql_count = ""SELECT * FROM fb_file_status WHERE transfer_id=$1::int AND filename=$2::text"" if @db.exec(sql_count, [transfer_id, file]).count > 0 sql_update = ""UPDATE fb_file_status SET status_id=$1::int, status_time=$2::timestamp WHERE transfer_id=$3::int AND filename=$4::text"" @db.exec(sql_update, [status_id, status_time, transfer_id, file]) else insert_file_status(transfer_id, file, status_id, status_time) end end"
358,"it ""recognizes and generates #destroy"" do { :delete => ""/users/1"" }.should route_to(:controller => ""users"", :action => ""destroy"", :id => ""1"") end",True,Ruby,"""recognizes and generates #destroy""",users_routing_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 13:57:00+08:00,Add custom serializers for xml and json.,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2013-7224,"def insert_file_status(transfer_id, file, status_id, status_time) sql = ""INSERT into fb_file_status (transfer_id, filename, status_id, status_time) VALUES ($1::int, $2::text, $3::int, $4::timestamp)"" @db.exec(sql, [transfer_id, file, status_id, status_time]) end"
359,"it ""recognizes and generates #destroy"" do { :delete => ""/users/1"" }.should route_to(:controller => ""users"", :action => ""destroy"", :id => ""1"") end",True,Ruby,"""recognizes and generates #destroy""",users_routing_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 13:57:00+08:00,Add custom serializers for xml and json.,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2013-7249,"def do_list(soap_body) begin prefix = soap_body.root.namespace.prefix req = {} req['protocol'] = soap_body.xpath(""//#{prefix}:Protocol/text()"").to_s.downcase req['address'] = soap_body.xpath(""//#{prefix}:Address/text()"").to_s req['port'] = soap_body.xpath(""//#{prefix}:Port/text()"").to_s req['login'] = soap_body.xpath(""//#{prefix}:Login/text()"").to_s req['password'] = soap_body.xpath(""//#{prefix}:Password/text()"").to_s req['path'] = soap_body.xpath(""//#{prefix}:Path/text()"").to_s req['filter_out_transferred'] = soap_body.xpath(""//#{prefix}:FilterOutTransferred/text()"").to_s begin source = @db.select_account(req) rescue Database::AccountNotExist source = @db.insert_account(req) end list = [] if req['protocol'] == 'cifs' conn = Connector::CIFS.new conn.address = req['address'] conn.login = req['login'] conn.password = req['password'] conn.share = req['path'].split('/')[1] conn.connect conn.cd(req['path']) list = conn.list(req['path']) conn.disconnect elsif req['protocol'] == 'ftp' conn = Connector::FTP.new conn.address = req['address'] conn.port = req['port'] conn.login = req['login'] conn.password = req['password'] conn.connect list = conn.list(req['path']) conn.disconnect elsif req['protocol'] == 'sftp' conn = Connector::SFTP.new conn.address = req['address'] conn.port = req['port'] conn.login = req['login'] conn.password = req['password'] conn.connect list = conn.list(req['path']) conn.disconnect end # Convert time format list.map { |j| j['mtime'] = DateTime.parse(j['mtime']) } # Remove currently transferring files @db.select_running_transfers_by_source(FBService::TRANSFER_RUNNING, source['account_id'], source['path']).each { |i| @db.select_transfer_files(i['transfer_id']).each { |j| list.delete_if { |k| k['name'] == j['filename'] } } } # Remove already transferred files - optional depends on FilterOutTransferred option if source['filter_out_transferred'] == 'true' list.delete_if { |k| @db.select_files_by_transfer_status(FBService::TRANSFER_COMPLETED_SUCCESSFULLY, source['account_id'], source['path'], k['name']).ntuples() > 0 } end # Remove temporary files list.delete_if { |j| j['name'] =~ /\.partial$/ } builder(:list_response, :locals => { :list => list }) rescue err_msg = ""#{$!.backtrace.join(""\n"")}\n#{$!.message}\n"" @stderr_mutex.try_lock 80.times { STDERR.print '-' } STDERR.puts STDERR.puts ""Exception time: #{DateTime.parse(Time.now.to_s)}"" STDERR.puts err_msg 80.times { STDERR.print '-' } STDERR.puts @stderr_mutex.unlock builder(:fault, :locals => { :fault_string => 'failed to list directory', :fault_code => 'Server' }) end end"
364,"def timeline unless params[:type].empty? model = params[:type].camelize.constantize item = model.find(params[:id]) item.update_attribute(:state, params[:state]) else comments, emails = params[:id].split(""+"") Comment.update_all(""state = '#{params[:state]}'"", ""id IN (#{comments})"") unless comments.blank? Email.update_all(""state = '#{params[:state]}'"", ""id IN (#{emails})"") unless emails.blank? end render :nothing => true end",True,Ruby,timeline,home_controller.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 15:06:58+08:00,Fixed sql injection in timeline method.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2013-7225,def show @images = Image.where(:sol => params[:sol]) end
370,"it ""should not display completed tasks"" do task_1 = FactoryGirl.create(:task, :user_id => current_user.id, :name => ""Your first task"", :bucket => ""due_asap"", :assigned_to => current_user.id) task_2 = FactoryGirl.create(:task, :user_id => current_user.id, :name => ""Completed task"", :bucket => ""due_asap"", :completed_at => 1.days.ago, :completed_by => current_user.id, :assigned_to => current_user.id) get :index assigns[:my_tasks].should == [task_1] end",True,Ruby,"""should not display completed tasks""",home_controller_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 15:06:58+08:00,Fixed sql injection in timeline method.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2013-7225,def index # find the martian solar date of the most recent image taken @image_count = Image.count @most_recent = Image.maximum(:sol) end
374,"def activity_user user = current_user.pref[:activity_user] if user && user != ""all_users"" user = if user =~ /@/ # email User.where(:email => user).first else # first_name middle_name last_name any_name name_query = if user.include?("" "") user.name_permutations.map{ |first, last| ""(upper(first_name) LIKE upper('%#{first}%') AND upper(last_name) LIKE upper('%#{last}%'))"" }.join("" OR "") else ""upper(first_name) LIKE upper('%#{user}%') OR upper(last_name) LIKE upper('%#{user}%')"" end User.where(name_query).first end",True,Ruby,activity_user,home_controller.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 15:41:55+08:00,Refactor activity_user to remove possible SQL injection points.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2013-7225,"def redirect_back_or_default(default, options={}) back_url = params[:back_url].to_s if back_url.present? begin uri = URI.parse(back_url) # do not redirect user to another host or to the login or register page if ((uri.relative? && back_url.match(%r{\A/\w})) || (uri.host == request.host)) && !uri.path.match(%r{/(login|account/register)}) redirect_to(back_url) return end rescue URI::InvalidURIError logger.warn(""Could not redirect to invalid URL #{back_url}"") # redirect to default end elsif options[:referer] redirect_to_referer_or default return end redirect_to default false end"
376,"it ""should find a user by first name or last name"" do @cur_user.stub(:pref).and_return(:activity_user => 'Billy') controller.instance_variable_set(:@current_user, @cur_user) User.should_receive(:where).with(""upper(first_name) LIKE upper('%Billy%') OR upper(last_name) LIKE upper('%Billy%')"").and_return([@user]) controller.send(:activity_user).should == 1 end",True,Ruby,"""should find a user by first name or last name""",home_controller_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 15:41:55+08:00,Refactor activity_user to remove possible SQL injection points.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2013-7225,"def test_login_should_not_redirect_to_another_host back_urls = [ 'http://test.foo/fake', '//test.foo/fake' ] back_urls.each do |back_url| post :login, :username => 'jsmith', :password => 'jsmith', :back_url => back_url assert_redirected_to '/my/page' end end"
379,"it ""should find a user by first name and last name"" do @cur_user.stub(:pref).and_return(:activity_user => 'Billy Elliot') controller.instance_variable_set(:@current_user, @cur_user) User.should_receive(:where).with(""(upper(first_name) LIKE upper('%Billy%') AND upper(last_name) LIKE upper('%Elliot%')) OR (upper(first_name) LIKE upper('%Elliot%') AND upper(last_name) LIKE upper('%Billy%'))"").and_return([@user]) controller.send(:activity_user).should == 1 end",True,Ruby,"""should find a user by first name and last name""",home_controller_spec.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2013-12-27 15:41:55+08:00,Refactor activity_user to remove possible SQL injection points.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2013-7225,"def redirect_back_or_default(default, options={}) back_url = params[:back_url].to_s if back_url.present? && valid_url = validate_back_url(back_url) redirect_to(valid_url) return elsif options[:referer] redirect_to_referer_or default return end redirect_to default false end"
381,"def tags_for_index(model) model.tags.inject("""".html_safe) do |out, tag| query = controller.send(:current_query) || """" hashtag = ""##{tag}"" if query.empty? query = hashtag elsif !query.include?(hashtag) query += "" #{hashtag}"" end out << link_to_function(tag, ""crm.search_tagged('#{query}', '#{model.class.to_s.tableize}')"", title: tag) end end",True,Ruby,tags_for_index,tags_helper.rb,https://github.com/fatfreecrm/fat_free_crm,fatfreecrm,Steve Kenworthy,2018-10-27 10:22:06+08:00,Context-sensitive XSS bugfix.,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-20975,def valid_back_url?(back_url) !!validate_back_url(back_url) end
383,"def generate(type, str) case type when :md5 attribute_value = '{MD5}' + Base64.encode64(Digest::MD5.digest(str)).chomp! when :sha attribute_value = '{SHA}' + Base64.encode64(Digest::SHA1.digest(str)).chomp! when :ssha srand; salt = (rand * 1000).to_i.to_s attribute_value = '{SSHA}' + Base64.encode64(Digest::SHA1.digest(str + salt) + salt).chomp! else raise Net::LDAP::HashTypeUnsupportedError, ""Unsupported password-hash type (#{type})"" end",True,Ruby,generate,password.rb,https://github.com/ruby-ldap/ruby-net-ldap,ruby-ldap,Tatsuya Sato,2015-01-07 08:43:48+09:00,Use SecureRandam to generate salt,CWE-916,Use of Password Hash With Insufficient Computational Effort,"The product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.",https://cwe.mitre.org/data/definitions/916.html,CVE-2014-0083,"def test_login_with_suburi_should_not_redirect_to_another_suburi @relative_url_root = Redmine::Utils.relative_url_root Redmine::Utils.relative_url_root = '/redmine' back_urls = [ 'http://test.host/', 'http://test.host/fake', 'http://test.host/fake/issues', 'http://test.host/redmine/../fake', 'http://test.host/redmine/../fake/issues', 'http://test.host/redmine/%2e%2e/fake', '//test.foo/fake', 'http://test.host//fake', 'http://test.host/\n//fake', '//bar@test.foo', '//test.foo', '////test.foo', '@test.foo', 'fake@test.foo' ] back_urls.each do |back_url| post :login, :username => 'jsmith', :password => 'jsmith', :back_url => back_url assert_redirected_to '/my/page' end ensure Redmine::Utils.relative_url_root = @relative_url_root end"
384,"def sanitize(params) return [] if params.nil? || params.empty? params.collect do |k, v| [sanitize_key(k), sanitize_value(v)] end end",True,Ruby,sanitize,awesome_spawn.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def self.reminders(options={}) days = options[:days] || 7 project = options[:project] ? Project.find(options[:project]) : nil tracker = options[:tracker] ? Tracker.find(options[:tracker]) : nil target_version_id = options[:version] ? Version.named(options[:version]).pluck(:id) : nil if options[:version] && target_version_id.blank? raise ActiveRecord::RecordNotFound.new(""Couldn't find Version with named #{options[:version]}"") end user_ids = options[:users] scope = Issue.open.where(""#{Issue.table_name}.assigned_to_id IS NOT NULL"" + "" AND #{Project.table_name}.status = #{Project::STATUS_ACTIVE}"" + "" AND #{Issue.table_name}.due_date <= ?"", days.day.from_now.to_date ) scope = scope.where(:assigned_to_id => user_ids) if user_ids.present? scope = scope.where(:project_id => project.id) if project scope = scope.where(:fixed_version_id => target_version_id) if target_version_id.present? scope = scope.where(:tracker_id => tracker.id) if tracker issues_by_assignee = scope.includes(:status, :assigned_to, :project, :tracker). group_by(&:assigned_to) issues_by_assignee.keys.each do |assignee| if assignee.is_a?(Group) assignee.users.each do |user| issues_by_assignee[user] ||= [] issues_by_assignee[user] += issues_by_assignee[assignee] end end end issues_by_assignee.each do |assignee, issues| if assignee.is_a?(User) && assignee.active? && issues.present? visible_issues = issues.select {|i| i.visible?(assignee)} reminder(assignee, visible_issues, days).deliver if visible_issues.present? end end end"
385,"def build_command_line(command, params = nil) return command.to_s if params.nil? || params.empty? ""#{command} #{assemble_params(sanitize(params))}"" end",True,Ruby,build_command_line,awesome_spawn.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def column_content(column, item) value = column.value_object(item) if value.is_a?(Array) values = value.collect {|v| column_value(column, item, v)}.compact safe_join(values, ', ') else column_value(column, item, value) end end"
386,"def sanitize_key(key) case key when Symbol then ""--#{key.to_s.tr(""_"", ""-"")}"" else key end",True,Ruby,sanitize_key,awesome_spawn.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def format_object(object, html=true, &block) if block_given? object = yield object end case object.class.name when 'Array' formatted_objects = object.map {|o| format_object(o, html)} html ? safe_join(formatted_objects, ', ') : formatted_objects.join(', ') when 'Time' format_time(object) when 'Date' format_date(object) when 'Fixnum' object.to_s when 'Float' sprintf ""%.2f"", object when 'User' html ? link_to_user(object) : object.to_s when 'Project' html ? link_to_project(object) : object.to_s when 'Version' html ? link_to_version(object) : object.to_s when 'TrueClass' l(:general_text_Yes) when 'FalseClass' l(:general_text_No) when 'Issue' object.visible? && html ? link_to_issue(object) : ""##{object.id}"" when 'Attachment' html ? link_to_attachment(object) : object.filename when 'CustomValue', 'CustomFieldValue' if object.custom_field f = object.custom_field.format.formatted_custom_value(self, object, html) if f.nil? || f.is_a?(String) f else format_object(f, html, &block) end else object.value.to_s end else html ? h(object) : object.to_s end"
388,"def assemble_params(sanitized_params) sanitized_params.collect do |pair| pair_joiner = pair.first.to_s.end_with?(""="") ? """" : "" "" pair.flatten.compact.join(pair_joiner) end.join("" "") end",True,Ruby,assemble_params,awesome_spawn.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def diff(path, identifier_from, identifier_to=nil) hg_args = %w|rhdiff| if identifier_to hg_args << '-r' << hgrev(identifier_to) << '-r' << hgrev(identifier_from) else hg_args << '-c' << hgrev(identifier_from) end unless path.blank? p = scm_iconv(@path_encoding, 'UTF-8', path) hg_args << '--' << CGI.escape(hgtarget(p)) end diff = [] hg *hg_args do |io| io.each_line do |line| diff << line end end diff rescue HgCommandAborted nil # means not found end"
389,def sanitize_value(value) case value when Array then value.collect { |i| i.to_s.shellescape } when NilClass then value else value.to_s.shellescape end,True,Ruby,sanitize_value,awesome_spawn.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={}) hg_args = ['log', '--debug', '-C', '--style', self.class.template_path] hg_args << '-r' << ""#{hgrev(identifier_from)}:#{hgrev(identifier_to)}"" hg_args << '--limit' << options[:limit] if options[:limit] hg_args << '--' << hgtarget(path) unless path.blank? log = hg(*hg_args) do |io| output = io.read.force_encoding('UTF-8') begin # Mercurial < 1.5 does not support footer template for '</log>' parse_xml(""#{output}</log>"")['log'] rescue end end as_ary(log['logentry']).each do |le| cpalist = as_ary(le['paths']['path-copied']).map do |e| [e['__content__'], e['copyfrom-path']].map do |s| scm_iconv('UTF-8', @path_encoding, CGI.unescape(s)) end end cpmap = Hash[*cpalist.flatten] paths = as_ary(le['paths']['path']).map do |e| p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) ) {:action => e['action'], :path => with_leading_slash(p), :from_path => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil), :from_revision => (cpmap.member?(p) ? le['node'] : nil)} end.sort { |a, b| a[:path] <=> b[:path] } parents_ary = [] as_ary(le['parents']['parent']).map do |par| parents_ary << par['__content__'] if par['__content__'] != ""0000000000000000000000000000000000000000"" end yield Revision.new(:revision => le['revision'], :scmid => le['node'], :author => (le['author']['__content__'] rescue ''), :time => Time.parse(le['date']['__content__']), :message => le['msg']['__content__'], :paths => paths, :parents => parents_ary) end self end"
395,"it ""handles Symbol keys with underscore"" do cl = subject.build_command_line(""true"", :abc_def => ""ghi"") expect(cl).to eq ""true --abc-def ghi"" end",True,Ruby,"""handles Symbol keys with underscore""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def annotate(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) blame = Annotate.new hg 'rhannotate', '-ncu', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io| io.each_line do |line| line.force_encoding('ASCII-8BIT') next unless line =~ %r{^([^:]+)\s(\d+)\s([0-9a-f]+):\s(.*)$} r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3, :identifier => $3) blame.add_line($4.rstrip, r) end end blame rescue HgCommandAborted # means not found or cannot be annotated Annotate.new end"
396,"it ""sanitizes Fixnum array param value"" do cl = subject.build_command_line(""true"", nil => [1]) expect(cl).to eq ""true 1"" end",True,Ruby,"""sanitizes Fixnum array param value""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def entries(path=nil, identifier=nil, options={}) p1 = scm_iconv(@path_encoding, 'UTF-8', path) manifest = hg('rhmanifest', '-r', CGI.escape(hgrev(identifier)), '--', CGI.escape(without_leading_slash(p1.to_s))) do |io| output = io.read.force_encoding('UTF-8') begin parse_xml(output)['rhmanifest']['repository']['manifest'] rescue end end path_prefix = path.blank? ? '' : with_trailling_slash(path) entries = Entries.new as_ary(manifest['dir']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" entries << Entry.new(:name => n, :path => p, :kind => 'dir') end as_ary(manifest['file']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" lr = Revision.new(:revision => e['revision'], :scmid => e['node'], :identifier => e['node'], :time => Time.at(e['time'].to_i)) entries << Entry.new(:name => n, :path => p, :kind => 'file', :size => e['size'].to_i, :lastrev => lr) end entries rescue HgCommandAborted nil # means not found end"
397,"it ""with params as empty Hash"" do cl = subject.build_command_line(""true"", {}) expect(cl).to eq ""true"" end",True,Ruby,"""with params as empty Hash""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def cat(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) hg 'rhcat', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io| io.binmode io.read end rescue HgCommandAborted nil # means not found end"
398,"it ""sanitizes Pathname param key"" do cl = subject.build_command_line(""true"", Pathname.new(""/usr/bin/ruby"") => nil) expect(cl).to eq ""true /usr/bin/ruby"" end",True,Ruby,"""sanitizes Pathname param key""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def diff(path, identifier_from, identifier_to=nil) hg_args = %w|rhdiff| if identifier_to hg_args << ""-r#{hgrev(identifier_to)}"" << ""-r#{hgrev(identifier_from)}"" else hg_args << ""-c#{hgrev(identifier_from)}"" end unless path.blank? p = scm_iconv(@path_encoding, 'UTF-8', path) hg_args << '--' << CGI.escape(hgtarget(p)) end diff = [] hg *hg_args do |io| io.each_line do |line| diff << line end end diff rescue HgCommandAborted nil # means not found end"
399,"it ""with params as nil"" do cl = subject.build_command_line(""true"", nil) expect(cl).to eq ""true"" end",True,Ruby,"""with params as nil""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={}) hg_args = ['log', '--debug', '-C', ""--style=#{self.class.template_path}""] hg_args << ""-r#{hgrev(identifier_from)}:#{hgrev(identifier_to)}"" hg_args << ""--limit=#{options[:limit]}"" if options[:limit] hg_args << '--' << hgtarget(path) unless path.blank? log = hg(*hg_args) do |io| output = io.read.force_encoding('UTF-8') begin # Mercurial < 1.5 does not support footer template for '</log>' parse_xml(""#{output}</log>"")['log'] rescue end end as_ary(log['logentry']).each do |le| cpalist = as_ary(le['paths']['path-copied']).map do |e| [e['__content__'], e['copyfrom-path']].map do |s| scm_iconv('UTF-8', @path_encoding, CGI.unescape(s)) end end cpmap = Hash[*cpalist.flatten] paths = as_ary(le['paths']['path']).map do |e| p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) ) {:action => e['action'], :path => with_leading_slash(p), :from_path => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil), :from_revision => (cpmap.member?(p) ? le['node'] : nil)} end.sort { |a, b| a[:path] <=> b[:path] } parents_ary = [] as_ary(le['parents']['parent']).map do |par| parents_ary << par['__content__'] if par['__content__'] != ""0000000000000000000000000000000000000000"" end yield Revision.new(:revision => le['revision'], :scmid => le['node'], :author => (le['author']['__content__'] rescue ''), :time => Time.parse(le['date']['__content__']), :message => le['msg']['__content__'], :paths => paths, :parents => parents_ary) end self end"
400,"it ""handles Symbol keys with underscore and tailing '='"" do cl = subject.build_command_line(""true"", :abc_def= => ""ghi"") expect(cl).to eq ""true --abc-def=ghi"" end",True,Ruby,"""handles Symbol keys with underscore and tailing '='""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def hg(*args, &block) # as of hg 4.4.1, early parsing of bool options is not terminated at '--' if args.any? { |s| s =~ HG_EARLY_BOOL_ARG } raise HgCommandArgumentError, ""malicious command argument detected"" end if args.take_while { |s| s != '--' }.any? { |s| s =~ HG_EARLY_LIST_ARG } raise HgCommandArgumentError, ""malicious command argument detected"" end repo_path = root_url || url full_args = [""-R#{repo_path}"", '--encoding=utf-8'] # don't use ""--config=<value>"" form for compatibility with ancient Mercurial full_args << '--config' << ""extensions.redminehelper=#{HG_HELPER_EXT}"" full_args << '--config' << 'diff.git=false' full_args += args ret = shellout( self.class.sq_bin + ' ' + full_args.map { |e| shell_quote e.to_s }.join(' '), &block ) if $? && $?.exitstatus != 0 raise HgCommandAborted, ""hg exited with non-zero status: #{$?.exitstatus}"" end ret end"
401,"it ""handles Symbol keys"" do cl = subject.build_command_line(""true"", :abc => ""def"") expect(cl).to eq ""true --abc def"" end",True,Ruby,"""handles Symbol keys""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def annotate(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) blame = Annotate.new hg 'rhannotate', '-ncu', ""-r#{CGI.escape(hgrev(identifier))}"", '--', hgtarget(p) do |io| io.each_line do |line| line.force_encoding('ASCII-8BIT') next unless line =~ %r{^([^:]+)\s(\d+)\s([0-9a-f]+):\s(.*)$} r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3, :identifier => $3) blame.add_line($4.rstrip, r) end end blame rescue HgCommandAborted # means not found or cannot be annotated Annotate.new end"
402,"it ""handles Symbol keys with tailing '='"" do cl = subject.build_command_line(""true"", :abc= => ""def"") expect(cl).to eq ""true --abc=def"" end",True,Ruby,"""handles Symbol keys with tailing '='""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def nodes_in_branch(branch, options={}) hg_args = ['rhlog', '--template={node}\n', ""--rhbranch=#{CGI.escape(branch)}""] hg_args << ""--from=#{CGI.escape(branch)}"" hg_args << '--to=0' hg_args << ""--limit=#{options[:limit]}"" if options[:limit] hg(*hg_args) { |io| io.readlines.map { |e| e.chomp } } end"
403,"it ""with Pathname command and params"" do cl = subject.build_command_line(Pathname.new(""/usr/bin/ruby""), ""-v"" => nil) expect(cl).to eq ""/usr/bin/ruby -v"" end",True,Ruby,"""with Pathname command and params""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def entries(path=nil, identifier=nil, options={}) p1 = scm_iconv(@path_encoding, 'UTF-8', path) manifest = hg('rhmanifest', ""-r#{CGI.escape(hgrev(identifier))}"", '--', CGI.escape(without_leading_slash(p1.to_s))) do |io| output = io.read.force_encoding('UTF-8') begin parse_xml(output)['rhmanifest']['repository']['manifest'] rescue end end path_prefix = path.blank? ? '' : with_trailling_slash(path) entries = Entries.new as_ary(manifest['dir']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" entries << Entry.new(:name => n, :path => p, :kind => 'dir') end as_ary(manifest['file']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" lr = Revision.new(:revision => e['revision'], :scmid => e['node'], :identifier => e['node'], :time => Time.at(e['time'].to_i)) entries << Entry.new(:name => n, :path => p, :kind => 'file', :size => e['size'].to_i, :lastrev => lr) end entries rescue HgCommandAborted nil # means not found end"
404,"it ""sanitizes crazy params"" do cl = subject.build_command_line(""true"", modified_params) expect(cl).to eq ""true --user bob --pass P@\\$sw0\\^\\&\\ \\|\\<\\>/-\\+\\*d\\% --db --desc=Some\\ Description --symkey --symkey-dash pkg1 some\\ pkg --pool 123 --pool 456"" end",True,Ruby,"""sanitizes crazy params""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def cat(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) hg 'rhcat', ""-r#{CGI.escape(hgrev(identifier))}"", '--', hgtarget(p) do |io| io.binmode io.read end rescue HgCommandAborted nil # means not found end"
405,"it ""with Pathname command"" do cl = subject.build_command_line(Pathname.new(""/usr/bin/ruby"")) expect(cl).to eq ""/usr/bin/ruby"" end",True,Ruby,"""with Pathname command""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"def test_bad_early_options assert_nil @adapter.diff('sources/welcome_controller.rb', '--config=alias.rhdiff=!xterm') assert_raise HgCommandArgumentError do @adapter.entries('--debugger') end assert_raise HgCommandAborted do @adapter.revisions(nil, nil, nil, limit: '--repo=otherrepo') end assert_raise HgCommandAborted do @adapter.nodes_in_branch('default', limit: '--repository=otherrepo') end assert_raise HgCommandAborted do @adapter.nodes_in_branch('-Rotherrepo') end end"
406,"it ""without params"" do cl = subject.build_command_line(""true"") expect(cl).to eq ""true"" end",True,Ruby,"""without params""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,def by_state(items) case params[:state].to_s when 'closed' items.closed when 'merged' items.respond_to?(:merged) ? items.merged : items.closed when 'opened' items.opened else items end
407,"it ""sanitizes Pathname param value"" do cl = subject.build_command_line(""true"", nil => [Pathname.new(""/usr/bin/ruby"")]) expect(cl).to eq ""true /usr/bin/ruby"" end",True,Ruby,"""sanitizes Pathname param value""",awesome_spawn_spec.rb,https://github.com/ManageIQ/awesome_spawn,ManageIQ,Jason Frey,2014-07-03 14:14:51-04:00,Separate command line building and sanitizing into its own class.,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2014-0156,"it ""should delete guest's membership of group"" do expect { delete api(""/groups/#{group_with_members.id}/members/#{guest.id}"", owner) }.to change { group_with_members.members.count }.by(-1) response.status.should == 200 end"
423,def tmp_dir ENV['TMPDIR'] || ENV['TEMP'] || '/tmp' end,True,Ruby,tmp_dir,context.rb,https://github.com/github/hub,github,Mislav Marohnić,2014-04-15 19:04:30+02:00,"Use non-predictable filename for downloaded patch file

Since the /tmp directory is readable by everybody on Unix, and since
the patch name could be public or easy to guess, a attacker could create a symlink
to a file writable by the user running hub, which would be replaced by the patch.

This has been assigned CVE-2014-0177",CWE-310,Cryptographic Issues,"Weaknesses in this category are related to the design and implementation of data confidentiality and integrity. Frequently these deal with the use of encoding techniques, encryption libraries, and hashing algorithms. The weaknesses in this category could lead to a degradation of the quality data if they are not addressed.",https://cwe.mitre.org/data/definitions/310.html,CVE-2014-0177,"def by_frq_order_by_distance return nil if @location.nil? || @q.to_f == 0 sql = <<-SQL SELECT uo.name AS owner, CONCAT(us.name, ' ', us.location) AS display_name, us.net, us.radius, us.lat, us.lon, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance, fa.id AS frequency_assignment_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) INNER JOIN uke_stations us ON us.id = fa.subject_id INNER JOIN uke_operators uo ON uo.id = us.uke_operator_id WHERE f.mhz = :mhz AND fa.usage = 'TX' HAVING distance <= 100 ORDER BY distance ASC SQL result_to_hash(conn.select_all(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':lat', conn.quote(@location.latitude.to_s)).gsub(':lon', conn.quote(@location.longitude.to_s)).gsub(':mhz', conn.quote(Uke::Unifier::frq_string(@q).to_s)))) end"
425,"it 'corrects incorrect HTML' do post 'html_renderer', content: '<div>Hello', format: :html expect(response.body).to eq('<div>Hello</div>') end",True,Ruby,'corrects incorrect HTML',helpers_controller_spec.rb,https://github.com/bertrand-caron/rails-cv-app,bertrand-caron,Bertrand Caron,2014-11-16 22:59:19+01:00,"HOTFIX : Another vulnerability picked up by Brakeman

- Potential Path Traversal attack (tested working !)
I could potentially explore the whole filesystem with root access
(Ex: filename: '../../../etc/passwd')
- Added (empty) specs to detect it",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2014-125033,"def by_string return nil if @q.length < 4 sql = <<-SQL SELECT us.id FROM uke_stations us JOIN uke_operators uo on (uo.id = us.uke_operator_id) WHERE us.uke_import_id = :uke_import_id AND (us.location LIKE :like OR us.name LIKE :like OR uo.name LIKE :like) SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':like', conn.quote('%'+@q.to_s+'%'))) end"
428,"def execute(statement) Environment.logger.info(""Executing: "" + statement) super(statement) end",True,Ruby,execute,database.rb,https://github.com/elizabrock/license-to-kill,elizabrock,Eliza Brock,2014-05-01 09:22:12-05:00,Fix the SQL injection! STRING INTERPOLATION - NEVER AGAIN. NEVER!,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125037,"def by_frq return nil if @q.length < 4 || Uke::Unifier::frq_string(@q) < 1 sql = <<-SQL SELECT DISTINCT subject_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) WHERE f.mhz = :mhz SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz', conn.quote(Uke::Unifier::frq_string(@q).to_s))) end"
429,"def self.execute_and_instantiate(statement) rows = Environment.database_connection.execute(statement) results = [] rows.each do |row| results << Injury.new(row[""name""]) end results end",True,Ruby,self.execute_and_instantiate,injury.rb,https://github.com/elizabrock/license-to-kill,elizabrock,Eliza Brock,2014-05-01 09:22:12-05:00,Fix the SQL injection! STRING INTERPOLATION - NEVER AGAIN. NEVER!,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125037,"def by_location return nil if @q.strip[0..3] != 'loc:' || (@location = Geocoder.search(@q.gsub('loc:', '').strip).first).nil? bounds_ne = @location.geometry['bounds']['northeast'] bounds_sw = @location.geometry['bounds']['southwest'] @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0) sql = <<-SQL SELECT DISTINCT us.id, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance FROM uke_stations AS us WHERE us.uke_import_id = :uke_import_id AND lat BETWEEN :lat_sw AND :lat_ne AND lon BETWEEN :lon_sw AND :lon_ne ORDER BY distance ASC SQL sql.gsub!(':uke_import_id', @active_import.id.to_s) sql.gsub!(':lat_ne', conn.quote(bounds_ne['lat'].to_s)) sql.gsub!(':lat_sw', conn.quote(bounds_sw['lat'].to_s)) sql.gsub!(':lon_ne', conn.quote(bounds_ne['lng'].to_s)) sql.gsub!(':lon_sw', conn.quote(bounds_sw['lng'].to_s)) sql.gsub!(':lat', conn.quote(@location.latitude.to_s)) sql.gsub!(':lon', conn.quote(@location.longitude.to_s)) result_to_hash select_using_uke_stations_result(sql) end"
431,"def self.find_by_name(name) statement = ""Select * from injuries where name = \""#{name}\"";"" execute_and_instantiate(statement)[0] end",True,Ruby,self.find_by_name,injury.rb,https://github.com/elizabrock/license-to-kill,elizabrock,Eliza Brock,2014-05-01 09:22:12-05:00,Fix the SQL injection! STRING INTERPOLATION - NEVER AGAIN. NEVER!,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125037,"def by_news return nil if @q.strip[0..4] != 'news:' || (@location = Geocoder.search(@q.gsub('news:', '').strip).first).nil? bounds_ne = @location.geometry['bounds']['northeast'] bounds_sw = @location.geometry['bounds']['southwest'] @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0) sql = <<-SQL SELECT DISTINCT us.id, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance FROM uke_import_news n INNER JOIN uke_stations AS us ON (us.id = n.uke_station_id) WHERE n.uke_import_id = :uke_import_id AND lat BETWEEN :lat_sw AND :lat_ne AND lon BETWEEN :lon_sw AND :lon_ne ORDER BY distance ASC SQL sql.gsub!(':uke_import_id', @active_import.id.to_s) sql.gsub!(':lat_ne', conn.quote(bounds_ne['lat'].to_s)) sql.gsub!(':lat_sw', conn.quote(bounds_sw['lat'].to_s)) sql.gsub!(':lon_ne', conn.quote(bounds_ne['lng'].to_s)) sql.gsub!(':lon_sw', conn.quote(bounds_sw['lng'].to_s)) sql.gsub!(':lat', conn.quote(@location.latitude.to_s)) sql.gsub!(':lon', conn.quote(@location.longitude.to_s)) result_to_hash select_using_uke_stations_result(sql) end"
434,"def save if Injury.find_by_name(self.name) @errors << ""#{self.name} already exists."" false else statement = ""Insert into injuries (name) values ('#{name}');"" Environment.database_connection.execute(statement) true end end",True,Ruby,save,injury.rb,https://github.com/elizabrock/license-to-kill,elizabrock,Eliza Brock,2014-05-01 09:22:12-05:00,Fix the SQL injection! STRING INTERPOLATION - NEVER AGAIN. NEVER!,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125037,"def by_frq_range return nil if @q.strip[0..3] != 'rng:' || (first = Uke::Unifier::frq_string(@q[4..@q.length].split('-').first)) < 1 || (last = Uke::Unifier::frq_string(@q[4..@q.length].split('-').last)) < 1 sql = <<-SQL SELECT DISTINCT fa.subject_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) WHERE (f.mhz BETWEEN :mhz_start AND :mhz_end) SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz_start', conn.quote(first.to_s)).gsub(':mhz_end', conn.quote(last.to_s))) end"
438,def current_user_existing_vote @vote = current_user.votes.find_by(comment_id: params[:id]) end,True,Ruby,current_user_existing_vote,comments_controller.rb,https://github.com/koroket/RedditOnRails,koroket,Jordan Arnesen,2014-12-19 17:11:20-08:00,"Solved duplicate votes issue; Discovered karma exploitation
Exploit - Currently even if you already upvoted you can click the upvote button again, which doesn't add a new vote to the post/comment but *does* add more to the user's karma since there's no check for existing vote value to only add karma for actual changes to votes",CWE-284,Improper Access Control,The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.,https://cwe.mitre.org/data/definitions/284.html,CVE-2014-125054,"def update @grade = Grade.find(params[:id]) if @grade.update(grade_params) render json: @grades else render json: @grade.errors.full_messages, status: 422 end end"
441,def current_user_existing_vote @vote = current_user.votes.find_by(post_id: params[:id]) end,True,Ruby,current_user_existing_vote,posts_controller.rb,https://github.com/koroket/RedditOnRails,koroket,Jordan Arnesen,2014-12-19 17:11:20-08:00,"Solved duplicate votes issue; Discovered karma exploitation
Exploit - Currently even if you already upvoted you can click the upvote button again, which doesn't add a new vote to the post/comment but *does* add more to the user's karma since there's no check for existing vote value to only add karma for actual changes to votes",CWE-284,Improper Access Control,The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.,https://cwe.mitre.org/data/definitions/284.html,CVE-2014-125054,"def grade_params params.permit(:grade, :assignment_id, :user_id) #need to change grade column - it confuses params_wrapper end"
444,"def select_transfer_files(transfer_id) sql = "" SELECT fb_file_status.transfer_id, fb_file_status.filename, fb_file_status.status_time, fb_file_status_dict.status_id, fb_file_status_dict.status_desc, fb_file_status_dict.status_type FROM public.fb_file_status, public.fb_file_status_dict WHERE fb_file_status.status_id = fb_file_status_dict.status_id AND fb_file_status.transfer_id = #{transfer_id} ORDER BY fb_file_status.filename ASC"" @db.exec(sql) end",True,Ruby,select_transfer_files,common.rb,https://github.com/peel/filebroker,peel,Wojciech Kicior,2014-02-18 12:23:15+01:00,filter out transferred + sql injection fixes,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125061,"def create @user = User.find_by(email: params[:user][:email]) if @user.present? @user.deliver_reset_password_instructions! redirect_to new_session_path, notice: ""Verifique seu email para receber instruções de recuperação de senha"" else @user = User.new email: params[:user][:email] flash[:alert] = ""Email não encontrado"" render :new end end"
447,"def update_file_status(transfer_id, file, status_id, status_time) if @db.exec(""SELECT * FROM fb_file_status WHERE transfer_id=#{transfer_id} AND filename='#{file}'"").count > 0 @db.exec(""UPDATE fb_file_status SET status_id=#{status_id}, status_time='#{status_time}' WHERE transfer_id=#{transfer_id} AND filename='#{file}'"") else insert_file_status(transfer_id, file, status_id, status_time) end end",True,Ruby,update_file_status,common.rb,https://github.com/peel/filebroker,peel,Wojciech Kicior,2014-02-18 12:23:15+01:00,filter out transferred + sql injection fixes,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125061,"it ""escapes html entities in the table"" do visit ""/admin/#/api_users"" page.should have_content(@user.email) page.should have_content(@user.first_name) page.should have_content(@user.last_name) page.should have_content(@user.use_description) page.should have_content(@user.registration_source) page.should_not have_selector("".xss-test"", :visible => :all) end"
448,"def insert_file_status(transfer_id, file, status_id, status_time) @db.exec(""INSERT into fb_file_status (transfer_id, filename, status_id, status_time) VALUES (#{transfer_id}, '#{file}', #{status_id}, '#{status_time}')"") end",True,Ruby,insert_file_status,common.rb,https://github.com/peel/filebroker,peel,Wojciech Kicior,2014-02-18 12:23:15+01:00,filter out transferred + sql injection fixes,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125061,"it ""escapes html entities in the form"" do visit ""/admin/#/api_users/#{@user.id}/edit"" find_field(""E-mail"").value.should eql(@user.email) find_field(""First Name"").value.should eql(@user.first_name) find_field(""Last Name"").value.should eql(@user.last_name) find_field(""Purpose"").value.should eql(@user.use_description) page.should have_content(@user.registration_source) page.should_not have_selector("".xss-test"", :visible => :all) end"
451,"def do_list(soap_body) begin prefix = soap_body.root.namespace.prefix req = {} req['protocol'] = soap_body.xpath(""//#{prefix}:Protocol/text()"").to_s.downcase req['address'] = soap_body.xpath(""//#{prefix}:Address/text()"").to_s req['port'] = soap_body.xpath(""//#{prefix}:Port/text()"").to_s req['login'] = soap_body.xpath(""//#{prefix}:Login/text()"").to_s req['password'] = soap_body.xpath(""//#{prefix}:Password/text()"").to_s req['path'] = soap_body.xpath(""//#{prefix}:Path/text()"").to_s begin source = @db.select_account(req) rescue Database::AccountNotExist source = @db.insert_account(req) end list = [] if req['protocol'] == 'cifs' conn = Connector::CIFS.new conn.address = req['address'] conn.login = req['login'] conn.password = req['password'] conn.share = req['path'].split('/')[1] conn.connect conn.cd(req['path']) list = conn.list(req['path']) conn.disconnect elsif req['protocol'] == 'ftp' conn = Connector::FTP.new conn.address = req['address'] conn.port = req['port'] conn.login = req['login'] conn.password = req['password'] conn.connect list = conn.list(req['path']) conn.disconnect elsif req['protocol'] == 'sftp' conn = Connector::SFTP.new conn.address = req['address'] conn.port = req['port'] conn.login = req['login'] conn.password = req['password'] conn.connect list = conn.list(req['path']) conn.disconnect end # Convert time format list.map { |j| j['mtime'] = DateTime.parse(j['mtime']) } # Remove currently transferred files @db.select_running_transfers_by_source(FBService::TRANSFER_RUNNING, source['account_id'], source['path']).each { |i| @db.select_transfer_files(i['transfer_id']).each { |j| list.delete_if { |k| k['name'] == j['filename'] } } } # Remove temporary files list.delete_if { |j| j['name'] =~ /\.partial$/ } builder(:list_response, :locals => { :list => list }) rescue err_msg = ""#{$!.backtrace.join(""\n"")}\n#{$!.message}\n"" @stderr_mutex.try_lock 80.times { STDERR.print '-' } STDERR.puts STDERR.puts ""Exception time: #{DateTime.parse(Time.now.to_s)}"" STDERR.puts err_msg 80.times { STDERR.print '-' } STDERR.puts @stderr_mutex.unlock builder(:fault, :locals => { :fault_string => 'failed to list directory', :fault_code => 'Server' }) end end",True,Ruby,do_list,filebroker.rb,https://github.com/peel/filebroker,peel,Wojciech Kicior,2014-02-18 12:23:15+01:00,filter out transferred + sql injection fixes,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125061,"it ""escapes html entities in the table"" do log = FactoryGirl.create(:xss_log_item, :request_at => Time.parse(""2015-01-16T06:06:28.816Z""), :request_method => ""OPTIONS"") LogItem.gateway.refresh_index! visit ""/admin/#/stats/logs/tz=America%2FDenver&search=&start_at=2015-01-12&end_at=2015-01-18&interval=day"" page.should have_content(log.request_method) page.should have_content(log.request_accept_encoding) page.should have_content(log.request_ip_city) page.should have_content(log.request_ip_country) page.should have_content(log.request_ip_region) page.should have_content(log.request_user_agent) page.should have_content(log.response_content_type) page.should have_content(log.user_email) page.should_not have_selector("".xss-test"", :visible => :all) end"
452,def show @images = Image.where(sol: params[:sol]) end,True,Ruby,show,image_controller.rb,https://github.com/corincerami/curiosity,corincerami,Chris C Cerami,2014-12-07 13:00:33-05:00,Sanitized form input to protect against SQL injection.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125067,"def basic_auth authenticate_or_request_with_http_basic do |username, password| expected_username = ENV.fetch(""DYNOSAUR_USERNAME"", DEFAULT_USERNAME) expected_password = ENV.fetch(""DYNOSAUR_PASSWORD"", DEFAULT_PASSWORD) if username != expected_username puts ""Failed username"" return request_http_basic_authentication end if expected_password == password return true else begin bcyrpt_password = BCrypt::Password.new(expected_password) if bcyrpt_password == password return true else puts ""Failed password"" end rescue BCrypt::Errors::InvalidHash puts ""DYNOSAUR_PASSWORD is not a valid bcrypt hash, so that's not gonna work"" end end puts ""ERROR: Failed basic auth"" return request_http_basic_authentication end end"
453,def index # find the martial solar date of the most recent image taken # @most_recent = Image.all.sort_by { |hash| -hash[:sol].to_i }.first[:sol] @image_count = Image.count @most_recent = Image.maximum(:sol) end,True,Ruby,index,image_controller.rb,https://github.com/corincerami/curiosity,corincerami,Chris C Cerami,2014-12-07 13:00:33-05:00,Sanitized form input to protect against SQL injection.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2014-125067,"def get_tweets(account, amount = 3) tweets = [] begin @twitter.user_timeline(account, count: amount).each do |tweet| name = tweet.user.screen_name twtext = tweet.text.gsub(""\r?\n"", '. ') tweets << { account: name, tweet: twtext, time: tweet.created_at, uri: tweet.uri.to_s, id: tweet.id } end rescue StandardError => e warn ""Unable to retrieve Tweet information for #{account}: #{e}"" tweets = nil end tweets end"
457,"def redirect_back_or_default(default, options={}) back_url = params[:back_url].to_s if back_url.present? begin uri = URI.parse(back_url) # do not redirect user to another host or to the login or register page if (uri.relative? || (uri.host == request.host)) && !uri.path.match(%r{/(login|account/register)}) redirect_to(back_url) return end rescue URI::InvalidURIError logger.warn(""Could not redirect to invalid URL #{back_url}"") # redirect to default end elsif options[:referer] redirect_to_referer_or default return end redirect_to default false end",True,Ruby,redirect_back_or_default,application_controller.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2014-03-29 14:32:47+00:00,"Fixed back url verification (#16466).

git-svn-id: http://svn.redmine.org/redmine/trunk@13018 e93f8b46-1217-0410-a6f0-8f06a7374b81",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2014-1985,"def validate_signature(base64_cert, soft = true) # validate references # check for inclusive namespaces inclusive_namespaces = extract_inclusive_namespaces document = Nokogiri.parse(self.to_s) # create a working copy so we don't modify the original @working_copy ||= REXML::Document.new(self.to_s).root # store and remove signature node @sig_element ||= begin element = REXML::XPath.first( @working_copy, ""//ds:Signature"", {""ds""=>DSIG} ) element.remove end # verify signature signed_info_element = REXML::XPath.first( @sig_element, ""//ds:SignedInfo"", {""ds""=>DSIG} ) noko_sig_element = document.at_xpath('//ds:Signature', 'ds' => DSIG) noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' => DSIG) canon_algorithm = canon_algorithm REXML::XPath.first( @sig_element, '//ds:CanonicalizationMethod', 'ds' => DSIG ) canon_string = noko_signed_info_element.canonicalize(canon_algorithm) noko_sig_element.remove # check digests REXML::XPath.each(@sig_element, ""//ds:Reference"", {""ds""=>DSIG}) do |ref| uri = ref.attributes.get_attribute(""URI"").value hashed_element = document.at_xpath(""//*[@ID=$uri]"", nil, { 'uri' => uri[1..-1] }) canon_algorithm = canon_algorithm REXML::XPath.first( ref, '//ds:CanonicalizationMethod', { ""ds"" => DSIG } ) canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces) digest_algorithm = algorithm(REXML::XPath.first( ref, ""//ds:DigestMethod"", { ""ds"" => DSIG } )) hash = digest_algorithm.digest(canon_hashed_element) encoded_digest_value = REXML::XPath.first( ref, ""//ds:DigestValue"", { ""ds"" => DSIG } ).text digest_value = Base64.decode64(encoded_digest_value) unless digests_match?(hash, digest_value) @errors << ""Digest mismatch"" return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(""Digest mismatch"")) end end base64_signature = REXML::XPath.first( @sig_element, ""//ds:SignatureValue"", {""ds"" => DSIG} ).text signature = Base64.decode64(base64_signature) # get certificate object cert_text = Base64.decode64(base64_cert) cert = OpenSSL::X509::Certificate.new(cert_text) # signature method sig_alg_value = REXML::XPath.first( signed_info_element, ""//ds:SignatureMethod"", {""ds""=>DSIG} ) signature_algorithm = algorithm(sig_alg_value) unless cert.public_key.verify(signature_algorithm.new, signature, canon_string) @errors << ""Key validation error"" return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(""Key validation error"")) end return true end"
459,"def test_login_should_not_redirect_to_another_host post :login, :username => 'jsmith', :password => 'jsmith', :back_url => 'http://test.foo/fake' assert_redirected_to '/my/page' end",True,Ruby,test_login_should_not_redirect_to_another_host,account_controller_test.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2014-03-29 14:32:47+00:00,"Fixed back url verification (#16466).

git-svn-id: http://svn.redmine.org/redmine/trunk@13018 e93f8b46-1217-0410-a6f0-8f06a7374b81",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2014-1985,"def crop_command target = @attachment.instance if target.cropping?(@attachment.name) begin w = Integer(target.send :""#{@attachment.name}_crop_w"") h = Integer(target.send :""#{@attachment.name}_crop_h"") x = Integer(target.send :""#{@attachment.name}_crop_x"") y = Integer(target.send :""#{@attachment.name}_crop_y"") [""-crop"", ""#{w}x#{h}+#{x}+#{y}""] rescue Paperclip.log(""[papercrop] #{@attachment.name} crop w/h/x/y were non-integer"") return end end end"
462,"def redirect_back_or_default(default, options={}) back_url = params[:back_url].to_s if back_url.present? && valid_back_url?(back_url) redirect_to(back_url) return elsif options[:referer] redirect_to_referer_or default return end redirect_to default false end",True,Ruby,redirect_back_or_default,application_controller.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2015-09-13 14:35:20+00:00,"Open redirect vulnerability (#19577).

Patch by Holger Just.

git-svn-id: http://svn.redmine.org/redmine/trunk@14560 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2015-8474,"def calculated_media_type @calculated_media_type ||= calculated_content_type.split(""/"").first end"
464,def valid_back_url?(back_url) if CGI.unescape(back_url).include?('..') return false end begin uri = URI.parse(back_url) rescue URI::InvalidURIError return false end if uri.host.present? && uri.host != request.host return false end if uri.path.match(%r{/(login|account/register)}) return false end if relative_url_root.present? && !uri.path.starts_with?(relative_url_root) return false end return true end,True,Ruby,valid_back_url?,application_controller.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2015-09-13 14:35:20+00:00,"Open redirect vulnerability (#19577).

Patch by Holger Just.

git-svn-id: http://svn.redmine.org/redmine/trunk@14560 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2015-8474,def media_type_mismatch? supplied_type_mismatch? || calculated_type_mismatch? end
465,"def test_login_with_suburi_should_not_redirect_to_another_suburi @relative_url_root = Redmine::Utils.relative_url_root Redmine::Utils.relative_url_root = '/redmine' back_urls = [ 'http://test.host/', 'http://test.host/fake', 'http://test.host/fake/issues', 'http://test.host/redmine/../fake', 'http://test.host/redmine/../fake/issues', 'http://test.host/redmine/%2e%2e/fake' ] back_urls.each do |back_url| post :login, :username => 'jsmith', :password => 'jsmith', :back_url => back_url assert_redirected_to '/my/page' end ensure Redmine::Utils.relative_url_root = @relative_url_root end",True,Ruby,test_login_with_suburi_should_not_redirect_to_another_suburi,account_controller_test.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2015-09-13 14:35:20+00:00,"Open redirect vulnerability (#19577).

Patch by Holger Just.

git-svn-id: http://svn.redmine.org/redmine/trunk@14560 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2015-8474,"def self.using(file, name, content_type) new(file, name, content_type) end"
469,"def self.reminders(options={}) days = options[:days] || 7 project = options[:project] ? Project.find(options[:project]) : nil tracker = options[:tracker] ? Tracker.find(options[:tracker]) : nil target_version_id = options[:version] ? Version.named(options[:version]).pluck(:id) : nil if options[:version] && target_version_id.blank? raise ActiveRecord::RecordNotFound.new(""Couldn't find Version with named #{options[:version]}"") end user_ids = options[:users] scope = Issue.open.where(""#{Issue.table_name}.assigned_to_id IS NOT NULL"" + "" AND #{Project.table_name}.status = #{Project::STATUS_ACTIVE}"" + "" AND #{Issue.table_name}.due_date <= ?"", days.day.from_now.to_date ) scope = scope.where(:assigned_to_id => user_ids) if user_ids.present? scope = scope.where(:project_id => project.id) if project scope = scope.where(:fixed_version_id => target_version_id) if target_version_id.present? scope = scope.where(:tracker_id => tracker.id) if tracker issues_by_assignee = scope.includes(:status, :assigned_to, :project, :tracker). group_by(&:assigned_to) issues_by_assignee.keys.each do |assignee| if assignee.is_a?(Group) assignee.users.each do |user| issues_by_assignee[user] ||= [] issues_by_assignee[user] += issues_by_assignee[assignee] end end end issues_by_assignee.each do |assignee, issues| reminder(assignee, issues, days).deliver if assignee.is_a?(User) && assignee.active? end end",True,Ruby,self.reminders,mailer.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2017-05-13 09:38:05+00:00,"Send reminders about visible issues only (#25713).

Patch by Felix Schäfer.

git-svn-id: http://svn.redmine.org/redmine/trunk@16557 e93f8b46-1217-0410-a6f0-8f06a7374b81",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2017-16804,"def initialize(file, name, content_type) @file = file @name = name @content_type = content_type || """" end"
474,"def column_content(column, item) value = column.value_object(item) if value.is_a?(Array) value.collect {|v| column_value(column, item, v)}.compact.join(', ').html_safe else column_value(column, item, value) end end",True,Ruby,column_content,queries_helper.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2017-10-15 11:08:46+00:00,"Ensure that values of multi-value fields are HTML-escaped in issue list (#27186).

Patch by Holger Just.

git-svn-id: http://svn.redmine.org/redmine/trunk@16984 e93f8b46-1217-0410-a6f0-8f06a7374b81",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-15569,"def filename_extension File.extname(@name.to_s.downcase).sub(/^\./, '').to_sym end"
476,"def format_object(object, html=true, &block) if block_given? object = yield object end case object.class.name when 'Array' object.map {|o| format_object(o, html)}.join(', ').html_safe when 'Time' format_time(object) when 'Date' format_date(object) when 'Fixnum' object.to_s when 'Float' sprintf ""%.2f"", object when 'User' html ? link_to_user(object) : object.to_s when 'Project' html ? link_to_project(object) : object.to_s when 'Version' html ? link_to_version(object) : object.to_s when 'TrueClass' l(:general_text_Yes) when 'FalseClass' l(:general_text_No) when 'Issue' object.visible? && html ? link_to_issue(object) : ""##{object.id}"" when 'Attachment' html ? link_to_attachment(object) : object.filename when 'CustomValue', 'CustomFieldValue' if object.custom_field f = object.custom_field.format.formatted_custom_value(self, object, html) if f.nil? || f.is_a?(String) f else format_object(f, html, &block) end else object.value.to_s end else html ? h(object) : object.to_s end",True,Ruby,format_object,application_helper.rb,https://github.com/redmine/redmine,redmine,Jean-Philippe Lang,2017-10-15 11:09:43+00:00,"Ensure that values of multi-value fields are HTML-escaped in issue history (#27186).

Patch by Holger Just.

git-svn-id: http://svn.redmine.org/redmine/trunk@16985 e93f8b46-1217-0410-a6f0-8f06a7374b81",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-15568,def mapped_content_type Paperclip.options[:content_type_mappings][filename_extension] end
479,"def diff(path, identifier_from, identifier_to=nil) hg_args = %w|rhdiff| if identifier_to hg_args << '-r' << hgrev(identifier_to) << '-r' << hgrev(identifier_from) else hg_args << '-c' << hgrev(identifier_from) end unless path.blank? p = scm_iconv(@path_encoding, 'UTF-8', path) hg_args << CGI.escape(hgtarget(p)) end diff = [] hg *hg_args do |io| io.each_line do |line| diff << line end end diff rescue HgCommandAborted nil # means not found end",True,Ruby,diff,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:35+00:00,"mercurial: separate command options and positional arguments with ""--"" (#27516)

We don't have much problems here thanks to hgtarget(path) and CGI.escape(),
which prepends a repository path and encodes ""="" character respectively, but
it's better to not rely on the side effect of these functions.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17061 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,def calculated_content_type @calculated_content_type ||= type_from_file_command.chomp end
480,"def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={}) hg_args = ['log', '--debug', '-C', '--style', self.class.template_path] hg_args << '-r' << ""#{hgrev(identifier_from)}:#{hgrev(identifier_to)}"" hg_args << '--limit' << options[:limit] if options[:limit] hg_args << hgtarget(path) unless path.blank? log = hg(*hg_args) do |io| output = io.read.force_encoding('UTF-8') begin # Mercurial < 1.5 does not support footer template for '</log>' parse_xml(""#{output}</log>"")['log'] rescue end end as_ary(log['logentry']).each do |le| cpalist = as_ary(le['paths']['path-copied']).map do |e| [e['__content__'], e['copyfrom-path']].map do |s| scm_iconv('UTF-8', @path_encoding, CGI.unescape(s)) end end cpmap = Hash[*cpalist.flatten] paths = as_ary(le['paths']['path']).map do |e| p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) ) {:action => e['action'], :path => with_leading_slash(p), :from_path => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil), :from_revision => (cpmap.member?(p) ? le['node'] : nil)} end.sort { |a, b| a[:path] <=> b[:path] } parents_ary = [] as_ary(le['parents']['parent']).map do |par| parents_ary << par['__content__'] if par['__content__'] != ""0000000000000000000000000000000000000000"" end yield Revision.new(:revision => le['revision'], :scmid => le['node'], :author => (le['author']['__content__'] rescue ''), :time => Time.parse(le['date']['__content__']), :message => le['msg']['__content__'], :paths => paths, :parents => parents_ary) end self end",True,Ruby,each_revision,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:35+00:00,"mercurial: separate command options and positional arguments with ""--"" (#27516)

We don't have much problems here thanks to hgtarget(path) and CGI.escape(),
which prepends a repository path and encodes ""="" character respectively, but
it's better to not rely on the side effect of these functions.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17061 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def spoofed? if has_name? && has_extension? && media_type_mismatch? && mapping_override_mismatch? Paperclip.log(""Content Type Spoof: Filename #{File.basename(@name)} (#{supplied_content_type} from Headers, #{content_types_from_name} from Extension), content type discovered from file command: #{calculated_content_type}. See documentation to allow this combination."") true else false end end"
483,"def annotate(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) blame = Annotate.new hg 'rhannotate', '-ncu', '-r', CGI.escape(hgrev(identifier)), hgtarget(p) do |io| io.each_line do |line| line.force_encoding('ASCII-8BIT') next unless line =~ %r{^([^:]+)\s(\d+)\s([0-9a-f]+):\s(.*)$} r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3, :identifier => $3) blame.add_line($4.rstrip, r) end end blame rescue HgCommandAborted # means not found or cannot be annotated Annotate.new end",True,Ruby,annotate,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:35+00:00,"mercurial: separate command options and positional arguments with ""--"" (#27516)

We don't have much problems here thanks to hgtarget(path) and CGI.escape(),
which prepends a repository path and encodes ""="" character respectively, but
it's better to not rely on the side effect of these functions.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17061 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def validate_each(record, attribute, value) adapter = Paperclip.io_adapters.for(value) if Paperclip::MediaTypeSpoofDetector.using(adapter, value.original_filename, value.content_type).spoofed? record.errors.add(attribute, :spoofed_media_type) end end"
484,"def entries(path=nil, identifier=nil, options={}) p1 = scm_iconv(@path_encoding, 'UTF-8', path) manifest = hg('rhmanifest', '-r', CGI.escape(hgrev(identifier)), CGI.escape(without_leading_slash(p1.to_s))) do |io| output = io.read.force_encoding('UTF-8') begin parse_xml(output)['rhmanifest']['repository']['manifest'] rescue end end path_prefix = path.blank? ? '' : with_trailling_slash(path) entries = Entries.new as_ary(manifest['dir']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" entries << Entry.new(:name => n, :path => p, :kind => 'dir') end as_ary(manifest['file']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" lr = Revision.new(:revision => e['revision'], :scmid => e['node'], :identifier => e['node'], :time => Time.at(e['time'].to_i)) entries << Entry.new(:name => n, :path => p, :kind => 'file', :size => e['size'].to_i, :lastrev => lr) end entries rescue HgCommandAborted nil # means not found end",True,Ruby,entries,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:35+00:00,"mercurial: separate command options and positional arguments with ""--"" (#27516)

We don't have much problems here thanks to hgtarget(path) and CGI.escape(),
which prepends a repository path and encodes ""="" character respectively, but
it's better to not rely on the side effect of these functions.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17061 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"it ""returns default error message for spoofed media type"" do build_validator file = File.new(fixture_file(""5k.png""), ""rb"") @dummy.avatar.assign(file) detector = mock(""detector"", :spoofed? => true) Paperclip::MediaTypeSpoofDetector.stubs(:using).returns(detector) @validator.validate(@dummy) assert_equal I18n.t(""errors.messages.spoofed_media_type""), @dummy.errors[:avatar].first end"
486,"def cat(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) hg 'rhcat', '-r', CGI.escape(hgrev(identifier)), hgtarget(p) do |io| io.binmode io.read end rescue HgCommandAborted nil # means not found end",True,Ruby,cat,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:35+00:00,"mercurial: separate command options and positional arguments with ""--"" (#27516)

We don't have much problems here thanks to hgtarget(path) and CGI.escape(),
which prepends a repository path and encodes ""="" character respectively, but
it's better to not rely on the side effect of these functions.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17061 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def list Log.add_info(request, params.inspect) con = [] @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end unless @group_id.nil? if @group_id == '0' con << ""((groups like '%|0|%') or (groups is null))"" else con << SqlHelper.get_sql_like([:groups], ""|#{@group_id}|"") end end where = '' unless con.empty? where = ' where ' + con.join(' and ') end order_by = nil @sort_col = params[:sort_col] @sort_type = params[:sort_type] if @sort_col.blank? or @sort_type.blank? @sort_col = 'id' @sort_type = 'ASC' end SqlHelper.validate_token([@sort_col, @sort_type]) order_by = ' order by ' + @sort_col + ' ' + @sort_type sql = 'select distinct Equipment.* from equipment Equipment' sql << where + order_by @equipment_pages, @equipment, @total_num = paginate_by_sql(Equipment, sql, 20) end"
489,"def diff(path, identifier_from, identifier_to=nil) hg_args = %w|rhdiff| if identifier_to hg_args << '-r' << hgrev(identifier_to) << '-r' << hgrev(identifier_from) else hg_args << '-c' << hgrev(identifier_from) end unless path.blank? p = scm_iconv(@path_encoding, 'UTF-8', path) hg_args << '--' << CGI.escape(hgtarget(p)) end diff = [] hg *hg_args do |io| io.each_line do |line| diff << line end end diff rescue HgCommandAborted nil # means not found end",True,Ruby,diff,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def schedule_all Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end if @login_user.nil? or params[:display].nil? or params[:display] == 'all' params[:display] = 'all' con = EquipmentHelper.get_scope_condition_for(@login_user) else display_type = params[:display].split('_').first display_id = params[:display].split('_').last case display_type when 'group' if @login_user.get_groups_a(true).include?(display_id) con = SqlHelper.get_sql_like([:groups], ""|#{display_id}|"") end when 'team' if @login_user.get_teams_a.include?(display_id) con = SqlHelper.get_sql_like([:teams], ""|#{display_id}|"") end end end"
490,"def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={}) hg_args = ['log', '--debug', '-C', '--style', self.class.template_path] hg_args << '-r' << ""#{hgrev(identifier_from)}:#{hgrev(identifier_to)}"" hg_args << '--limit' << options[:limit] if options[:limit] hg_args << '--' << hgtarget(path) unless path.blank? log = hg(*hg_args) do |io| output = io.read.force_encoding('UTF-8') begin # Mercurial < 1.5 does not support footer template for '</log>' parse_xml(""#{output}</log>"")['log'] rescue end end as_ary(log['logentry']).each do |le| cpalist = as_ary(le['paths']['path-copied']).map do |e| [e['__content__'], e['copyfrom-path']].map do |s| scm_iconv('UTF-8', @path_encoding, CGI.unescape(s)) end end cpmap = Hash[*cpalist.flatten] paths = as_ary(le['paths']['path']).map do |e| p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) ) {:action => e['action'], :path => with_leading_slash(p), :from_path => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil), :from_revision => (cpmap.member?(p) ? le['node'] : nil)} end.sort { |a, b| a[:path] <=> b[:path] } parents_ary = [] as_ary(le['parents']['parent']).map do |par| parents_ary << par['__content__'] if par['__content__'] != ""0000000000000000000000000000000000000000"" end yield Revision.new(:revision => le['revision'], :scmid => le['node'], :author => (le['author']['__content__'] rescue ''), :time => Time.parse(le['date']['__content__']), :message => le['msg']['__content__'], :paths => paths, :parents => parents_ary) end self end",True,Ruby,each_revision,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def get_users if params[:action] == 'get_users' Log.add_info(request, params.inspect) end @group_id = params[:id] # FEATURE_PAGING_IN_TREE >>> con = ['User.id > 0'] unless @group_id.nil? if @group_id == '0' con << ""((groups like '%|0|%') or (groups is null))"" else con << SqlHelper.get_sql_like([:groups], ""|#{@group_id}|"") end end unless params[:keyword].blank? key_array = params[:keyword].split(nil) key_array.each do |key| con << SqlHelper.get_sql_like([:name, :email, :fullname, :address, :organization, :tel1, :tel2, :tel3, :fax, :url, :postalcode, :title], key) end end where = '' unless con.empty? where = ' where ' + con.join(' and ') end order_by = nil @sort_col = params[:sort_col] @sort_type = params[:sort_type] if @sort_col.blank? or @sort_type.blank? @sort_col = 'OfficialTitle.xorder' @sort_type = 'ASC' end SqlHelper.validate_token([@sort_col, @sort_type]) order_by = @sort_col + ' ' + @sort_type if @sort_col == 'OfficialTitle.xorder' order_by = '(OfficialTitle.xorder is null) ' + @sort_type + ', ' + order_by else order_by << ', (OfficialTitle.xorder is null) ASC, OfficialTitle.xorder ASC' end if @sort_col != 'name' order_by << ', name ASC' end sql = 'select distinct User.* from (users User left join user_titles UserTitle on User.id=UserTitle.user_id)' sql << ' left join official_titles OfficialTitle on UserTitle.official_title_id=OfficialTitle.id' sql << where + ' order by ' + order_by @user_pages, @users, @total_num = paginate_by_sql(User, sql, 50) # FEATURE_PAGING_IN_TREE <<< session[:group_id] = @group_id session[:group_option] = 'user' render(:partial => 'ajax_group_users', :layout => false) end"
492,"def hg(*args, &block) # as of hg 4.4.1, early parsing of bool options is not terminated at '--' if args.any? { |s| s =~ HG_EARLY_BOOL_ARG } raise HgCommandArgumentError, ""malicious command argument detected"" end if args.take_while { |s| s != '--' }.any? { |s| s =~ HG_EARLY_LIST_ARG } raise HgCommandArgumentError, ""malicious command argument detected"" end repo_path = root_url || url full_args = ['-R', repo_path, '--encoding', 'utf-8'] full_args << '--config' << ""extensions.redminehelper=#{HG_HELPER_EXT}"" full_args << '--config' << 'diff.git=false' full_args += args ret = shellout( self.class.sq_bin + ' ' + full_args.map { |e| shell_quote e.to_s }.join(' '), &block ) if $? && $?.exitstatus != 0 raise HgCommandAborted, ""hg exited with non-zero status: #{$?.exitstatus}"" end ret end",True,Ruby,hg,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) submit_url = url_for(:controller => 'desktop', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end"
494,"def annotate(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) blame = Annotate.new hg 'rhannotate', '-ncu', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io| io.each_line do |line| line.force_encoding('ASCII-8BIT') next unless line =~ %r{^([^:]+)\s(\d+)\s([0-9a-f]+):\s(.*)$} r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3, :identifier => $3) blame.add_line($4.rstrip, r) end end blame rescue HgCommandAborted # means not found or cannot be annotated Annotate.new end",True,Ruby,annotate,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def get_group_users Log.add_info(request, params.inspect) SqlHelper.validate_token([params[:id]]) begin @folder = Folder.find(params[:id]) rescue => evar Log.add_error(request, evar) end @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) @users = Group.get_users(@group_id) render(:partial => 'ajax_select_users', :layout => false) end"
498,"def nodes_in_branch(branch, options={}) hg_args = ['rhlog', '--template', '{node}\n', '--rhbranch', CGI.escape(branch)] hg_args << '--from' << CGI.escape(branch) hg_args << '--to' << '0' hg_args << '--limit' << options[:limit] if options[:limit] hg(*hg_args) { |io| io.readlines.map { |e| e.chomp } } end",True,Ruby,nodes_in_branch,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def show_tree Log.add_info(request, params.inspect) if !@login_user.nil? and @login_user.admin?(User::AUTH_FOLDER) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) @folder_tree = Folder.get_tree_by_group_for_admin(@group_id || '0') else @folder_tree = Folder.get_tree_for(@login_user) end end"
501,"def entries(path=nil, identifier=nil, options={}) p1 = scm_iconv(@path_encoding, 'UTF-8', path) manifest = hg('rhmanifest', '-r', CGI.escape(hgrev(identifier)), '--', CGI.escape(without_leading_slash(p1.to_s))) do |io| output = io.read.force_encoding('UTF-8') begin parse_xml(output)['rhmanifest']['repository']['manifest'] rescue end end path_prefix = path.blank? ? '' : with_trailling_slash(path) entries = Entries.new as_ary(manifest['dir']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" entries << Entry.new(:name => n, :path => p, :kind => 'dir') end as_ary(manifest['file']).each do |e| n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name'])) p = ""#{path_prefix}#{n}"" lr = Revision.new(:revision => e['revision'], :scmid => e['node'], :identifier => e['node'], :time => Time.at(e['time'].to_i)) entries << Entry.new(:name => n, :path => p, :kind => 'file', :size => e['size'].to_i, :lastrev => lr) end entries rescue HgCommandAborted nil # means not found end",True,Ruby,entries,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) @users = Group.get_users(@group_id) render(:partial => 'ajax_select_users', :layout => false) end"
502,"def cat(path, identifier=nil) p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path)) hg 'rhcat', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io| io.binmode io.read end rescue HgCommandAborted nil # means not found end",True,Ruby,cat,mercurial_adapter.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def wf_issue Log.add_info(request, params.inspect) begin @item = Item.find(params[:id]) @workflow = @item.workflow rescue => evar Log.add_error(request, evar) end attrs = ActionController::Parameters.new({status: Workflow::STATUS_ACTIVE, issued_at: Time.now}) @workflow.update_attributes(attrs.permit(Workflow::PERMIT_BASE)) @orders = @workflow.get_orders render(:partial => 'ajax_workflow', :layout => false) end"
504,"def test_bad_early_options assert_raise HgCommandArgumentError do @adapter.diff('sources/welcome_controller.rb', '--config=alias.rhdiff=!xterm') end assert_raise HgCommandArgumentError do @adapter.entries('--debugger') end assert_raise HgCommandArgumentError do @adapter.revisions(nil, nil, nil, limit: '--repo=otherrepo') end assert_raise HgCommandArgumentError do @adapter.nodes_in_branch('default', limit: '--repository=otherrepo') end assert_raise HgCommandArgumentError do @adapter.nodes_in_branch('-Rotherrepo') end end",True,Ruby,test_bad_early_options,mercurial_adapter_test.rb,https://github.com/redmine/redmine,redmine,Toshi MARUYAMA,2017-12-07 11:38:47+00:00,"mercurial: work around faulty parsing of early command options (#27516)

Use -sVALUE and --long=VALUE instead of ""-s VALUE"" and ""--long VALUE""
respectively.

Contributed by Yuya Nishihara.

git-svn-id: http://svn.redmine.org/redmine/trunk@17062 e93f8b46-1217-0410-a6f0-8f06a7374b81",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-18026,"def check_owner return if params[:id].blank? or @login_user.nil? begin owner_id = Item.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_ITEM) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
505,def by_state(items) params[:state] ||= 'all' if items.respond_to?(params[:state]) items.public_send(params[:state]) else items end end,True,Ruby,by_state,issuable_finder.rb,https://gitlab.com/gitlab-org/gitlab-ce,gitlab-org,Robert Speicher,2016-12-06 12:26:48+11:00,"Merge branch 'issue_25064' into 'security'

Ensure state param has a valid value when filtering issuables.

Closes https://gitlab.com/gitlab-org/gitlab-ce/issues/25064

This fix makes sure we only call safe methods on issuable when filtering by state.

See merge request !2038",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2016-9469,"def team_organize Log.add_info(request, params.inspect) team_id = params[:team_id] unless team_id.blank? begin @team = Team.find(team_id) rescue @team = nil ensure if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end end users = @team.get_users_a end team_members = params[:team_members] created = false modified = false if team_members.nil? or team_members.empty? unless team_id.blank? # @team must not be nil. @team.save if modified = @team.clear_users end else if team_members != users if team_id.blank? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users team_members @team.save @team.remove_application team_members modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end"
510,"it ""should delete guest's membership of group"" do count_before=group_with_members.group_members.count delete api(""/groups/#{group_with_members.id}/members/#{guest.id}"", owner) response.status.should == 200 group_with_members.group_members.count.should == count_before - 1 end",True,Ruby,"""should delete guest's membership of group""",group_members_spec.rb,https://gitlab.com/gitlab-org/gitlab-ce,gitlab-org,Valery Sizov,2014-10-29 16:00:55+02:00,"Dont allow guests..developers to manage group members

Signed-off-by: Dmitriy Zaporozhets <dmitriy.zaporozhets@gmail.com>",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2014-8540,"def send_password Log.add_info(request, params.inspect) mail_addr = params[:thetisBoxEdit] SqlHelper.validate_token([mail_addr], ['@-']) begin users = User.where(""email='#{mail_addr}'"").to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end"
516,"def tok(s) case s[0] when ?{ then ['{', s[0,1], s[0,1]] when ?} then ['}', s[0,1], s[0,1]] when ?: then [':', s[0,1], s[0,1]] when ?, then [',', s[0,1], s[0,1]] when ?[ then ['[', s[0,1], s[0,1]] when ?] then [']', s[0,1], s[0,1]] when ?n then nulltok(s) when ?t then truetok(s) when ?f then falsetok(s) when ?"" then strtok(s) when Spc, ?\t, ?\n, ?\r then [:space, s[0,1], s[0,1]] else numtok(s) end end def nulltok(s); s[0,4] == 'null' ? [:val, 'null', nil] : [] end def truetok(s); s[0,4] == 'true' ? [:val, 'true', true] : [] end def falsetok(s); s[0,5] == 'false' ? [:val, 'false', false] : [] end def numtok(s) m = /-?([1-9][0-9]+|[0-9])([.][0-9]+)?([eE][+-]?[0-9]+)?/.match(s) if m && m.begin(0) == 0 if !m[2] && !m[3] [:val, m[0], Integer(m[0])] elsif m[2] [:val, m[0], Float(m[0])] else [:val, m[0], Integer(m[1])*(10**m[3][1..-1].to_i(10))] end else [] end end def strtok(s) m = /""([^""\\]|\\[""\/\\bfnrt]|\\u[0-9a-fA-F]{4})*""/.match(s) if ! m raise Error, ""invalid string literal at #{abbrev(s)}"" end [:str, m[0], unquote(m[0])] end",True,Ruby,tok,okjson.rb,https://github.com/getsentry/raven-ruby,getsentry,Nate Berkopec,2014-12-08 17:49:04-05:00,"Remove scientific computation from okjson

Conflicts:
	spec/raven/okjson_spec.rb",CWE-399,Resource Management Errors,Weaknesses in this category are related to improper management of system resources.,https://cwe.mitre.org/data/definitions/399.html,CVE-2014-9490,"def edit_page # Saved contents of Login User begin @research = Research.where(""user_id=#{@login_user.id}"").first rescue end if @research.nil? @research = Research.new else # Already accepted? if !@research.status.nil? and @research.status != 0 render(:action => 'show_receipt') return end end # Specifying page @page = '01' unless params[:page].blank? @page = params[:page] SqlHelper.validate_token([@page]) end end"
517,"it 'parses zero-leading exponent numbers correctly' do expect(Raven::OkJson.decode(""[123e090]"")).to eq [123000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000] end",True,Ruby,'parses zero-leading exponent numbers correctly',okjson_spec.rb,https://github.com/getsentry/raven-ruby,getsentry,Nate Berkopec,2014-12-08 17:49:04-05:00,"Remove scientific computation from okjson

Conflicts:
	spec/raven/okjson_spec.rb",CWE-399,Resource Management Errors,Weaknesses in this category are related to improper management of system resources.,https://cwe.mitre.org/data/definitions/399.html,CVE-2014-9490,"def save_page Log.add_info(request, params.inspect) # Next page pave_val = params[:page].to_i + 1 @page = sprintf('%02d', pave_val) page_num = Dir.glob(File.join(Research.page_dir, ""_q[0-9][0-9].html.erb"")).length unless params[:research].nil? params[:research].each do |key, value| if value.instance_of?(Array) value.compact! value.delete('') if value.empty? params[:research][key] = nil else params[:research][key] = value.join(""\n"") + ""\n"" end end end end research_id = params[:research_id] SqlHelper.validate_token([research_id]) if research_id.blank? @research = Research.new(params.require(:research).permit(Research::PERMIT_BASE)) @research.status = Research::U_STATUS_IN_ACTON @research.update_attribute(:user_id, @login_user.id) else @research = Research.find(research_id) @research.update_attributes(params.require(:research).permit(Research::PERMIT_BASE)) end if pave_val <= page_num render(:action => 'edit_page') else tmpl_folder, tmpl_q_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_RESEARCH) if tmpl_q_folder.nil? ary = TemplatesHelper.setup_tmpl_folder tmpl_q_folder = ary[4] end items = Folder.get_items_admin(tmpl_q_folder.id, 'xorder ASC') @q_caps_h = {} unless items.nil? items.each do |item| desc = item.description next if desc.nil? or desc.empty? hash = Research.select_q_caps(desc) hash.each do |key, val| @q_caps_h[key] = val end end end render(:action => 'confirm') end rescue => evar Log.add_error(request, evar) @page = '01' render(:action => 'edit_page') end"
520,"def by_frq_order_by_distance return nil if @location.nil? || @q.to_f == 0 sql = <<-SQL SELECT uo.name AS owner, CONCAT(us.name, ' ', us.location) AS display_name, us.net, us.radius, us.lat, us.lon, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance, fa.id AS frequency_assignment_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) INNER JOIN uke_stations us ON us.id = fa.subject_id INNER JOIN uke_operators uo ON uo.id = us.uke_operator_id WHERE f.mhz = :mhz AND fa.usage = 'TX' HAVING distance <= 100 ORDER BY distance ASC SQL result_to_hash(conn.select_all(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':lat', conn.quote_string(@location.latitude.to_s)).gsub(':lon', conn.quote_string(@location.longitude.to_s)).gsub(':mhz', conn.quote_string(Uke::Unifier::frq_string(@q).to_s)))) end",True,Ruby,by_frq_order_by_distance,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def get_group_equipment Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) submit_url = url_for(:controller => 'schedules', :action => 'get_group_equipment') render(:partial => 'common/select_equipment', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end"
521,"def by_string return nil if @q.length < 4 sql = <<-SQL SELECT us.id FROM uke_stations us JOIN uke_operators uo on (uo.id = us.uke_operator_id) WHERE us.uke_import_id = :uke_import_id AND (us.location LIKE '%:like%' OR us.name LIKE '%:like%' OR uo.name LIKE '%:like%') SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':like', conn.quote_string(@q))) end",True,Ruby,by_string,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) submit_url = url_for(:controller => 'schedules', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end"
523,"def by_frq return nil if @q.length < 4 || Uke::Unifier::frq_string(@q) < 1 sql = <<-SQL SELECT DISTINCT subject_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) WHERE f.mhz = :mhz SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz', conn.quote_string(Uke::Unifier::frq_string(@q).to_s))) end",True,Ruby,by_frq,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def check_owner return if params[:id].blank? or @login_user.nil? email = Email.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and email.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
526,"def by_location return nil if @q.strip[0..3] != 'loc:' || (@location = Geocoder.search(@q.gsub('loc:', '').strip).first).nil? bounds_ne = @location.geometry['bounds']['northeast'] bounds_sw = @location.geometry['bounds']['southwest'] @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0) sql = <<-SQL SELECT DISTINCT us.id, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance FROM uke_stations AS us WHERE us.uke_import_id = :uke_import_id AND lat BETWEEN :lat_sw AND :lat_ne AND lon BETWEEN :lon_sw AND :lon_ne ORDER BY distance ASC SQL sql.gsub!(':uke_import_id', @active_import.id.to_s) sql.gsub!(':lat_ne', conn.quote_string(bounds_ne['lat'].to_s)) sql.gsub!(':lat_sw', conn.quote_string(bounds_sw['lat'].to_s)) sql.gsub!(':lon_ne', conn.quote_string(bounds_ne['lng'].to_s)) sql.gsub!(':lon_sw', conn.quote_string(bounds_sw['lng'].to_s)) sql.gsub!(':lat', conn.quote_string(@location.latitude.to_s)) sql.gsub!(':lon', conn.quote_string(@location.longitude.to_s)) result_to_hash select_using_uke_stations_result(sql) end",True,Ruby,by_location,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) submit_url = url_for(:controller => 'send_mails', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :email, :submit_url => submit_url}) end"
527,"def by_news return nil if @q.strip[0..4] != 'news:' || (@location = Geocoder.search(@q.gsub('news:', '').strip).first).nil? bounds_ne = @location.geometry['bounds']['northeast'] bounds_sw = @location.geometry['bounds']['southwest'] @location_radius = (distance_between_points([bounds_ne['lat'], bounds_ne['lng']], [bounds_sw['lat'], bounds_sw['lng']])/1000).round(0) sql = <<-SQL SELECT DISTINCT us.id, (3959 * acos(cos(radians(:lat))*cos(radians(lat))*cos(radians(lon)-radians(:lon))+sin(radians(:lat))*sin(radians(lat)))) AS distance FROM uke_import_news n INNER JOIN uke_stations AS us ON (us.id = n.uke_station_id) WHERE n.uke_import_id = :uke_import_id AND lat BETWEEN :lat_sw AND :lat_ne AND lon BETWEEN :lon_sw AND :lon_ne ORDER BY distance ASC SQL sql.gsub!(':uke_import_id', @active_import.id.to_s) sql.gsub!(':lat_ne', conn.quote_string(bounds_ne['lat'].to_s)) sql.gsub!(':lat_sw', conn.quote_string(bounds_sw['lat'].to_s)) sql.gsub!(':lon_ne', conn.quote_string(bounds_ne['lng'].to_s)) sql.gsub!(':lon_sw', conn.quote_string(bounds_sw['lng'].to_s)) sql.gsub!(':lat', conn.quote_string(@location.latitude.to_s)) sql.gsub!(':lon', conn.quote_string(@location.longitude.to_s)) result_to_hash select_using_uke_stations_result(sql) end",True,Ruby,by_news,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def self.validate_token(tokens, extra_chars=nil) extra_chars = Regexp.escape((extra_chars || []).join()) regexp = Regexp.new(""^[ ]*[a-zA-Z0-9_.#{extra_chars}]+[ ]*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end"
528,"def by_frq_range return nil if @q.strip[0..3] != 'rng:' || (first = Uke::Unifier::frq_string(@q[4..@q.length].split('-').first)) < 1 || (last = Uke::Unifier::frq_string(@q[4..@q.length].split('-').last)) < 1 sql = <<-SQL SELECT DISTINCT fa.subject_id FROM frequencies f INNER JOIN frequency_assignments fa ON (fa.frequency_id = f.id AND fa.subject_type = 'UkeStation' AND fa.uke_import_id = :uke_import_id) WHERE (f.mhz BETWEEN :mhz_start AND :mhz_end) SQL result_to_hash select_using_uke_stations_sql(sql.gsub(':uke_import_id', @active_import.id.to_s).gsub(':mhz_start', conn.quote_string(first.to_s)).gsub(':mhz_end', conn.quote_string(last.to_s))) end",True,Ruby,by_frq_range,finder.rb,https://github.com/arekk/uke,arekk,Arek K,2015-11-17 14:30:39+01:00,SQL injection possibility,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10014,"def self.up add_column :items, :source_id, :integer add_column :addresses, :groups, :text add_column :addresses, :teams, :text add_column :workflows, :groups, :text add_column :users, :figure, :string add_column :groups, :xtype, :string add_column :teams, :req_to_del_at, :datetime change_table :teams do |t| t.timestamps end Team.find_each do |team| begin item = Item.find(team.item_id) rescue end next if item.nil? attrs = ActionController::Parameters.new({created_at: item.created_at, updated_at: item.updated_at}) attrs.permit! team.update_attributes(attrs) end end"
531,def destroy @grade = Grade.find(params[:id]) @grade.destroy render json: {} end,True,Ruby,destroy,grades_controller.rb,https://github.com/jvvlee/MerlinsBoard,jvvlee,App Academy Student,2015-03-19 12:34:41-04:00,"Progresses on grades change view and events. Discovered security vulnerability that allows a course admin to change whatever grade they want if they know the ID, even in other classes",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2015-10033,"def edit_timecard Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse(date_s) end @timecard = Timecard.get_for(@login_user.id, date_s) render(:partial => 'timecard', :layout => false) end"
532,"def update @grade = Grade.find(params[:id]) if @grade.save render json: @grades else render json: @grade.errors.full_messages, status: 422 end end",True,Ruby,update,grades_controller.rb,https://github.com/jvvlee/MerlinsBoard,jvvlee,App Academy Student,2015-03-19 12:34:41-04:00,"Progresses on grades change view and events. Discovered security vulnerability that allows a course admin to change whatever grade they want if they know the ID, even in other classes",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2015-10033,"def team_organize Log.add_info(request, params.inspect) team_id = params[:team_id] unless team_id.blank? begin @team = Team.find(team_id) rescue @team = nil ensure if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end end users = @team.get_users_a end team_members = params[:team_members] SqlHelper.validate_token([team_members]) created = false modified = false if team_members.nil? or team_members.empty? unless team_id.blank? # @team must not be nil. @team.save if modified = @team.clear_users end else if team_members != users if team_id.blank? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users(team_members) @team.save @team.remove_application(team_members) modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end"
536,"def grade_params params.require(:grade).permit(:grade, :assignment_id, :user_id) end",True,Ruby,grade_params,grades_controller.rb,https://github.com/jvvlee/MerlinsBoard,jvvlee,App Academy Student,2015-03-19 12:34:41-04:00,"Progresses on grades change view and events. Discovered security vulnerability that allows a course admin to change whatever grade they want if they know the ID, even in other classes",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2015-10033,"def send_password Log.add_info(request, params.inspect) mail_addr = params[:thetisBoxEdit] SqlHelper.validate_token([mail_addr]) begin users = User.where(""email='#{mail_addr}'"").to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end"
539,"def create @user = User.find_by(params[:user]) if @user.present? @user.deliver_reset_password_instructions! redirect_to new_session_path, notice: ""Verifique seu email para receber instruções de recuperação de senha"" else @user = User.new email: params[:user][:email] flash[:alert] = ""Email não encontrado"" render :new end end",True,Ruby,create,passwords_controller.rb,https://github.com/prodigasistemas/curupira,prodigasistemas,Luiz Sanches,2015-08-13 16:51:14-03:00,fixed SQL injection vulnerability,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-10053,"def show_tree if params[:action] == 'show_tree' Log.add_info(request, params.inspect) end con = [] con << ""(user_id=#{@login_user.id})"" account_xtype = params[:mail_account_xtype] SqlHelper.validate_token([account_xtype]) unless account_xtype.blank? con << ""(xtype='#{account_xtype}')"" end @mail_accounts = MailAccount.find_all(con.join(' and ')) mail_account_ids = [] @mail_accounts.each do |mail_account| mail_account_ids << mail_account.id if MailFolder.where(""mail_account_id=#{mail_account.id}"").count <= 0 @login_user.create_default_mail_folders(mail_account.id) end Email.destroy_by_user(@login_user.id, ""status='#{Email::STATUS_TEMPORARY}'"") end @folder_tree = MailFolder.get_tree_for(@login_user, mail_account_ids) end"
540,"it ""escapes html entities in the table"" do visit ""/admin/#/api_users"" page.should have_content(@user.email) page.should_not have_selector("".xss-test"", :visible => :all) page.should have_content(@user.first_name) page.should have_content(@user.last_name) page.should have_content(@user.use_description) page.should have_content(@user.registration_source) end",True,Ruby,"""escapes html entities in the table""",api_users_spec.rb,https://github.com/NREL/api-umbrella-web,NREL,Nick Muerdter,2015-04-10 11:30:01-06:00,"Fix additional XSS issues in the flash messages in the admin.

A follow-up to XSS issues first identified in
f53a9fb87e10c457f0f3dd4f2af24d3b2f21b3ca.

I've gone through the rest of the admin, and I believe this covers
everything.

This commit is a bit bigger, since it fixes some issues with how our
test elasticsearch database was being setup for this web app (the
database didn't have our actual mappings loaded, so some fields weren't
being indexes as the proper types). These test fixes allow us to now
properly test the analytics by users list, where some additional XSS
tests have been added.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-10072,"def edit Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse(date_s) end if params[:user_id].nil? @selected_user = @login_user else @selected_user = User.find(params[:user_id]) end @timecard = Timecard.get_for(@selected_user.id, date_s) if @selected_user == @login_user @schedules = Schedule.get_user_day(@login_user, @date) end if !params[:display].nil? and params[:display].split('_').first == 'group' @group_id = params[:display].split('_').last end end"
544,"it ""escapes html entities in the form"" do visit ""/admin/#/api_users/#{@user.id}/edit"" find_field(""E-mail"").value.should eql(@user.email) page.should_not have_selector("".xss-test"", :visible => :all) find_field(""First Name"").value.should eql(@user.first_name) find_field(""Last Name"").value.should eql(@user.last_name) find_field(""Purpose"").value.should eql(@user.use_description) page.should have_content(@user.registration_source) end",True,Ruby,"""escapes html entities in the form""",api_users_spec.rb,https://github.com/NREL/api-umbrella-web,NREL,Nick Muerdter,2015-04-10 11:30:01-06:00,"Fix additional XSS issues in the flash messages in the admin.

A follow-up to XSS issues first identified in
f53a9fb87e10c457f0f3dd4f2af24d3b2f21b3ca.

I've gone through the rest of the admin, and I believe this covers
everything.

This commit is a bit bigger, since it fixes some issues with how our
test elasticsearch database was being setup for this web app (the
database didn't have our actual mappings loaded, so some fields weren't
being indexes as the proper types). These test fixes allow us to now
properly test the analytics by users list, where some additional XSS
tests have been added.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-10072,"def query Log.add_info(request, '') # Not to show passwords. unless @login_user.admin?(User::AUTH_ZEPTAIR) render(:text => 'ERROR:' + t('msg.need_to_be_admin')) return end target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] group_id = params[:group_id] SqlHelper.validate_token([user_id, zeptair_id, group_id]) unless user_id.blank? target_user = User.find(user_id) end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first end if target_user.nil? if group_id.blank? sql = 'select distinct Item.* from items Item, attachments Attachment' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << ' order by Item.user_id ASC' else group_ids = [group_id] if params[:recursive] == 'true' group_ids += Group.get_childs(group_id, true, false) end groups_con = [] group_ids.each do |grp_id| groups_con << SqlHelper.get_sql_like(['User.groups'], ""|#{grp_id}|"") end sql = 'select distinct Item.* from items Item, attachments Attachment, users User' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << "" and (Item.user_id=User.id and (#{groups_con.join(' or ')}))"" sql << ' order by Item.user_id ASC' end @post_items = Item.find_by_sql(sql) else @post_item = ZeptairPostHelper.get_item_for(target_user) end rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end"
545,"it ""escapes html entities in the table"" do log = FactoryGirl.create(:xss_log_item, :request_at => Time.parse(""2015-01-16T06:06:28.816Z""), :request_method => ""OPTIONS"") LogItem.gateway.refresh_index! visit ""/admin/#/stats/logs/tz=America%2FDenver&search=&start_at=2015-01-12&end_at=2015-01-18&interval=day"" page.should have_content(log.request_method) page.should_not have_selector("".xss-test"", :visible => :all) page.should have_content(log.request_accept_encoding) page.should have_content(log.request_ip_city) page.should have_content(log.request_ip_country) page.should have_content(log.request_ip_region) page.should have_content(log.request_user_agent) page.should have_content(log.response_content_type) page.should have_content(log.user_email) end",True,Ruby,"""escapes html entities in the table""",stats_logs_spec.rb,https://github.com/NREL/api-umbrella-web,NREL,Nick Muerdter,2015-04-10 11:30:01-06:00,"Fix additional XSS issues in the flash messages in the admin.

A follow-up to XSS issues first identified in
f53a9fb87e10c457f0f3dd4f2af24d3b2f21b3ca.

I've gone through the rest of the admin, and I believe this covers
everything.

This commit is a bit bigger, since it fixes some issues with how our
test elasticsearch database was being setup for this web app (the
database didn't have our actual mappings loaded, so some fields weren't
being indexes as the proper types). These test fixes allow us to now
properly test the analytics by users list, where some additional XSS
tests have been added.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-10072,"def delete_attachment Log.add_info(request, '') # Not to show passwords. target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] attachment_id = params[:attachment_id] SqlHelper.validate_token([user_id, zeptair_id, attachment_id]) unless user_id.blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == user_id.to_s target_user = User.find(user_id) end end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if attachment_id.blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(attachment_id) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end"
551,"def basic_auth authenticate_or_request_with_http_basic do |username, password| expected_username = ENV.fetch(""DYNOSAUR_USERNAME"", DEFAULT_USERNAME) expected_password = ENV.fetch(""DYNOSAUR_PASSWORD"", DEFAULT_PASSWORD) if username != expected_username puts ""Failed username"" return false end if expected_password == password @passed_auth=true return true else begin bcyrpt_password = BCrypt::Password.new(expected_password) if bcyrpt_password == password @passed_auth=true return true else puts ""Failed password"" end rescue BCrypt::Errors::InvalidHash puts ""DYNOSAUR_PASSWORD is not a valid bcrypt hash, so that's not gonna work"" end end puts ""ERROR: Failed basic auth"" request_http_basic_authentication return false end end",True,Ruby,basic_auth,application_controller.rb,https://github.com/harrystech/dynosaur-rails,harrystech,Andy O'Neill,2015-09-15 14:02:06-04:00,"Fix basic auth bypass vulnerability

Serious vulnerability discovered, please update to latest code.",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2015-10083,"def self.get_next_revision(user_id, source_id) SqlHelper.validate_token([user_id, source_id]) copied_items = Item.where(""user_id=#{user_id} and source_id=#{source_id}"").order('created_at DESC').to_a rev = 0 copied_items.each do |item| rev_ary = item.title.scan(/[#](\d\d\d)$/) next if rev_ary.nil? rev = rev_ary.first.to_a.first.to_i break end return ('#' + sprintf('%03d', rev+1)) end"
554,"def get_tweets(account, amount = 3) tweets = [] begin @twitter.user_timeline(account, count: amount).each do |tweet| name = tweet.user.screen_name tweets << { account: name, tweet: tweet.text, time: tweet.created_at, uri: tweet.uri.to_s, id: tweet.id } end rescue StandardError => e warn ""Unable to retrieve Tweet information for #{account}: #{e}"" tweets = nil end tweets end",True,Ruby,get_tweets,twitter_announcer.rb,https://github.com/Zarthus/irc-twitter-bot,Zarthus,Jos Ahrens,2015-08-13 02:29:13+02:00,"Prevent edge-case exploitation that allows execution of arbitrary fantasy commands.

This commit replaces \r\n with '.  ' in tweets.

An edge-case issue where you may be able to exploit the bot having op.
Should you be the one being tracked, you could insert a newline in your tweet, and follow it up for ""!ban <someone>"" to execute a fantasy command.

This exploit requires a lot of requirements to be met. Mainly the fact that the bot has permissions in the channel, and that the followed person is associated and aware of the possibility.",CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),"The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/77.html,CVE-2015-10096,"def self.validate_token(tokens, extra_chars=nil) if extra_chars.nil? extra_chars = '' else extra_chars = Regexp.escape(extra_chars.join()) end regexp = Regexp.new(""^[ ]*[a-zA-Z0-9_.@\\-#{extra_chars}]+[ ]*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end"
555,"def validate_signature(base64_cert, soft = true) # validate references # check for inclusive namespaces inclusive_namespaces = extract_inclusive_namespaces document = Nokogiri.parse(self.to_s) # create a working copy so we don't modify the original @working_copy ||= REXML::Document.new(self.to_s).root # store and remove signature node @sig_element ||= begin element = REXML::XPath.first( @working_copy, ""//ds:Signature"", {""ds""=>DSIG} ) element.remove end # verify signature signed_info_element = REXML::XPath.first( @sig_element, ""//ds:SignedInfo"", {""ds""=>DSIG} ) noko_sig_element = document.at_xpath('//ds:Signature', 'ds' => DSIG) noko_signed_info_element = noko_sig_element.at_xpath('./ds:SignedInfo', 'ds' => DSIG) canon_algorithm = canon_algorithm REXML::XPath.first( @sig_element, '//ds:CanonicalizationMethod', 'ds' => DSIG ) canon_string = noko_signed_info_element.canonicalize(canon_algorithm) noko_sig_element.remove # check digests REXML::XPath.each(@sig_element, ""//ds:Reference"", {""ds""=>DSIG}) do |ref| uri = ref.attributes.get_attribute(""URI"").value hashed_element = document.at_xpath(""//*[@ID='#{uri[1..-1]}']"") canon_algorithm = canon_algorithm REXML::XPath.first( ref, '//ds:CanonicalizationMethod', { ""ds"" => DSIG } ) canon_hashed_element = hashed_element.canonicalize(canon_algorithm, inclusive_namespaces) digest_algorithm = algorithm(REXML::XPath.first( ref, ""//ds:DigestMethod"", { ""ds"" => DSIG } )) hash = digest_algorithm.digest(canon_hashed_element) encoded_digest_value = REXML::XPath.first( ref, ""//ds:DigestValue"", { ""ds"" => DSIG } ).text digest_value = Base64.decode64(encoded_digest_value) unless digests_match?(hash, digest_value) @errors << ""Digest mismatch"" return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(""Digest mismatch"")) end end base64_signature = REXML::XPath.first( @sig_element, ""//ds:SignatureValue"", {""ds"" => DSIG} ).text signature = Base64.decode64(base64_signature) # get certificate object cert_text = Base64.decode64(base64_cert) cert = OpenSSL::X509::Certificate.new(cert_text) # signature method sig_alg_value = REXML::XPath.first( signed_info_element, ""//ds:SignatureMethod"", {""ds""=>DSIG} ) signature_algorithm = algorithm(sig_alg_value) unless cert.public_key.verify(signature_algorithm.new, signature, canon_string) @errors << ""Key validation error"" return soft ? false : (raise OneLogin::RubySaml::ValidationError.new(""Key validation error"")) end return true end",True,Ruby,validate_signature,xml_security.rb,https://github.com/SAML-Toolkits/ruby-saml,SAML-Toolkits,Sixto Martin,2015-04-29 17:25:00+02:00,Fix possible xpath injection,CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),"The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/77.html,CVE-2015-20108,"def self.get_default_for(user_id, xtype=nil) SqlHelper.validate_token([user_id, xtype]) con = [] con << ""(user_id=#{user_id})"" con << '(is_default=1)' con << ""(xtype='#{xtype}')"" unless xtype.blank? where = '' unless con.nil? or con.empty? where = 'where ' + con.join(' and ') end mail_accounts = MailAccount.find_by_sql('select * from mail_accounts ' + where + ' order by xorder ASC, title ASC') if mail_accounts.nil? or mail_accounts.empty? return nil else return mail_accounts.first end end"
557,"def crop_command target = @attachment.instance if target.cropping?(@attachment.name) w = target.send :""#{@attachment.name}_crop_w"" h = target.send :""#{@attachment.name}_crop_h"" x = target.send :""#{@attachment.name}_crop_x"" y = target.send :""#{@attachment.name}_crop_y"" [""-crop"", ""#{w}x#{h}+#{x}+#{y}""] end end",True,Ruby,crop_command,cropper.rb,https://github.com/rsantamaria/papercrop,rsantamaria,rsantamaria,2015-09-21 18:10:38+01:00,"Sanitized crop input, logs with Paperclip log function if anything weird happens",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-2784,"def self.update_for(user_id, fiscal_year, num) SqlHelper.validate_token([user_id, fiscal_year]) if num <= 0 con = [] con << ""(user_id=#{user_id})"" con << ""(year=#{fiscal_year})"" PaidHoliday.destroy_all(con.join(' and ')) return end paid_holiday = PaidHoliday.get_for(user_id, fiscal_year) if paid_holiday.nil? paid_holiday = PaidHoliday.new paid_holiday.user_id = user_id paid_holiday.year = fiscal_year paid_holiday.num = num paid_holiday.save! else paid_holiday.update_attribute(:num, num) end end"
559,"def calculated_media_type @calculated_media_type ||= calculated_content_type.split(""/"").first end",True,Ruby,calculated_media_type,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def remove_application(user_ids) return if user_ids.nil? or user_ids.empty? SqlHelper.validate_token([user_ids]) con = [""(xtype='#{Comment::XTYPE_APPLY}')""] con << ""(item_id=#{self.item_id})"" user_con_a = [] user_ids.each do |user_id| user_con_a << ""(user_id=#{user_id})"" end con << '(' + user_con_a.join(' or ') + ')' Comment.destroy_all(con.join(' and ')) end"
566,def supplied_file_media_types @supplied_file_media_types ||= MIME::Types.type_for(@name).collect(&:media_type) end,True,Ruby,supplied_file_media_types,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def self.get_for(user_id, date_s) SqlHelper.validate_token([user_id, date_s]) begin con = ""(user_id=#{user_id}) and (date='#{date_s}')"" return Timecard.where(con).first rescue end return nil end"
567,def media_type_mismatch? ! supplied_file_media_types.include?(calculated_media_type) end,True,Ruby,media_type_mismatch?,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def self.applied_paid_hlds(user_id, start_date, end_date) SqlHelper.validate_token([user_id]) start_s = start_date.strftime(Schedule::SYS_DATE_FORM) end_s = end_date.strftime(Schedule::SYS_DATE_FORM) sql = ""SELECT COUNT(*) FROM timecards WHERE user_id = #{user_id} AND date >= '#{start_s}' AND date <= '#{end_s}'"" sum = 0.0 self.workcodes.each do |key, params| paidhld_rate = params[WKCODE_PARAM_PAIDHLD] if paidhld_rate > 0.0 num = Timecard.count_by_sql(sql + "" AND workcode='#{key}'"") sum += num * paidhld_rate end end return sum end"
569,"def self.using(file, name) new(file, name) end",True,Ruby,self.using,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def self.find_term(user_id, start_date, end_date) SqlHelper.validate_token([user_id]) start_s = start_date.strftime(Schedule::SYS_DATE_FORM) end_s = end_date.strftime(Schedule::SYS_DATE_FORM) con = ""(user_id=#{user_id}) and (date >= '#{start_s}') and (date <= '#{end_s}')"" ary = Timecard.where(con).order('date ASC').to_a timecards_h = Hash.new unless ary.nil? ary.each do |timecard| timecards_h[timecard.date.strftime(Schedule::SYS_DATE_FORM)] = timecard end end return timecards_h end"
571,"def initialize(file, name) @file = file @name = name end",True,Ruby,initialize,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def self.get_my_folder(user_id) SqlHelper.validate_token([user_id]) return Folder.where(""(owner_id=#{user_id}) and (xtype='#{Folder::XTYPE_USER}')"").first end"
574,"def filename_extension File.extname(@name.to_s.downcase).sub(/^\./, '').to_sym end",True,Ruby,filename_extension,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,def gate_process HistoryHelper.keep_last(request) @login_user = User.find(session[:login_user_id]) begin if @login_user.nil? \ or @login_user.time_zone.nil? or @login_user.time_zone.empty? unless THETIS_USER_TIMEZONE_DEFAULT.nil? or THETIS_USER_TIMEZONE_DEFAULT.empty? Time.zone = THETIS_USER_TIMEZONE_DEFAULT end else Time.zone = @login_user.time_zone end rescue => evar logger.fatal(evar.to_s) end end
576,def mapped_content_type Paperclip.options[:content_type_mappings][filename_extension] end,True,Ruby,mapped_content_type,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def paginate_by_sql(model, sql, per_page, options={}) if options[:count].blank? total = model.count_by_sql_wrapping_select_query(sql) else if options[:count].is_a?(Integer) total = options[:count] #else # total = model.count_by_sql(options[:count]) end end SqlHelper.validate_token([params['page']]) object_pages = model.paginate_by_sql(sql, {:page => params['page'], :per_page => per_page}) return [object_pages, object_pages, total] end"
578,def calculated_content_type @calculated_content_type ||= type_from_file_command.chomp end,True,Ruby,calculated_content_type,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def show if params[:action] == 'show' Log.add_info(request, params.inspect) end begin @mail_filter = MailFilter.find(params[:id]) rescue => evar end if @mail_filter.nil? render(:text => 'ERROR:' + t('msg.already_deleted', :name => MailFilter.model_name.human)) return else if @mail_filter.mail_account.user_id != @login_user.id render(:text => 'ERROR:' + t('msg.need_to_be_owner')) return end end render(:action => 'show', :layout => (!request.xhr?)) end"
579,def supplied_file_content_types @supplied_file_content_types ||= MIME::Types.type_for(@name).collect(&:content_type) end,True,Ruby,supplied_file_content_types,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def update_order Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] order_arr = params[:mail_filters_order] SqlHelper.validate_token([mail_account_id]) @mail_account = MailAccount.find(mail_account_id) if @mail_account.user_id != @login_user.id render(:text => 'ERROR:' + t('msg.need_to_be_owner')) return end filters = MailFilter.get_for(mail_account_id) # filters must be ordered by xorder ASC. filters.sort! { |filter_a, filter_b| id_a = filter_a.id.to_s id_b = filter_b.id.to_s idx_a = order_arr.index(id_a) idx_b = order_arr.index(id_b) if idx_a.nil? or idx_b.nil? idx_a = filters.index(id_a) idx_b = filters.index(id_b) end idx_a - idx_b } idx = 1 filters.each do |filter| next if filter.mail_account_id != mail_account_id.to_i filter.update_attribute(:xorder, idx) idx += 1 end render(:text => '') end"
580,"def spoofed? if has_name? && has_extension? && media_type_mismatch? && mapping_override_mismatch? Paperclip.log(""Content Type Spoof: Filename #{File.basename(@name)} (#{supplied_file_content_types}), content type discovered from file command: #{calculated_content_type}. See documentation to allow this combination."") true end end",True,Ruby,spoofed?,media_type_spoof_detector.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def do_execute Log.add_info(request, params.inspect) mail_account = MailAccount.find(params[:mail_account_id]) mail_folder = MailFolder.find(params[:mail_folder_id]) if mail_account.user_id != @login_user.id \ or mail_folder.user_id != @login_user.id render(:text => t('msg.need_to_be_owner')) return end mail_filters = MailFilter.get_for(mail_account.id, true, MailFilter::TRIGGER_MANUAL) emails = MailFolder.get_mails(mail_folder.id, mail_folder.user_id) filter_next = true emails.each do |email| mail_filters.each do |filter| filter_next = filter.execute(email) break unless filter_next end break unless filter_next end render(:text => '') end"
584,"def validate_each(record, attribute, value) adapter = Paperclip.io_adapters.for(value) if Paperclip::MediaTypeSpoofDetector.using(adapter, value.original_filename).spoofed? record.errors.add(attribute, :spoofed_media_type) end end",True,Ruby,validate_each,media_type_spoof_detection_validator.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def get_order Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] SqlHelper.validate_token([mail_account_id]) @mail_account = MailAccount.find(mail_account_id) if @mail_account.user_id != @login_user.id flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') return end @mail_filters = MailFilter.get_for(mail_account_id) render(:partial => 'ajax_order', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_order', :layout => false) end"
588,"it ""returns default error message for spoofed media type"" do build_validator file = File.new(fixture_file(""5k.png""), ""rb"") @dummy.avatar.assign(file) detector = mock(""detector"", :spoofed? => true) Paperclip::MediaTypeSpoofDetector.stubs(:using).returns(detector) @validator.validate(@dummy) assert_equal ""has an extension that does not match its contents"", @dummy.errors[:avatar].first end",True,Ruby,"""returns default error message for spoofed media type""",media_type_spoof_detection_validator_spec.rb,https://github.com/thoughtbot/paperclip,thoughtbot,Tute Costa,2015-06-05 11:25:07-04:00,"Fix a possible security issue with spoofing

Thanks to MORI Shingo of DeNA Co., Ltd. for reporting this.

There is an issue where if an HTML file is uploaded with a .html
extension, but the content type is listed as being `image/jpeg`, this
will bypass a validation checking for images. But it will also pass the
spoof check, because a file named .html and containing actual HTML
passes the spoof check.

This change makes it so that we also check the supplied content type. So
even if the file contains HTML and ends with .html, it doesn't match the
content type of `image/jpeg` and so it fails.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-2963,"def update_folders_order Log.add_info(request, params.inspect) order_arr = params[:folders_order] SqlHelper.validate_token([params[:id]]) folders = MailFolder.get_childs(params[:id], false, false) # folders must be ordered by xorder ASC. folders.sort! { |id_a, id_b| idx_a = order_arr.index(id_a) idx_b = order_arr.index(id_b) if idx_a.nil? or idx_b.nil? idx_a = folders.index(id_a) idx_b = folders.index(id_b) end idx_a - idx_b } idx = 1 folders.each do |folder_id| begin folder = MailFolder.find(folder_id) next if folder.user_id != @login_user.id folder.update_attribute(:xorder, idx) if folder.xtype == MailFolder::XTYPE_ACCOUNT_ROOT mail_account = MailAccount.find_by_id(folder.mail_account_id) unless mail_account.nil? mail_account.update_attribute(:xorder, idx) end end idx += 1 rescue => evar Log.add_error(request, evar) end end render(:text => '') end"
589,"def list Log.add_info(request, params.inspect) con = [] @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end unless @group_id.nil? if @group_id == '0' con << ""((groups like '%|0|%') or (groups is null))"" else con << ApplicationHelper.get_sql_like([:groups], ""|#{@group_id}|"") end end where = '' unless con.empty? where = ' where ' + con.join(' and ') end order_by = nil @sort_col = params[:sort_col] @sort_type = params[:sort_type] if @sort_col.blank? or @sort_type.blank? @sort_col = 'id' @sort_type = 'ASC' end SqlHelper.validate_token([@sort_col, @sort_type]) order_by = ' order by ' + @sort_col + ' ' + @sort_type sql = 'select distinct Equipment.* from equipment Equipment' sql << where + order_by @equipment_pages, @equipment, @total_num = paginate_by_sql(Equipment, sql, 20) end",True,Ruby,list,equipment_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-04 09:40:26+09:00,"x ApplicationHelper.get_sql_like() -> o SqlHelper.get_sql_like()
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def ajax_delete_mails Log.add_info(request, params.inspect) folder_id = params[:id] mail_account_id = params[:mail_account_id] unless params[:check_mail].blank? mail_folder = MailFolder.find(folder_id) trash_folder = MailFolder.get_for(@login_user, mail_account_id, MailFolder::XTYPE_TRASH) count = 0 params[:check_mail].each do |email_id, value| next if value != '1' begin email = Email.find(email_id) rescue => evar end next if email.nil? or (email.user_id != @login_user.id) if trash_folder.nil? \ or folder_id == trash_folder.id.to_s \ or mail_folder.get_parents(false).include?(trash_folder.id.to_s) email.destroy flash[:notice] ||= t('msg.delete_success') else begin email.update_attribute(:mail_folder_id, trash_folder.id) flash[:notice] ||= t('msg.moved_to_trash') rescue => evar Log.add_error(request, evar) email.destroy flash[:notice] ||= t('msg.delete_success') end end count += 1 end end get_mails end"
591,"def schedule_all Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end if @login_user.nil? or params[:display].nil? or params[:display] == 'all' params[:display] = 'all' con = EquipmentHelper.get_scope_condition_for(@login_user) else display_type = params[:display].split('_').first display_id = params[:display].split('_').last case display_type when 'group' if @login_user.get_groups_a(true).include?(display_id) con = ApplicationHelper.get_sql_like([:groups], ""|#{display_id}|"") end when 'team' if @login_user.get_teams_a.include?(display_id) con = ApplicationHelper.get_sql_like([:teams], ""|#{display_id}|"") end end end",True,Ruby,schedule_all,equipment_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-04 09:40:26+09:00,"x ApplicationHelper.get_sql_like() -> o SqlHelper.get_sql_like()
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_mail_attachment Log.add_info(request, params.inspect) attached_id = params[:id].to_i begin mail_attach = MailAttachment.find(attached_id) rescue => evar end if mail_attach.nil? redirect_to(THETIS_RELATIVE_URL_ROOT + '/404.html') return end begin email = Email.find(mail_attach.email_id) rescue => evar end if email.nil? or email.user_id != @login_user.id render(:text => '') return end mail_attach_name = mail_attach.name agent = request.env['HTTP_USER_AGENT'] unless agent.nil? ie_ver = nil agent.scan(/\sMSIE\s?(\d+)[.](\d+)/){|m| ie_ver = m[0].to_i + (0.1 * m[1].to_i) } mail_attach_name = CGI::escape(mail_attach_name) unless ie_ver.nil? end filepath = mail_attach.get_path if FileTest.exist?(filepath) send_file(filepath, :filename => mail_attach_name, :stream => true, :disposition => 'attachment') else send_data('', :type => 'application/octet-stream;', :disposition => 'attachment;filename=""'+mail_attach_name+'""') end end"
593,"def get_users if params[:action] == 'get_users' Log.add_info(request, params.inspect) end @group_id = params[:id] # FEATURE_PAGING_IN_TREE >>> con = ['User.id > 0'] unless @group_id.nil? if @group_id == '0' con << ""((groups like '%|0|%') or (groups is null))"" else con << ApplicationHelper.get_sql_like([:groups], ""|#{@group_id}|"") end end unless params[:keyword].blank? key_array = params[:keyword].split(nil) key_array.each do |key| con << SqlHelper.get_sql_like([:name, :email, :fullname, :address, :organization, :tel1, :tel2, :tel3, :fax, :url, :postalcode, :title], key) end end where = '' unless con.empty? where = ' where ' + con.join(' and ') end order_by = nil @sort_col = params[:sort_col] @sort_type = params[:sort_type] if @sort_col.blank? or @sort_type.blank? @sort_col = 'OfficialTitle.xorder' @sort_type = 'ASC' end SqlHelper.validate_token([@sort_col, @sort_type]) order_by = @sort_col + ' ' + @sort_type if @sort_col == 'OfficialTitle.xorder' order_by = '(OfficialTitle.xorder is null) ' + @sort_type + ', ' + order_by else order_by << ', (OfficialTitle.xorder is null) ASC, OfficialTitle.xorder ASC' end if @sort_col != 'name' order_by << ', name ASC' end sql = 'select distinct User.* from (users User left join user_titles UserTitle on User.id=UserTitle.user_id)' sql << ' left join official_titles OfficialTitle on UserTitle.official_title_id=OfficialTitle.id' sql << where + ' order by ' + order_by @user_pages, @users, @total_num = paginate_by_sql(User, sql, 50) # FEATURE_PAGING_IN_TREE <<< session[:group_id] = @group_id session[:group_option] = 'user' render(:partial => 'ajax_group_users', :layout => false) end",True,Ruby,get_users,groups_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-04 09:40:26+09:00,"x ApplicationHelper.get_sql_like() -> o SqlHelper.get_sql_like()
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def ajax_move_mails Log.add_info(request, params.inspect) folder_id = params[:thetisBoxSelKeeper].split(':').last SqlHelper.validate_token([folder_id]) begin mail_folder = MailFolder.find(folder_id) rescue => evar end if folder_id == '0' \ or mail_folder.nil? \ or mail_folder.user_id != @login_user.id flash[:notice] = 'ERROR:' + t('msg.cannot_save_in_folder') get_mails return end unless params[:check_mail].blank? count = 0 params[:check_mail].each do |email_id, value| if value == '1' begin email = Email.find(email_id) next if email.user_id != @login_user.id email.update_attribute(:mail_folder_id, folder_id) rescue => evar Log.add_error(request, evar) end count += 1 end end flash[:notice] = t('mail.moved', :count => count) end get_mails end"
596,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end submit_url = url_for(:controller => 'desktop', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end",True,Ruby,get_group_users,desktop_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_mail_attachments Log.add_info(request, params.inspect) email_id = params[:id] email = Email.find(email_id) if email.nil? or email.user_id != @login_user.id render(:text => '') return end download_name = ""mail_attachments#{email.id}.zip"" zip_file = email.zip_attachments(params[:enc]) if zip_file.nil? send_data('', :type => 'application/octet-stream;', :disposition => 'attachment;filename=""'+download_name+'""') else filepath = zip_file.path send_file(filepath, :filename => download_name, :stream => true, :disposition => 'attachment') end end"
599,"def get_group_users Log.add_info(request, params.inspect) begin @folder = Folder.find(params[:id]) rescue => evar Log.add_error(request, evar) end @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end @users = Group.get_users @group_id render(:partial => 'ajax_select_users', :layout => false) end",True,Ruby,get_group_users,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.execute_action_move(mail_filter, email, val) mail_folder_id = val SqlHelper.validate_token([mail_folder_id]) begin mail_folder = MailFolder.find(mail_folder_id) rescue => evar end if !mail_folder.nil? and (mail_folder.user_id == email.user_id) email.update_attribute(:mail_folder_id, mail_folder_id) end return true end"
600,"def show_tree Log.add_info(request, params.inspect) if !@login_user.nil? and @login_user.admin?(User::AUTH_FOLDER) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end @folder_tree = Folder.get_tree_by_group_for_admin(@group_id || '0') else @folder_tree = Folder.get_tree_for(@login_user) end end",True,Ruby,show_tree,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_import(mode, address_names) #, address_emails err_msgs = [] # Existing Addresss unless self.id.nil? or self.id == 0 or self.id == '' if mode == 'add' err_msgs << I18n.t('address.import.dont_specify_id') else begin org_address = Address.find(self.id) rescue end if org_address.nil? err_msgs << I18n.t('address.import.not_found') end end end # Requierd if self.name.nil? or self.name.empty? err_msgs << Address.human_attribute_name('name') + I18n.t('msg.is_required') end # Groups unless self.groups.nil? or self.groups.empty? if (/^|([0-9]+|)+$/ =~ self.groups) == 0 self.get_groups_a.each do |group_id| begin group = Group.find(group_id) rescue => evar group = nil end if group.nil? err_msgs << I18n.t('address.import.not_valid_groups') + ': '+group_id.to_s break end end else err_msgs << I18n.t('address.import.invalid_groups_format') end end # Teams unless self.teams.nil? or self.teams.empty? if (/^|([0-9]+|)+$/ =~ self.teams) == 0 self.get_teams_a.each do |team_id| begin team = Team.find(team_id) rescue => evar team = nil end if team.nil? err_msgs << I18n.t('address.import.not_valid_teams') + ': '+team_id.to_s break end end else err_msgs << I18n.t('address.import.invalid_teams_format') end end return err_msgs end"
602,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end @users = Group.get_users @group_id render(:partial => 'ajax_select_users', :layout => false) end",True,Ruby,get_group_users,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.parse_csv_row(row, book, idxs, user) imp_id = (idxs[0].nil? or row[idxs[0]].nil?)?(nil):(row[idxs[0]].strip) SqlHelper.validate_token([imp_id]) unless imp_id.blank? org_address = Address.find_by_id(imp_id) end if org_address.nil? address = Address.new else address = org_address end address.id = imp_id attr_names = [ :name, :name_ruby, :nickname, :screenname, :email1, :email2, :email3, :postalcode, :address, :tel1_note, :tel1, :tel2_note, :tel2, :tel3_note, :tel3, :fax, :url, :organization, :title, :memo, :xorder, :groups, :teams ] attr_names.each_with_index do |attr_name, idx| row_idx = idxs[idx+1] break if row_idx.nil? val = (row[row_idx].nil?)?(nil):(row[row_idx].strip) address.send(attr_name.to_s + '=', val) end if (address.groups == Address::EXP_IMP_FOR_ALL) \ or (book == Address::BOOK_COMMON and address.groups.blank? and address.teams.blank?) address.groups = nil address.teams = nil address.owner_id = 0 elsif !address.groups.blank? or !address.teams.blank? address.owner_id = 0 else address.owner_id = user.id end return address end"
604,"def wf_issue Log.add_info(request, params.inspect) begin @item = Item.find(params[:id]) @workflow = @item.workflow rescue => evar Log.add_error(request, evar) end attrs = ActionController::Parameters.new({status: Workflow::STATUS_ACTIVE, issued_at: Time.now}) @workflow.update_attributes(attrs.permit(Workflow::PERMIT_BASE)) @orders = @workflow.get_orders render(:partial => 'ajax_workflow', :layout => false) end",True,Ruby,wf_issue,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def attachments_without_content return [] if self.id.nil? sql = 'select id, title, memo, name, size, content_type, comment_id, xorder, location from attachments' sql << ' where comment_id=' + self.id.to_s sql << ' order by xorder ASC' begin attachments = Attachment.find_by_sql(sql) rescue => evar Log.add_error(nil, evar) end return (attachments || []) end"
609,"def check_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? begin owner_id = Item.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_ITEM) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def is_a_copy?(folder_obj_cache=nil) return false if self.source_id.nil? # Exclude those created from system templates. begin src_item = Item.find(self.source_id) rescue => evar src_item = nil end if src_item.nil? return true else return !src_item.in_system_folder?(folder_obj_cache) end end
610,"def team_organize Log.add_info(request, params.inspect) team_id = params[:team_id] unless team_id.nil? or team_id.empty? begin @team = Team.find(team_id) rescue @team = nil ensure if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end end users = @team.get_users_a end team_members = params[:team_members] created = false modified = false if team_members.nil? or team_members.empty? unless team_id.nil? or team_id.empty? # @team must not be nil. @team.save if modified = @team.clear_users end else if team_members != users if team_id.nil? or team_id.empty? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users team_members @team.save @team.remove_application team_members modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end",True,Ruby,team_organize,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for_user(user) return [] if user.nil? toys = Toy.where(""user_id=#{user.id}"").to_a deleted_arr = [] return [] if toys.nil? toys.each do |toy| case toy.xtype when Toy::XTYPE_ITEM item = Item.find_by_id(toy.target_id) if item.nil? deleted_arr << toy next end Toy.copy(toy, item) when Toy::XTYPE_COMMENT comment = Comment.find_by_id(toy.target_id) if comment.nil? deleted_arr << toy next end Toy.copy(toy, comment) when Toy::XTYPE_WORKFLOW workflow = Workflow.find_by_id(toy.target_id) if workflow.nil? deleted_arr << toy next end Toy.copy(toy, workflow) when Toy::XTYPE_SCHEDULE schedule = Schedule.find_by_id(toy.target_id) if schedule.nil? deleted_arr << toy next end Toy.copy(toy, schedule) when Toy::XTYPE_FOLDER folder = Folder.find_by_id(toy.target_id) if folder.nil? deleted_arr << toy next end Toy.copy(toy, folder) end end"
615,"def send_password Log.add_info(request, params.inspect) begin users = User.where(""email='#{params[:thetisBoxEdit]}'"").to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end",True,Ruby,send_password,login_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_import(mode, user_names) #, user_emails err_msgs = [] # Existing Users unless self.id.nil? or self.id == 0 or self.id == '' if mode == 'add' err_msgs << I18n.t('user.import.dont_specify_id') else begin org_user = User.find(self.id) rescue end if org_user.nil? err_msgs << I18n.t('user.import.not_found') end end end # Required if self.name.nil? or self.name.empty? err_msgs << User.human_attribute_name('name') + I18n.t('msg.is_required') end if self.pass_md5.nil? or self.pass_md5.empty? if mode == 'update' and !org_user.nil? self.pass_md5 = org_user.pass_md5 end end if self.pass_md5.nil? or self.pass_md5.empty? err_msgs << I18n.t('password.name') + I18n.t('msg.is_required') end if self.email.nil? or self.email.empty? err_msgs << User.human_attribute_name('email') + I18n.t('msg.is_required') end # Duplicated if user_names.include?(self.name) err_msgs << User.human_attribute_name('name') + I18n.t('msg.is_duplicated') elsif !self.name.nil? and !self.name.empty? user_names << self.name end # Comment out considering about administrative users. # if user_emails.include?(self.email) # err_msgs << User.human_attribute_name('email') + I18n.t('msg.is_duplicated') # elsif !self.email.nil? and !self.email.empty? # user_emails << self.email # end # Characters if (/^[01-9a-zA-Z]+$/ =~ self.name).nil? err_msgs << User.human_attribute_name('name') + I18n.t('activerecord.errors.models.user.attributes.name.invalid', :attribute => User.human_attribute_name('name')) end # Authority unless self.auth.nil? or self.auth.empty? or self.auth == User::AUTH_ALL if (/^|([a-z]+|)+$/ =~ self.auth) == 0 keys = User.get_auth_names.keys() keys.delete(User::AUTH_ALL) self.get_auth_a.each do |auth| unless keys.include?(auth) err_msgs << I18n.t('user.import.not_valid_auth') + ': '+auth.to_s break end end else err_msgs << I18n.t('user.import.invalid_auth_format') end end # Groups unless self.groups.nil? or self.groups.empty? if (/^|([0-9]+|)+$/ =~ self.groups) == 0 self.get_groups_a.each do |group_id| begin group = Group.find(group_id) rescue => evar group = nil end if group.nil? err_msgs << I18n.t('user.import.not_valid_groups') + ': '+group_id.to_s break end end else err_msgs << I18n.t('user.import.invalid_groups_format') end end return err_msgs end"
619,"def edit_page # Saved contents of Login User begin @research = Research.where(""user_id=#{@login_user.id}"").first rescue end if @research.nil? @research = Research.new else # Already accepted? if !@research.status.nil? and @research.status != 0 render(:action => 'show_receipt') return end end # Specifying page @page = '01' unless params[:page].nil? or params[:page].empty? @page = params[:page] end end",True,Ruby,edit_page,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def gate_process HistoryHelper.keep_last(request) SqlHelper.validate_token([session[:login_user_id]]) begin @login_user = User.find(session[:login_user_id]) rescue => evar @login_user = nil end begin if @login_user.nil? \ or @login_user.time_zone.nil? or @login_user.time_zone.empty? unless THETIS_USER_TIMEZONE_DEFAULT.nil? or THETIS_USER_TIMEZONE_DEFAULT.empty? Time.zone = THETIS_USER_TIMEZONE_DEFAULT end else Time.zone = @login_user.time_zone end rescue => evar logger.fatal(evar.to_s) end end
621,"def save_page Log.add_info(request, params.inspect) # Next page pave_val = params[:page].to_i + 1 @page = sprintf('%02d', pave_val) page_num = Dir.glob(File.join(Research.page_dir, ""_q[0-9][0-9].html.erb"")).length unless params[:research].nil? params[:research].each do |key, value| if value.instance_of?(Array) value.compact! value.delete('') if value.empty? params[:research][key] = nil else params[:research][key] = value.join(""\n"") + ""\n"" end end end end if params[:research_id].nil? or params[:research_id].empty? @research = Research.new(params.require(:research).permit(Research::PERMIT_BASE)) @research.status = Research::U_STATUS_IN_ACTON @research.update_attribute(:user_id, @login_user.id) else @research = Research.find(params[:research_id]) @research.update_attributes(params.require(:research).permit(Research::PERMIT_BASE)) end if pave_val <= page_num render(:action => 'edit_page') else tmpl_folder, tmpl_q_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_RESEARCH) if tmpl_q_folder.nil? ary = TemplatesHelper.setup_tmpl_folder tmpl_q_folder = ary[4] end items = Folder.get_items_admin(tmpl_q_folder.id, 'xorder ASC') @q_caps_h = {} unless items.nil? items.each do |item| desc = item.description next if desc.nil? or desc.empty? hash = Research.select_q_caps(desc) hash.each do |key, val| @q_caps_h[key] = val end end end render(:action => 'confirm') end rescue => evar Log.add_error(request, evar) @page = '01' render(:action => 'edit_page') end",True,Ruby,save_page,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_owner return if (params[:id].blank? or @login_user.nil?) address = Address.find(params[:id]) if !@login_user.admin?(User::AUTH_ADDRESSBOOK) and address.owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
624,"def get_group_equipment Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end submit_url = url_for(:controller => 'schedules', :action => 'get_group_equipment') render(:partial => 'common/select_equipment', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end",True,Ruby,get_group_equipment,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_by_ajax Log.add_info(request, params.inspect) return unless request.post? cat_h = {:desktop => User::AUTH_DESKTOP, :user => User::AUTH_USER, :log => User::AUTH_LOG} yaml = ApplicationHelper.get_config_yaml cat_h.keys.each do |cat| next if params[cat].blank? unless @login_user.admin?(cat_h[cat]) render(:text => t('msg.need_to_be_admin')) return end yaml[cat] ||= {} params[cat].each do |key, val| yaml[cat][key] = val end end ApplicationHelper.save_config_yaml(yaml) render(:text => '') end"
625,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end submit_url = url_for(:controller => 'schedules', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end",True,Ruby,get_group_users,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_config Log.add_info(request, params.inspect) return unless request.post? @yaml = ApplicationHelper.get_config_yaml unless params[:desktop].blank? @yaml[:desktop] = Hash.new if @yaml[:desktop].nil? params[:desktop].each do |key, val| @yaml[:desktop][key] = val end ApplicationHelper.save_config_yaml(@yaml) end flash[:notice] = t('msg.update_success') render(:partial => 'ajax_user_before_login', :layout => false) end"
628,"def check_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? email = Email.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and email.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,send_mails_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update Log.add_info(request, params.inspect) return unless request.post? SqlHelper.validate_token([params[:groups], params[:teams]]) @equipment = Equipment.find(params[:id]) if params[:groups].blank? params[:equipment][:groups] = nil else params[:equipment][:groups] = '|' + params[:groups].join('|') + '|' end if params[:teams].blank? params[:equipment][:teams] = nil else params[:equipment][:teams] = '|' + params[:teams].join('|') + '|' end if @equipment.update_attributes(params.require(:equipment).permit(Equipment::PERMIT_BASE)) flash[:notice] = t('msg.update_success') list render(:action => 'list') else render(:controller => 'equipment', :action => 'edit', :id => params[:id]) end end"
629,"def get_group_users Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].nil? and !params[:group_id].empty? @group_id = params[:group_id] end submit_url = url_for(:controller => 'send_mails', :action => 'get_group_users') render(:partial => 'common/select_users', :layout => false, :locals => {:target_attr => :email, :submit_url => submit_url}) end",True,Ruby,get_group_users,send_mails_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def schedule_all Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today else @date = Date.parse(date_s) end if @login_user.nil? or params[:display].nil? or params[:display] == 'all' params[:display] = 'all' con = EquipmentHelper.get_scope_condition_for(@login_user) else display_type = params[:display].split('_').first display_id = params[:display].split('_').last case display_type when 'group' if @login_user.get_groups_a(true).include?(display_id) con = SqlHelper.get_sql_like([:groups], ""|#{display_id}|"") end when 'team' if @login_user.get_teams_a.include?(display_id) con = SqlHelper.get_sql_like([:teams], ""|#{display_id}|"") end end end"
636,"def self.validate_token(tokens, extra_chars=nil) extra_chars ||= [] regexp = Regexp.new(""^\s*[a-zA-Z0-9_.#{extra_chars.join()}]+\s*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end",True,Ruby,self.validate_token,sql_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def create Log.add_info(request, params.inspect) return unless request.post? parent_id = params[:selectedFolderId] unless Folder.check_user_auth(parent_id, @login_user, 'w', true) flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') render(:partial => 'ajax_folder_entry', :layout => false) return end if params[:thetisBoxEdit].blank? @folder = nil else @folder = Folder.new @folder.name = params[:thetisBoxEdit] @folder.xorder = Folder.get_order_max(parent_id) + 1 @folder.parent_id = parent_id @folder.inherit_parent_auth @folder.save! end render(:partial => 'ajax_folder_entry', :layout => false) end"
638,"def self.up add_column :items, :source_id, :integer add_column :addresses, :groups, :text add_column :addresses, :teams, :text add_column :workflows, :groups, :text add_column :users, :figure, :string add_column :groups, :xtype, :string add_column :teams, :req_to_del_at, :datetime change_table :teams do |t| t.timestamps end teams = Team.all unless teams.nil? teams.each do |team| begin item = Item.find(team.item_id) rescue end next if item.nil? attrs = ActionController::Parameters.new({created_at: item.created_at, updated_at: item.updated_at}) attrs.permit! team.update_attributes(attrs) end end end",True,Ruby,self.up,20110524100000_changes_for_ver110.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-05 22:30:39+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_auth_users Log.add_info(request, params.inspect) return unless request.post? @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_users = [] write_users = [] users_auth = params[:users_auth] unless users_auth.nil? users_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_users << user_id end if auths.include?('w') write_users << user_id end end end user_id = @folder.get_my_folder_owner if !user_id.nil? and (!read_users.include?(user_id.to_s) or !write_users.include?(user_id.to_s)) flash[:notice] = 'ERROR:' + t('folder.my_folder_without_auth_owner') else @folder.set_read_users(read_users) @folder.set_write_users(write_users) @folder.save flash[:notice] = t('msg.register_success') end else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end @group_id = params[:group_id] SqlHelper.validate_token([@group_id]) if @group_id.blank? @users = [] else @users = Group.get_users(@group_id) end render(:partial => 'ajax_auth_users', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_users', :layout => false) end"
639,"def edit_timecard Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse(date_s) end @timecard = Timecard.get_for(@login_user.id, date_s) render(:partial => 'timecard', :layout => false) end",True,Ruby,edit_timecard,desktop_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_path Log.add_info(request, params.inspect) if params[:thetisBoxSelKeeper].blank? @folder_path = '/' + t('paren.unknown') render(:partial => 'ajax_folder_path', :layout => false) return end @selected_id = params[:thetisBoxSelKeeper].split(':').last SqlHelper.validate_token([@selected_id]) @folder_path = Folder.get_path(@selected_id) render(:partial => 'ajax_folder_path', :layout => false) end"
642,"def team_organize Log.add_info(request, params.inspect) team_id = params[:team_id] unless team_id.blank? begin @team = Team.find(team_id) rescue @team = nil ensure if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end end users = @team.get_users_a end team_members = params[:team_members] created = false modified = false if team_members.nil? or team_members.empty? unless team_id.blank? # @team must not be nil. @team.save if modified = @team.clear_users end else if team_members != users if team_id.blank? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users team_members @team.save @team.remove_application team_members modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end",True,Ruby,team_organize,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_auth_groups Log.add_info(request, params.inspect) folder_id = params[:id] SqlHelper.validate_token([folder_id]) begin @folder = Folder.find(folder_id) rescue @folder = nil end @groups = Group.where(nil).to_a session[:folder_id] = folder_id render(:partial => 'ajax_auth_groups', :layout => false) end"
643,"def send_password Log.add_info(request, params.inspect) mail_addr = params[:thetisBoxEdit] SqlHelper.validate_token([mail_addr], ['@-']) begin users = User.where(""email='#{mail_addr}'"").to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end",True,Ruby,send_password,login_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def rename Log.add_info(request, params.inspect) return unless request.post? @folder = Folder.find(params[:id]) unless Folder.check_user_auth(@folder.id, @login_user, 'w', true) flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') render(:partial => 'ajax_folder_name', :layout => false) return end unless params[:thetisBoxEdit].blank? @folder.name = params[:thetisBoxEdit] @folder.save end render(:partial => 'ajax_folder_name', :layout => false) end"
645,"def show_tree if params[:action] == 'show_tree' Log.add_info(request, params.inspect) end con = [] con << ""(user_id=#{@login_user.id})"" account_xtype = params[:mail_account_xtype] unless account_xtype.blank? SqlHelper.validate_token([account_xtype]) con << ""(xtype='#{account_xtype}')"" end @mail_accounts = MailAccount.find_all(con.join(' and ')) mail_account_ids = [] @mail_accounts.each do |mail_account| mail_account_ids << mail_account.id if MailFolder.where(""mail_account_id=#{mail_account.id}"").count <= 0 @login_user.create_default_mail_folders(mail_account.id) end Email.destroy_by_user(@login_user.id, ""status='#{Email::STATUS_TEMPORARY}'"") end @folder_tree = MailFolder.get_tree_for(@login_user, mail_account_ids) end",True,Ruby,show_tree,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_auth_teams Log.add_info(request, params.inspect) return unless request.post? @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_teams = [] write_teams = [] teams_auth = params[:teams_auth] unless teams_auth.nil? teams_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_teams << user_id end if auths.include?('w') write_teams << user_id end end end @folder.set_read_teams(read_teams) @folder.set_write_teams(write_teams) @folder.save flash[:notice] = t('msg.register_success') else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end target_user_id = (@login_user.admin?(User::AUTH_TEAM))?(nil):(@login_user.id) @teams = Team.get_for(target_user_id, true) render(:partial => 'ajax_auth_teams', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_teams', :layout => false) end"
647,"def edit Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse(date_s) end if params[:user_id].nil? @selected_user = @login_user else @selected_user = User.find(params[:user_id]) end @timecard = Timecard.get_for(@selected_user.id, date_s) if @selected_user == @login_user @schedules = Schedule.get_user_day(@login_user, @date) end if !params[:display].nil? and params[:display].split('_').first == 'group' @group_id = params[:display].split('_').last end end",True,Ruby,edit,timecards_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_auth_users Log.add_info(request, params.inspect) folder_id = params[:id] SqlHelper.validate_token([folder_id]) begin @folder = Folder.find(folder_id) rescue @folder = nil end @users = [] session[:folder_id] = folder_id if !@login_user.nil? and (@login_user.admin?(User::AUTH_FOLDER) or (!@folder.nil? and @folder.in_my_folder_of?(@login_user.id))) render(:partial => 'ajax_auth_users', :layout => false) else render(:partial => 'ajax_auth_disp', :layout => false) end end"
649,"def query Log.add_info(request, '') # Not to show passwords. unless @login_user.admin?(User::AUTH_ZEPTAIR) render(:text => 'ERROR:' + t('msg.need_to_be_admin')) return end target_user = nil SqlHelper.validate_token([params[:user_id], params[:zeptair_id], params[:group_id]]) unless params[:user_id].blank? target_user = User.find(params[:user_id]) end unless params[:zeptair_id].blank? zeptair_id = params[:zeptair_id] target_user = User.where(""zeptair_id=#{zeptair_id}"").first end if target_user.nil? if params[:group_id].blank? sql = 'select distinct Item.* from items Item, attachments Attachment' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << ' order by Item.user_id ASC' else group_ids = [params[:group_id]] if params[:recursive] == 'true' group_ids += Group.get_childs(params[:group_id], true, false) end groups_con = [] group_ids.each do |group_id| groups_con << SqlHelper.get_sql_like(['User.groups'], ""|#{@group_id}|"") end sql = 'select distinct Item.* from items Item, attachments Attachment, users User' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << "" and (Item.user_id=User.id and (#{groups_con.join(' or ')}))"" sql << ' order by Item.user_id ASC' end @post_items = Item.find_by_sql(sql) else @post_item = ZeptairPostHelper.get_item_for(target_user) end rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end",True,Ruby,query,zeptair_post_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def ajax_delete_items Log.add_info(request, params.inspect) unless params[:check_item].blank? is_admin = @login_user.admin?(User::AUTH_ITEM) count = 0 params[:check_item].each do |item_id, value| if value == '1' begin item = Item.find(item_id) next if !is_admin and item.user_id != @login_user.id item.destroy rescue => evar item = nil Log.add_error(request, evar) end count += 1 end end flash[:notice] = t('item.deleted', :count => count) end get_items end"
651,"def delete_attachment Log.add_info(request, '') # Not to show passwords. target_user = nil unless params[:user_id].blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == params[:user_id].to_s target_user = User.find(params[:user_id]) end end unless params[:zeptair_id].blank? target_user = User.where(""zeptair_id=#{params[:zeptair_id]}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if params[:attachment_id].blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(params[:attachment_id]) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end",True,Ruby,delete_attachment,zeptair_post_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_auth_teams Log.add_info(request, params.inspect) folder_id = params[:id] SqlHelper.validate_token([folder_id]) begin @folder = Folder.find(folder_id) rescue @folder = nil end target_user_id = (@login_user.admin?(User::AUTH_TEAM))?(nil):(@login_user.id) @teams = Team.get_for(target_user_id, true) session[:folder_id] = folder_id render(:partial => 'ajax_auth_teams', :layout => false) end"
654,"def self.get_next_revision(user_id, source_id) copied_items = Item.where(""user_id=#{user_id} and source_id=#{source_id}"").order('created_at DESC').to_a rev = 0 copied_items.each do |item| rev_ary = item.title.scan(/[#](\d\d\d)$/) next if rev_ary.nil? rev = rev_ary.first.to_a.first.to_i break end return '#' + sprintf('%03d', rev+1) end",True,Ruby,self.get_next_revision,items_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_disp_ctrl Log.add_info(request, params.inspect) folder_id = params[:id] SqlHelper.validate_token([folder_id]) if folder_id != '0' begin @folder = Folder.find(folder_id) rescue => evar @folder = nil end end session[:folder_id] = folder_id render(:partial => 'ajax_disp_ctrl', :layout => false) end"
656,"def self.validate_token(tokens, extra_chars=nil) extra_chars = Regexp.escape((extra_chars || []).join()) regexp = Regexp.new(""^[ ]*[a-zA-Z0-9_.#{extra_chars}]+[ ]*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end",True,Ruby,self.validate_token,sql_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_auth_groups Log.add_info(request, params.inspect) return unless request.post? @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_groups = [] write_groups = [] groups_auth = params[:groups_auth] unless groups_auth.nil? groups_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_groups << user_id end if auths.include?('w') write_groups << user_id end end end @folder.set_read_groups(read_groups) @folder.set_write_groups(write_groups) @folder.save flash[:notice] = t('msg.register_success') else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end @groups = Group.where(nil).to_a render(:partial => 'ajax_auth_groups', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_groups', :layout => false) end"
670,"def self.get_default_for(user_id, xtype=nil) SqlHelper.validate_token([user_id, xtype]) con = [] con << ""(user_id=#{user_id})"" con << '(is_default=1)' con << ""(xtype='#{xtype}')"" unless xtype.blank? where = '' unless con.nil? or con.empty? where = 'where ' + con.join(' and ') end account_ary = MailAccount.find_by_sql('select * from mail_accounts ' + where + ' order by xorder ASC, title ASC') if account_ary.nil? or account_ary.empty? return nil else return account_ary.first end end",True,Ruby,self.get_default_for,mail_account.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def rename Log.add_info(request, params.inspect) return unless request.post? @group = Group.find(params[:id]) unless params[:thetisBoxEdit].blank? @group.rename(params[:thetisBoxEdit]) end render(:partial => 'ajax_group_name', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_group_name', :layout => false) end"
674,"def self.update_for(user_id, fiscal_year, num) if num <= 0 PaidHoliday.destroy_all(['user_id=? and year=?', user_id, fiscal_year]) return end paid_holiday = PaidHoliday.get_for(user_id, fiscal_year) if paid_holiday.nil? paid_holiday = PaidHoliday.new paid_holiday.user_id = user_id paid_holiday.year = fiscal_year paid_holiday.num = num paid_holiday.save! else paid_holiday.update_attribute(:num, num) end end",True,Ruby,self.update_for,paid_holiday.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_path Log.add_info(request, params.inspect) if params[:thetisBoxSelKeeper].blank? @group_path = '/' + t('paren.unknown') render(:partial => 'ajax_group_path', :layout => false) return end @selected_id = params[:thetisBoxSelKeeper].split(':').last SqlHelper.validate_token([@selected_id]) @group_path = Group.get_path(@selected_id) render(:partial => 'ajax_group_path', :layout => false) end"
685,"def remove_application(users) return if users.nil? or users.empty? array = [""(xtype='#{Comment::XTYPE_APPLY}')""] array << ""(item_id=#{self.item_id})"" user_con_a = [] users.each do |user_id| user_con_a << ""(user_id=#{user_id})"" end array << '(' + user_con_a.join(' or ') + ')' Comment.destroy_all(array.join(' and ')) end",True,Ruby,remove_application,team.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def create Log.add_info(request, params.inspect) return unless request.post? if params[:thetisBoxEdit].blank? @group = nil else @group = Group.new @group.name = params[:thetisBoxEdit] @group.parent_id = params[:selectedGroupId] @group.save! @group.create_group_folder end render(:partial => 'ajax_group_entry', :layout => false) end"
691,"def self.get_for(user_id, date) begin con = ""(user_id=#{user_id}) and (date='#{date}')"" return Timecard.where(con).first rescue end return nil end",True,Ruby,self.get_for,timecard.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_description Log.add_info(request, params.inspect) return unless request.post? if params[:id].blank? @item = Item.new_info(0) @item.attributes = params.require(:item).permit(Item::PERMIT_BASE) @item.user_id = @login_user.id @item.title = t('paren.no_title') @item.save else @item = Item.find(params[:id]) @item.update_attributes(params.require(:item).permit(Item::PERMIT_BASE)) end render(:partial => 'ajax_item_description', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_item_description', :layout => false) end"
692,"def self.applied_paid_hlds(user_id, start_date, end_date) SqlHelper.validate_token([user_id, start_date, end_date]) sql = ""SELECT COUNT(*) FROM timecards WHERE user_id = #{user_id} AND date >= '#{start_date}' AND date <= '#{end_date}'"" sum = 0.0 self.workcodes.each do |key, params| paidhld_rate = params[WKCODE_PARAM_PAIDHLD] if paidhld_rate > 0.0 num = Timecard.count_by_sql(sql + "" AND workcode='#{key}'"") sum += num * paidhld_rate end end return sum end",True,Ruby,self.applied_paid_hlds,timecard.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_workflow Log.add_info(request, params.inspect) return unless request.post? @item = Item.find(params[:id]) orders_hash = params.dup orders_hash.reject! { |key, value| key.index(/order-/) != 0 } orders_hash.sort_by { |key, value| key.split('-').last.to_i } orders = [] orders_hash.each do |key, value| user_ids = value.split(',') SqlHelper.validate_token([user_ids]) orders << '|' + user_ids.join('|') + '|' end @item.workflow.update_attribute(:users, orders.join(',')) render(:partial => 'ajax_item_workflow', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_item_workflow', :layout => false) end"
693,"def self.find_term(user_id, start_date, end_date) con = ""(user_id=#{user_id}) and (date >= '#{start_date}') and (date <= '#{end_date}')"" ary = Timecard.where(con).order('date ASC').to_a timecards_h = Hash.new unless ary.nil? ary.each do |timecard| timecards_h[timecard.date.strftime(Schedule::SYS_DATE_FORM)] = timecard end end return timecards_h end",True,Ruby,self.find_term,timecard.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def bbs Log.add_info(request, params.inspect) unless params[:select_sorting].nil? sort_a = params[:select_sorting].split(' ') params[:sort_col] = sort_a.first params[:sort_type] = sort_a.last end list render(:action => 'bbs') end"
698,"def self.get_my_folder(user_id) return Folder.where(""(owner_id=#{user_id}) and (xtype='#{Folder::XTYPE_USER}')"").first end",True,Ruby,self.get_my_folder,user.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 09:10:26+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_attachment Log.add_info(request, params.inspect) attach = Attachment.find(params[:id]) if attach.nil? redirect_to(THETIS_RELATIVE_URL_ROOT + '/404.html') return end parent_item = (attach.item || ((attach.comment.nil?) ? nil : attach.comment.item)) if parent_item.nil? or !parent_item.check_user_auth(@login_user, 'r', true) Log.add_check(request, '[Item.check_user_auth]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end attach_name = attach.name agent = request.env['HTTP_USER_AGENT'] unless agent.nil? ie_ver = nil agent.scan(/\sMSIE\s?(\d+)[.](\d+)/){|m| ie_ver = m[0].to_i + (0.1 * m[1].to_i) } attach_name = CGI::escape(attach_name) unless ie_ver.nil? end begin attach_location = attach.location rescue attach_location = Attachment::LOCATION_DB # for lower versions end if attach_location == Attachment::LOCATION_DIR filepath = AttachmentsHelper.get_path(attach) send_file(filepath, :filename => attach_name, :stream => true, :disposition => 'attachment') else send_data(attach.content, :type => (attach.content_type || 'application/octet-stream')+';charset=UTF-8', :disposition => 'attachment;filename=""'+attach_name+'""') end end"
701,def gate_process HistoryHelper.keep_last(request) @login_user = User.find_by_id(session[:login_user_id]) begin if @login_user.nil? \ or @login_user.time_zone.nil? or @login_user.time_zone.empty? unless THETIS_USER_TIMEZONE_DEFAULT.nil? or THETIS_USER_TIMEZONE_DEFAULT.empty? Time.zone = THETIS_USER_TIMEZONE_DEFAULT end else Time.zone = @login_user.time_zone end rescue => evar logger.fatal(evar.to_s) end end,True,Ruby,gate_process,application_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_attachments_order Log.add_info(request, params.inspect) return unless request.post? order_ary = params[:attachments_order] item = Item.find(params[:id]) item.attachments_without_content.each do |attach| class << attach def record_timestamps; false; end end attach.update_attribute(:xorder, order_ary.index(attach.id.to_s) + 1) class << attach remove_method(:record_timestamps) end end render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end"
702,"def paginate_by_sql(model, sql, per_page, options={}) if options[:count] if options[:count].is_a?(Integer) total = options[:count] else total = model.count_by_sql(options[:count]) end else total = model.count_by_sql_wrapping_select_query(sql) end object_pages = model.paginate_by_sql(sql, {:page => params['page'], :per_page => per_page}) #objects = model.find_by_sql_with_limit(sql, object_pages.current.to_sql[1], per_page) return [object_pages, object_pages, total] end",True,Ruby,paginate_by_sql,application_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def team_organize Log.add_info(request, params.inspect) return unless request.post? team_id = params[:team_id] unless team_id.blank? begin @team = Team.find(team_id) rescue @team = nil end if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end users = @team.get_users_a end team_members = params[:team_members] SqlHelper.validate_token([team_members]) created = false modified = false if team_members.nil? or team_members.empty? unless team_id.blank? # @team must not be nil. modified = @team.clear_users @team.save if modified end else if team_members != users if team_id.blank? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users(team_members) @team.save @team.remove_application(team_members) modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end"
704,"def self.find_by_sql_with_limit(sql, offset, limit) sql = sanitize_sql(sql) add_limit!(sql, {:limit => limit, :offset => offset}) find_by_sql(sql) end",True,Ruby,self.find_by_sql_with_limit,application_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_attachment Log.add_info(request, params.inspect) return unless request.post? created = false if params[:id].blank? @item = Item.new_info(0) @item.attributes = params.require(:item).permit(Item::PERMIT_BASE) @item.user_id = @login_user.id @item.title = t('paren.no_title') [:attachment0, :attachment1].each do |attach| next if params[attach].nil? or params[attach][:file].nil? or params[attach][:file].size == 0 @item.save! created = true break end else @item = Item.find(params[:id]) end modified = false item_attachments = @item.attachments_without_content [:attachment0, :attachment1].each do |attach| next if params[attach].nil? or params[attach][:file].nil? or params[attach][:file].size == 0 attachment = Attachment.create(params[attach], @item, item_attachments.length) modified = true item_attachments << attachment end if modified and !created @item.update_attribute(:updated_at, Time.now) end render(:partial => 'ajax_item_attachment', :layout => false) rescue => evar Log.add_error(request, evar) @attachment = Attachment.new @attachment.errors.add_to_base(evar.to_s[0, 256]) render(:partial => 'ajax_item_attachment', :layout => false) end"
707,"def show if params[:action] == 'show' Log.add_info(request, params.inspect) end @mail_filter = MailFilter.find_by_id(params[:id]) if @mail_filter.nil? render(:text => 'ERROR:' + t('msg.already_deleted', :name => MailFilter.model_name.human)) return else if @mail_filter.mail_account.user_id != @login_user.id render(:text => 'ERROR:' + t('msg.need_to_be_owner')) return end end render(:action => 'show', :layout => (!request.xhr?)) end",True,Ruby,show,mail_filters_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_images_order Log.add_info(request, params.inspect) return unless request.post? order_ary = params[:images_order] item = Item.find(params[:id]) item.images_without_content.each do |img| class << img def record_timestamps; false; end end img.update_attribute(:xorder, order_ary.index(img.id.to_s) + 1) class << img remove_method(:record_timestamps) end end render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end"
708,"def update_order Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] order_ary = params[:mail_filters_order] @mail_account = MailAccount.find_by_id(mail_account_id) if @mail_account.user_id != @login_user.id render(:text => 'ERROR:' + t('msg.need_to_be_owner')) return end filters = MailFilter.get_for(mail_account_id) # filters must be ordered by xorder ASC. filters.sort! { |filter_a, filter_b| id_a = filter_a.id.to_s id_b = filter_b.id.to_s idx_a = order_ary.index(id_a) idx_b = order_ary.index(id_b) if idx_a.nil? or idx_b.nil? idx_a = filters.index(id_a) idx_b = filters.index(id_b) end idx_a - idx_b } idx = 1 filters.each do |filter| next if filter.mail_account_id != mail_account_id.to_i filter.update_attribute(:xorder, idx) idx += 1 end render(:text => '') end",True,Ruby,update_order,mail_filters_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def new @item = Item.new if params[:folder_id].blank? my_folder = @login_user.get_my_folder if my_folder.nil? @item.folder_id = 0 else @item.folder_id = my_folder.id end else @item.folder_id = params[:folder_id].to_i end @item.xtype= Item::XTYPE_INFO @item.layout = 'C' render(:action => 'edit') end
711,"def do_execute Log.add_info(request, params.inspect) mail_account = MailAccount.find_by_id(params[:mail_account_id]) mail_folder = MailFolder.find_by_id(params[:mail_folder_id]) if mail_account.user_id != @login_user.id \ or mail_folder.user_id != @login_user.id render(:text => t('msg.need_to_be_owner')) return end mail_filters = MailFilter.get_for(mail_account.id, true, MailFilter::TRIGGER_MANUAL) emails = MailFolder.get_mails(mail_folder.id, mail_folder.user_id) filter_next = true emails.each do |email| mail_filters.each do |filter| filter_next = filter.execute(email) break unless filter_next end break unless filter_next end render(:text => '') end",True,Ruby,do_execute,mail_filters_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def wf_issue Log.add_info(request, params.inspect) return unless request.post? begin @item = Item.find(params[:id]) @workflow = @item.workflow rescue => evar Log.add_error(request, evar) end attrs = ActionController::Parameters.new({status: Workflow::STATUS_ACTIVE, issued_at: Time.now}) @workflow.update_attributes(attrs.permit(Workflow::PERMIT_BASE)) @orders = @workflow.get_orders render(:partial => 'ajax_workflow', :layout => false) end"
712,"def get_order Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] @mail_account = MailAccount.find_by_id(mail_account_id) if @mail_account.user_id != @login_user.id flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') return end @mail_filters = MailFilter.get_for(mail_account_id) render(:partial => 'ajax_order', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_order', :layout => false) end",True,Ruby,get_order,mail_filters_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def set_image Log.add_info(request, params.inspect) return unless request.post? created = false if params[:id].blank? @item = Item.new_info(0) @item.attributes = params.require(:item).permit(Item::PERMIT_BASE) @item.user_id = @login_user.id @item.title = t('paren.no_title') [:image0, :image1].each do |img| next if params[img].nil? or params[img][:file].size == 0 @item.save! created = true break end else @item = Item.find(params[:id]) end modified = false item_images = @item.images_without_content [:image0, :image1].each do |img| next if params[img].nil? or params[img][:file].nil? or params[img][:file].size == 0 image = Image.new image.item_id = @item.id image.file = params[img][:file] image.title = params[img][:title] image.memo = params[img][:memo] image.xorder = item_images.length image.save! modified = true item_images << image end if modified and !created @item.update_attribute(:updated_at, Time.now) end render(:partial => 'ajax_item_image', :layout => false) rescue => evar Log.add_error(request, evar) @image = Image.new @image.errors.add_to_base(evar.to_s[0, 256]) render(:partial => 'ajax_item_image', :layout => false) end"
715,"def update_folders_order Log.add_info(request, params.inspect) order_ary = params[:folders_order] folders = MailFolder.get_childs(params[:id], false, false) # folders must be ordered by xorder ASC. folders.sort! { |id_a, id_b| idx_a = order_ary.index(id_a) idx_b = order_ary.index(id_b) if idx_a.nil? or idx_b.nil? idx_a = folders.index(id_a) idx_b = folders.index(id_b) end idx_a - idx_b } idx = 1 folders.each do |folder_id| begin folder = MailFolder.find(folder_id) next if folder.user_id != @login_user.id folder.update_attribute(:xorder, idx) if folder.xtype == MailFolder::XTYPE_ACCOUNT_ROOT mail_account = MailAccount.find_by_id(folder.mail_account_id) unless mail_account.nil? mail_account.update_attribute(:xorder, idx) end end idx += 1 rescue => evar Log.add_error(request, evar) end end render(:text => '') end",True,Ruby,update_folders_order,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def search Log.add_info(request, params.inspect) unless params[:select_sorting].blank? sort_a = params[:select_sorting].split(' ') params[:sort_col] = sort_a.first params[:sort_type] = sort_a.last end list if params[:keyword].blank? if params[:from_action].nil? or params[:from_action] == 'bbs' render(:action => 'bbs') else render(:action => 'list') end end end"
717,"def ajax_delete_mails Log.add_info(request, params.inspect) folder_id = params[:id] mail_account_id = params[:mail_account_id] unless params[:check_mail].blank? mail_folder = MailFolder.find(folder_id) trash_folder = MailFolder.get_for(@login_user, mail_account_id, MailFolder::XTYPE_TRASH) count = 0 params[:check_mail].each do |email_id, value| next if value != '1' email = Email.find_by_id(email_id) next if email.nil? or (email.user_id != @login_user.id) if trash_folder.nil? \ or folder_id == trash_folder.id.to_s \ or mail_folder.get_parents(false).include?(trash_folder.id.to_s) email.destroy flash[:notice] ||= t('msg.delete_success') else begin email.update_attribute(:mail_folder_id, trash_folder.id) flash[:notice] ||= t('msg.moved_to_trash') rescue => evar Log.add_error(request, evar) email.destroy flash[:notice] ||= t('msg.delete_success') end end count += 1 end end get_mails end",True,Ruby,ajax_delete_mails,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_owner return if params[:id].blank? or @login_user.nil? begin owner_id = Location.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_LOCATION) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
718,"def get_mail_attachment Log.add_info(request, params.inspect) attached_id = params[:id].to_i mail_attach = MailAttachment.find_by_id(attached_id) if mail_attach.nil? redirect_to(THETIS_RELATIVE_URL_ROOT + '/404.html') return end email = Email.find_by_id(mail_attach.email_id) if email.nil? or email.user_id != @login_user.id render(:text => '') return end mail_attach_name = mail_attach.name agent = request.env['HTTP_USER_AGENT'] unless agent.nil? ie_ver = nil agent.scan(/\sMSIE\s?(\d+)[.](\d+)/){|m| ie_ver = m[0].to_i + (0.1 * m[1].to_i) } mail_attach_name = CGI::escape(mail_attach_name) unless ie_ver.nil? end filepath = mail_attach.get_path if FileTest.exist?(filepath) send_file(filepath, :filename => mail_attach_name, :stream => true, :disposition => 'attachment') else send_data('', :type => 'application/octet-stream;', :disposition => 'attachment;filename=""'+mail_attach_name+'""') end end",True,Ruby,get_mail_attachment,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def on_moved Log.add_info(request, params.inspect) return unless request.post? location_id = params[:id] SqlHelper.validate_token([location_id]) if location_id.blank? location = Location.get_for(@login_user) if location.nil? location = Location.new location.user_id = @login_user.id end else begin location = Location.find(location_id) rescue location = nil end end unless location.nil? group_id = params[:group_id] group_id = nil if group_id.empty? SqlHelper.validate_token([group_id]) attrs = ActionController::Parameters.new({group_id: group_id, x: params[:x], y: params[:y]}) location.update_attributes(attrs.permit(Location::PERMIT_BASE)) end render(:text => (location.nil?)?'':location.id.to_s) end"
722,"def ajax_move_mails Log.add_info(request, params.inspect) folder_id = params[:thetisBoxSelKeeper].split(':').last mail_folder = MailFolder.find_by_id(folder_id) if folder_id == '0' \ or mail_folder.nil? \ or mail_folder.user_id != @login_user.id flash[:notice] = 'ERROR:' + t('msg.cannot_save_in_folder') get_mails return end unless params[:check_mail].blank? count = 0 params[:check_mail].each do |email_id, value| if value == '1' begin email = Email.find(email_id) next if email.user_id != @login_user.id email.update_attribute(:mail_folder_id, folder_id) rescue => evar Log.add_error(request, evar) end count += 1 end end flash[:notice] = t('mail.moved', :count => count) end get_mails end",True,Ruby,ajax_move_mails,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def login Log.add_info(request, '') # Not to show passwords. user = User.authenticate(params[:user]) if user.nil? flash[:notice] = '<span class=\'font_msg_bold\'>'+t('user.u_name')+'</span>'+t('msg.or')+'<span class=\'font_msg_bold\'>'+t('password.name')+'</span>'+t('msg.is_invalid') if params[:fwd_controller].blank? redirect_to(:controller => 'login', :action => 'index') else url_h = {:controller => 'login', :action => 'index', :fwd_controller => params[:fwd_controller], :fwd_action => params[:fwd_action]} unless params[:fwd_params].nil? params[:fwd_params].each do |key, val| url_h[""fwd_params[#{key}]""] = val end end redirect_to(url_h) end else @login_user = LoginHelper.on_login(user, session) if params[:fwd_controller].blank? prms = ApplicationHelper.get_fwd_params(params) prms.delete('user') prms[:controller] = 'desktop' prms[:action] = 'show' redirect_to(prms) else url_h = {:controller => params[:fwd_controller], :action => params[:fwd_action]} url_h = url_h.update(params[:fwd_params]) unless params[:fwd_params].nil? redirect_to(url_h) end end end"
723,"def get_mail_attachments Log.add_info(request, params.inspect) email_id = params[:id] email = Email.find_by_id(email_id) if email.nil? or email.user_id != @login_user.id render(:text => '') return end download_name = ""mail_attachments#{email.id}.zip"" zip_file = email.zip_attachments(params[:enc]) if zip_file.nil? send_data('', :type => 'application/octet-stream;', :disposition => 'attachment;filename=""'+download_name+'""') else filepath = zip_file.path send_file(filepath, :filename => download_name, :stream => true, :disposition => 'attachment') end end",True,Ruby,get_mail_attachments,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_owner return if params[:id].blank? or @login_user.nil? mail_account = MailAccount.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and mail_account.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
725,"def self.execute_action_move(mail_filter, email, val) mail_folder_id = val mail_folder = MailFolder.find_by_id(mail_folder_id) if !mail_folder.nil? and (mail_folder.user_id == email.user_id) email.update_attribute(:mail_folder_id, mail_folder_id) end return true end",True,Ruby,self.execute_action_move,mail_filters_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_owner return if (params[:id].blank? or @login_user.nil?) mail_filter = MailFilter.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and mail_filter.mail_account.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
727,"def check_import(mode, address_names) #, address_emails err_msgs = [] # Existing Addresss unless self.id.nil? or self.id == 0 or self.id == '' if mode == 'add' err_msgs << I18n.t('address.import.dont_specify_id') else begin org_address = Address.find(self.id) rescue end if org_address.nil? err_msgs << I18n.t('address.import.not_found') end end end # Requierd if self.name.nil? or self.name.empty? err_msgs << Address.human_attribute_name('name') + I18n.t('msg.is_required') end # Groups unless self.groups.nil? or self.groups.empty? if (/^|([0-9]+|)+$/ =~ self.groups) == 0 self.get_groups_a.each do |group_id| group = Group.find_by_id(group_id) if group.nil? err_msgs << I18n.t('address.import.not_valid_groups') + ': '+group_id.to_s break end end else err_msgs << I18n.t('address.import.invalid_groups_format') end end # Teams unless self.teams.nil? or self.teams.empty? if (/^|([0-9]+|)+$/ =~ self.teams) == 0 self.get_teams_a.each do |team_id| team = Team.find_by_id(team_id) if team.nil? err_msgs << I18n.t('address.import.not_valid_teams') + ': '+team_id.to_s break end end else err_msgs << I18n.t('address.import.invalid_teams_format') end end return err_msgs end",True,Ruby,check_import,address.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_mails if params[:action] == 'get_mails' Log.add_info(request, params.inspect) end if !params[:pop].nil? and params[:pop] == 'true' mail_account_id = params[:mail_account_id] SqlHelper.validate_token([mail_account_id]) begin new_arrivals_h = {} if mail_account_id.blank? mail_accounts = MailAccount.find_all(""user_id=#{@login_user.id}"") mail_accounts.each do |mail_account| emails = Email.do_pop(mail_account) unless emails.empty? new_arrivals_h[mail_account.id] ||= [] new_arrivals_h[mail_account.id] |= emails end end else mail_account = MailAccount.find(mail_account_id) emails = Email.do_pop(mail_account) unless emails.empty? new_arrivals_h[mail_account.id] ||= [] new_arrivals_h[mail_account.id] |= emails end end unless new_arrivals_h.empty? flash[:notice] = t('mail.received', :count => new_arrivals_h.values.flatten.length) # FEATURE_MAIL_FILTERS >>> new_arrivals_h.each do |mail_account_id, emails| mail_filters = MailFilter.get_for(mail_account_id, true, MailFilter::TRIGGER_CHECKING) filter_next = true emails.each do |email| mail_filters.each do |filter| filter_next = filter.execute(email) break unless filter_next end break unless filter_next end end # FEATURE_MAIL_FILTERS <<< end rescue => evar if evar.to_s.starts_with?('ERROR:') flash[:notice] = evar.to_s else flash[:notice] = 'ERROR:' + t('mail.receive_error') + '<br/>' + evar.to_s end Log.add_error(nil, evar) end end @folder_id = params[:id] SqlHelper.validate_token([@folder_id]) if @folder_id == TreeElement::ROOT_ID.to_s @emails = nil else # FEATURE_PAGING_IN_TREE >>> @sort_col = (params[:sort_col] || 'sent_at') @sort_type = (params[:sort_type] || 'DESC') SqlHelper.validate_token([@sort_col, @sort_type]) sql = EmailsHelper.get_list_sql(@login_user, params[:keyword], [@folder_id], @sort_col, @sort_type, 0, nil) @email_pages, @emails, @total_num = paginate_by_sql(Email, sql, 10) # FEATURE_PAGING_IN_TREE <<< end session[:mailfolder_id] = @folder_id render(:partial => 'ajax_folder_mails', :layout => false) end"
728,"def self.parse_csv_row(row, book, idxs, user) imp_id = (idxs[0].nil? or row[idxs[0]].nil?)?(nil):(row[idxs[0]].strip) unless imp_id.nil? or imp_id.empty? org_address = Address.find_by_id(imp_id) end if org_address.nil? address = Address.new else address = org_address end address.id = imp_id attr_names = [ :name, :name_ruby, :nickname, :screenname, :email1, :email2, :email3, :postalcode, :address, :tel1_note, :tel1, :tel2_note, :tel2, :tel3_note, :tel3, :fax, :url, :organization, :title, :memo, :xorder, :groups, :teams ] attr_names.each_with_index do |attr_name, idx| row_idx = idxs[idx+1] break if row_idx.nil? val = (row[row_idx].nil?)?(nil):(row[row_idx].strip) address.send(attr_name.to_s + '=', val) end if (address.groups == Address::EXP_IMP_FOR_ALL) \ or (book == Address::BOOK_COMMON and address.groups.blank? and address.teams.blank?) address.groups = nil address.teams = nil address.owner_id = 0 elsif !address.groups.blank? or !address.teams.blank? address.owner_id = 0 else address.owner_id = user.id end return address end",True,Ruby,self.parse_csv_row,address.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def create Log.add_info(request, params.inspect) return unless request.post? parent_id = params[:selectedFolderId] if params[:thetisBoxEdit].blank? @mail_folder = nil else @mail_folder = MailFolder.new @mail_folder.name = params[:thetisBoxEdit] @mail_folder.parent_id = parent_id @mail_folder.user_id = @login_user.id @mail_folder.xtype = nil @mail_folder.save! end render(:partial => 'ajax_folder_entry', :layout => false) end"
731,"def attachments_without_content return [] if self.id.nil? sql = 'select id, title, memo, name, size, content_type, comment_id, xorder, location from attachments' sql << ' where comment_id=' + self.id.to_s sql << ' order by xorder ASC' begin attachments = Attachment.find_by_sql(sql) rescue => evar Log.add_error(nil, evar) end attachments = [] if attachments.nil? return attachments end",True,Ruby,attachments_without_content,comment.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_mail_owner return if params[:id].blank? or @login_user.nil? begin owner_id = Email.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_MAIL) and owner_id != @login_user.id Log.add_check(request, '[check_mail_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
734,def is_a_copy?(folder_obj_cache=nil) return false if self.source_id.nil? # Exclude those created from system templates. src_item = Item.find_by_id(self.source_id) if src_item.nil? return true else return !src_item.in_system_folder?(folder_obj_cache) end end,True,Ruby,is_a_copy?,item.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def empty Log.add_info(request, params.inspect) return unless request.post? @folder_id = params[:id] mail_account_id = params[:mail_account_id] SqlHelper.validate_token([@folder_id, mail_account_id]) trash_folder = MailFolder.get_for(@login_user, mail_account_id, MailFolder::XTYPE_TRASH) mail_folder = MailFolder.find(@folder_id) emails = (MailFolder.get_mails(mail_folder.id, @login_user) || []) if mail_folder.id == trash_folder.id \ or mail_folder.get_parents(false).include?(trash_folder.id.to_s) emails.each do |email| email.destroy end flash[:notice] = t('msg.delete_success') else emails.each do |email| email.update_attribute(:mail_folder_id, trash_folder.id) end flash[:notice] = t('msg.moved_to_trash') end get_mails end"
735,"def self.get_for_user(user) return [] if user.nil? toys = Toy.where(""user_id=#{user.id}"").to_a deleted_ary = [] return [] if toys.nil? toys.each do |toy| case toy.xtype when Toy::XTYPE_ITEM item = Item.find_by_id(toy.target_id) if item.nil? deleted_ary << toy next end Toy.copy(toy, item) when Toy::XTYPE_COMMENT comment = Comment.find_by_id(toy.target_id) if comment.nil? deleted_ary << toy next end Toy.copy(toy, comment) when Toy::XTYPE_WORKFLOW workflow = Workflow.find_by_id(toy.target_id) if workflow.nil? deleted_ary << toy next end Toy.copy(toy, workflow) when Toy::XTYPE_SCHEDULE schedule = Schedule.find_by_id(toy.target_id) if schedule.nil? deleted_ary << toy next end Toy.copy(toy, schedule) when Toy::XTYPE_FOLDER folder = Folder.find_by_id(toy.target_id) if folder.nil? deleted_ary << toy next end Toy.copy(toy, folder) end end",True,Ruby,self.get_for_user,toy.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_mail_content Log.add_info(request, params.inspect) email_id = params[:id] begin @email = Email.find(email_id) render(:partial => 'ajax_mail_content', :layout => false) rescue => evar Log.add_error(nil, evar) render(:text => '') end end"
737,"def check_import(mode, user_names) #, user_emails err_msgs = [] # Existing Users unless self.id.nil? or self.id == 0 or self.id == '' if mode == 'add' err_msgs << I18n.t('user.import.dont_specify_id') else begin org_user = User.find(self.id) rescue end if org_user.nil? err_msgs << I18n.t('user.import.not_found') end end end # Required if self.name.nil? or self.name.empty? err_msgs << User.human_attribute_name('name') + I18n.t('msg.is_required') end if self.pass_md5.nil? or self.pass_md5.empty? if mode == 'update' and !org_user.nil? self.pass_md5 = org_user.pass_md5 end end if self.pass_md5.nil? or self.pass_md5.empty? err_msgs << I18n.t('password.name') + I18n.t('msg.is_required') end if self.email.nil? or self.email.empty? err_msgs << User.human_attribute_name('email') + I18n.t('msg.is_required') end # Duplicated if user_names.include?(self.name) err_msgs << User.human_attribute_name('name') + I18n.t('msg.is_duplicated') elsif !self.name.nil? and !self.name.empty? user_names << self.name end # Comment out considering about administrative users. # if user_emails.include?(self.email) # err_msgs << User.human_attribute_name('email') + I18n.t('msg.is_duplicated') # elsif !self.email.nil? and !self.email.empty? # user_emails << self.email # end # Characters if (/^[01-9a-zA-Z]+$/ =~ self.name).nil? err_msgs << User.human_attribute_name('name') + I18n.t('activerecord.errors.models.user.attributes.name.invalid', :attribute => User.human_attribute_name('name')) end # Authority unless self.auth.nil? or self.auth.empty? or self.auth == User::AUTH_ALL if (/^|([a-z]+|)+$/ =~ self.auth) == 0 keys = User.get_auth_names.keys() keys.delete(User::AUTH_ALL) self.get_auth_a.each do |auth| unless keys.include?(auth) err_msgs << I18n.t('user.import.not_valid_auth') + ': '+auth.to_s break end end else err_msgs << I18n.t('user.import.invalid_auth_format') end end # Groups unless self.groups.nil? or self.groups.empty? if (/^|([0-9]+|)+$/ =~ self.groups) == 0 self.get_groups_a.each do |group_id| group = Group.find_by_id(group_id) if group.nil? err_msgs << I18n.t('user.import.not_valid_groups') + ': '+group_id.to_s break end end else err_msgs << I18n.t('user.import.invalid_groups_format') end end return err_msgs end",True,Ruby,check_import,user.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:28:35+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_folders_order Log.add_info(request, params.inspect) @folder_id = params[:id] SqlHelper.validate_token([@folder_id]) if @folder_id == '0' @folders = MailFolder.get_account_roots_for(@login_user) else mail_folder = MailFolder.find(@folder_id) if mail_folder.user_id == @login_user.id @folders = MailFolder.get_childs(@folder_id, false, true) end end render(:partial => 'ajax_folders_order', :layout => false) end"
740,def gate_process HistoryHelper.keep_last(request) @login_user = User.find(session[:login_user_id]) begin if @login_user.nil? \ or @login_user.time_zone.nil? or @login_user.time_zone.empty? unless THETIS_USER_TIMEZONE_DEFAULT.nil? or THETIS_USER_TIMEZONE_DEFAULT.empty? Time.zone = THETIS_USER_TIMEZONE_DEFAULT end else Time.zone = @login_user.time_zone end rescue => evar logger.fatal(evar.to_s) end end,True,Ruby,gate_process,application_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-07 10:34:01+09:00,"Some trivial bug-fixes.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def rename Log.add_info(request, params.inspect) return unless request.post? @mail_folder = MailFolder.find(params[:id]) unless params[:thetisBoxEdit].blank? @mail_folder.name = params[:thetisBoxEdit] @mail_folder.save end render(:partial => 'ajax_folder_name', :layout => false) end"
742,"def check_owner return if (params[:id].nil? or params[:id].empty? or @login_user.nil?) address = Address.find(params[:id]) if !@login_user.admin?(User::AUTH_ADDRESSBOOK) and address.owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,addressbook_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def edit Log.add_info(request, params.inspect) @group_id = params[:group_id] official_title_id = params[:id] SqlHelper.validate_token([@group_id, official_title_id]) unless official_title_id.blank? @official_title = OfficialTitle.find(official_title_id) end render(:partial => 'ajax_official_title_form', :layout => (!request.xhr?)) end"
753,"def update_by_ajax Log.add_info(request, params.inspect) cat_h = {:desktop => User::AUTH_DESKTOP, :user => User::AUTH_USER, :log => User::AUTH_LOG} yaml = ApplicationHelper.get_config_yaml cat_h.keys.each do |cat| next if params[cat].nil? or params[cat].empty? unless @login_user.admin?(cat_h[cat]) render(:text => t('msg.need_to_be_admin')) return end yaml[cat] ||= {} params[cat].each do |key, val| yaml[cat][key] = val end end ApplicationHelper.save_config_yaml(yaml) render(:text => '') end",True,Ruby,update_by_ajax,config_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def show Log.add_info(request, params.inspect) @group_id = params[:group_id] official_title_id = params[:id] SqlHelper.validate_token([@group_id, official_title_id]) unless official_title_id.blank? @official_title = OfficialTitle.find(official_title_id) end render(:layout => (!request.xhr?)) end"
760,"def update_config Log.add_info(request, params.inspect) @yaml = ApplicationHelper.get_config_yaml unless params[:desktop].nil? or params[:desktop].empty? @yaml[:desktop] = Hash.new if @yaml[:desktop].nil? params[:desktop].each do |key, val| @yaml[:desktop][key] = val end ApplicationHelper.save_config_yaml(@yaml) end flash[:notice] = t('msg.update_success') render(:partial => 'ajax_user_before_login', :layout => false) end",True,Ruby,update_config,desktop_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def destroy Log.add_info(request, params.inspect) return unless request.post? begin OfficialTitle.destroy(params[:id]) rescue => evar Log.add_error(nil, evar) end @group_id = params[:group_id] SqlHelper.validate_token([@group_id]) if @group_id.blank? @group_id = '0' # '0' for ROOT end render(:partial => 'groups/ajax_group_official_titles', :layout => false) end"
767,"def update Log.add_info(request, params.inspect) @equipment = Equipment.find(params[:id]) if (params[:groups].nil? or params[:groups].empty?) params[:equipment][:groups] = nil else params[:equipment][:groups] = '|' + params[:groups].join('|') + '|' end if (params[:teams].nil? or params[:teams].empty?) params[:equipment][:teams] = nil else params[:equipment][:teams] = '|' + params[:teams].join('|') + '|' end if @equipment.update_attributes(params.require(:equipment).permit(Equipment::PERMIT_BASE)) flash[:notice] = t('msg.update_success') list render(:action => 'list') else render(:controller => 'equipment', :action => 'edit', :id => params[:id]) end end",True,Ruby,update,equipment_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def delete_statistics_group Log.add_info(request, params.inspect) return unless request.post? group_id = params[:group_id] SqlHelper.validate_token([group_id]) if group_id.blank? @group_ids = Research.get_statistics_groups render(:partial => 'ajax_statistics_groups', :layout => false) return end @group_ids = Research.delete_statistics_group(group_id) render(:partial => 'ajax_statistics_groups', :layout => false) end"
769,"def schedule_all Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end if @login_user.nil? or params[:display].nil? or params[:display] == 'all' params[:display] = 'all' con = EquipmentHelper.get_scope_condition_for(@login_user) else display_type = params[:display].split('_').first display_id = params[:display].split('_').last case display_type when 'group' if @login_user.get_groups_a(true).include?(display_id) con = SqlHelper.get_sql_like([:groups], ""|#{display_id}|"") end when 'team' if @login_user.get_teams_a.include?(display_id) con = SqlHelper.get_sql_like([:teams], ""|#{display_id}|"") end end end",True,Ruby,schedule_all,equipment_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_q_ctrl Log.add_info(request, params.inspect) return unless request.post? item_id = params[:item_id] q_code = params[:q_code] q_param = params[:q_param] cap = params[:caption] yaml = Research.get_config_yaml type = q_param.split(':').first vals = q_param[type.length+1 .. -1] yaml[q_code] = {:item_id => item_id, :type => type, :values => vals, :caption => cap.to_s } Research.save_config_yaml(yaml) render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end"
777,"def create Log.add_info(request, params.inspect) parent_id = params[:selectedFolderId] unless Folder.check_user_auth(parent_id, @login_user, 'w', true) flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') render(:partial => 'ajax_folder_entry', :layout => false) return end if params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @folder = nil else @folder = Folder.new @folder.name = params[:thetisBoxEdit] @folder.xorder = Folder.get_order_max(parent_id) + 1 @folder.parent_id = parent_id @folder.inherit_parent_auth @folder.save! end render(:partial => 'ajax_folder_entry', :layout => false) end",True,Ruby,create,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def add_statistics_group Log.add_info(request, params.inspect) return unless request.post? current_id = params[:current_id] unless params[:thetisBoxSelKeeper].nil? group_id = params[:thetisBoxSelKeeper].split(':').last end SqlHelper.validate_token([current_id, group_id]) if group_id.blank? @group_ids = Research.get_statistics_groups render(:partial => 'ajax_statistics_groups', :layout => false) return end unless current_id.blank? Research.delete_statistics_group(current_id) end @group_ids = Research.add_statistics_group(group_id) render(:partial => 'ajax_statistics_groups', :layout => false) end"
783,"def set_auth_users Log.add_info(request, params.inspect) @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_users = [] write_users = [] users_auth = params[:users_auth] unless users_auth.nil? users_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_users << user_id end if auths.include?('w') write_users << user_id end end end user_id = @folder.get_my_folder_owner if !user_id.nil? and (!read_users.include?(user_id.to_s) or !write_users.include?(user_id.to_s)) flash[:notice] = 'ERROR:' + t('folder.my_folder_without_auth_owner') else @folder.set_read_users read_users @folder.set_write_users write_users @folder.save flash[:notice] = t('msg.register_success') end else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end @group_id = params[:group_id] if @group_id.nil? or @group_id.empty? @users = [] else @users = Group.get_users(@group_id) end render(:partial => 'ajax_auth_users', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_users', :layout => false) end",True,Ruby,set_auth_users,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_groups_order Log.add_info(request, params.inspect) return unless request.post? order_ary = params[:groups_order] Research.set_statistics_groups(order_ary) render(:text => '') end"
784,"def get_path Log.add_info(request, params.inspect) if params[:thetisBoxSelKeeper].nil? or params[:thetisBoxSelKeeper].empty? @folder_path = '/' + t('paren.unknown') render(:partial => 'ajax_folder_path', :layout => false) return end @selected_id = params[:thetisBoxSelKeeper].split(':').last @folder_path = Folder.get_path(@selected_id) render(:partial => 'ajax_folder_path', :layout => false) end",True,Ruby,get_path,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def reset_users Log.add_info(request, params.inspect) return unless request.post? count = 0 unless params[:check_user].nil? params[:check_user].each do |user_id, value| if value == '1' SqlHelper.validate_token([user_id]) begin Research.destroy_all(""user_id=#{user_id.to_i}"") count += 1 rescue => evar Log.add_error(request, evar) end end end end if count > 0 flash[:notice] = t('msg.status_of')+ count.to_s + t('user.status_reset') end redirect_to(:controller => 'researches', :action => 'users') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end"
785,"def get_auth_groups Log.add_info(request, params.inspect) begin @folder = Folder.find(params[:id]) rescue @folder = nil end @groups = Group.where(nil).to_a session[:folder_id] = params[:id] render(:partial => 'ajax_auth_groups', :layout => false) end",True,Ruby,get_auth_groups,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def group Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today else @date = Date.parse(date_s) end @group_id = params[:id] SqlHelper.validate_token([@group_id, params[:id]]) group_users = Group.get_users(params[:id]) @user_schedule_hash = {} unless group_users.nil? @holidays = Schedule.get_holidays group_users.each do |user| @user_schedule_hash[user.id.to_s] = Schedule.get_somebody_week(@login_user, user.id, @date, @holidays) end end params[:display] = params[:action] + '_' + params[:id] end"
786,"def rename Log.add_info(request, params.inspect) @folder = Folder.find(params[:id]) unless Folder.check_user_auth(@folder.id, @login_user, 'w', true) flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') render(:partial => 'ajax_folder_name', :layout => false) return end unless params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @folder.name = params[:thetisBoxEdit] @folder.save end render(:partial => 'ajax_folder_name', :layout => false) end",True,Ruby,rename,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def team Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today else @date = Date.parse(date_s) end begin team = Team.find(params[:id]) team_users = team.get_users_a rescue => evar Log.add_error(request, evar) end @user_schedule_hash = {} unless team_users.nil? @holidays = Schedule.get_holidays team_users.each do |user_id| @user_schedule_hash[user_id] = Schedule.get_somebody_week(@login_user, user_id, @date, @holidays) end end params[:display] = params[:action] + '_' + params[:id] end"
788,"def set_auth_teams Log.add_info(request, params.inspect) @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_teams = [] write_teams = [] teams_auth = params[:teams_auth] unless teams_auth.nil? teams_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_teams << user_id end if auths.include?('w') write_teams << user_id end end end @folder.set_read_teams read_teams @folder.set_write_teams write_teams @folder.save flash[:notice] = t('msg.register_success') else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end target_user_id = (@login_user.admin?(User::AUTH_TEAM))?(nil):(@login_user.id) @teams = Team.get_for(target_user_id, true) render(:partial => 'ajax_auth_teams', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_teams', :layout => false) end",True,Ruby,set_auth_teams,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def save Log.add_info(request, params.inspect) return unless request.post? date = Date.parse(params[:date]) unless params[:id].blank? begin schedule = Schedule.find(params[:id]) rescue => evar Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('msg.already_deleted', :name => Schedule.model_name.human) redirect_to(:action => 'day', :date => date.strftime(Schedule::SYS_DATE_FORM)) return end unless schedule.check_user_auth(@login_user, 'w', true) Log.add_check(request, '[Schedule.check_user_auth]'+request.to_s) if @login_user.nil? check_login else redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') end return end end if params[:users].blank? \ and params[:groups].blank? \ and params[:teams].blank? \ and (params[:schedule][:scope] != Schedule::SCOPE_ALL) nearest_day = schedule.get_nearest_day(date) schedule.destroy unless schedule.nil? else [:users, :groups, :teams, :items].each do |attr| SqlHelper.validate_token([params[attr]]) if params[attr].blank? params[:schedule][attr] = nil else params[:schedule][attr] = '|' + params[attr].join('|') + '|' end end equipment_ids = (params[:equipment] || []) equipment_ids.delete('') if equipment_ids.empty? params[:schedule][:equipment] = nil else equipment_ids.each do |equipment_id| begin equipment = Equipment.find(equipment_id) rescue => evar equipment = nil end if equipment.nil? or !equipment.is_accessible_by(@login_user) flash[:notice] = 'ERROR:' + t('msg.need_auth_to_access') + t('cap.suffix') + Equipment.get_name(equipment_id) redirect_to(:action => 'day', :date => params[:date]) return end end params[:schedule][:equipment] = '|' + equipment_ids.join('|') + '|' end if params[:is_repeat] == '1' if params[:repeat_rules].blank? params[:schedule][:repeat_rule] = nil else params[:schedule][:repeat_rule] = '|' + params[:repeat_rules].join('|') + '|' end if params[:excepts].blank? params[:schedule][:except] = nil else excepts = params[:excepts] excepts.sort! excepts.reverse! params[:schedule][:except] = '|' + excepts.join('|') + '|' end else params[:schedule][:repeat_rule] = nil params[:schedule][:repeat_start] = nil params[:schedule][:repeat_end] = nil params[:schedule][:except] = nil end params[:schedule][:end] = SchedulesHelper.regularize(params[:schedule][:end]) check_schedule = Schedule.new(params.require(:schedule).permit(Schedule::PERMIT_BASE)) nearest_day = check_schedule.get_nearest_day(date) if nearest_day.nil? check_schedule.id = params[:id].to_i unless params[:id].nil? or params[:id].empty? flash[:notice] = 'ERROR:' + t('schedule.no_day_in_rule') if params[:fwd_controller].blank? self.index else prms = ApplicationHelper.get_fwd_params(params) prms.delete('id') prms.delete('schedule') prms[:controller] = params[:fwd_controller] prms[:action] = params[:fwd_action] redirect_to(prms) end # redirect_to(:action => 'day', :date => params[:date]) return end created = false if schedule.nil? or params[:repeat_update_target] == 'each' # Create params[:schedule][:created_by] = @login_user.id params[:schedule][:created_at] = Time.now schedule = Schedule.new(params.require(:schedule).permit(Schedule::PERMIT_BASE)) schedule.save! created = true else # Update params[:schedule][:updated_by] = @login_user.id params[:schedule][:updated_at] = Time.now schedule.update_attributes(params.require(:schedule).permit(Schedule::PERMIT_BASE)) end if params[:repeat_update_target] == 'each' # Update original repeated schedule org_schedule = Schedule.find(params[:id]) attrs = ActionController::Parameters.new() attrs[:updated_by] = @login_user.id attrs[:updated_at] = Time.now excepts = org_schedule.get_excepts_a excepts << params[:date] excepts.sort! excepts.reverse! attrs[:except] = '|' + excepts.join('|') + '|' org_schedule.update_attributes(attrs.permit(Schedule::PERMIT_BASE)) end # prms = {:show_id => schedule.id} end if created flash[:notice] = t('msg.register_success') else flash[:notice] = t('msg.update_success') end params[:date] = nearest_day.strftime(Schedule::SYS_DATE_FORM) if params[:fwd_controller].blank? self.index self.show unless self.performed? else prms = ApplicationHelper.get_fwd_params(params) prms.delete('id') prms.delete('schedule') prms[:controller] = params[:fwd_controller] prms[:action] = params[:fwd_action] redirect_to(prms) end rescue => evar Log.add_error(request, evar) date = Date.parse(params[:date]) redirect_to(:action => 'day', :date => date.strftime(Schedule::SYS_DATE_FORM)) end"
789,"def get_auth_users Log.add_info(request, params.inspect) begin @folder = Folder.find(params[:id]) rescue @folder = nil end @users = [] session[:folder_id] = params[:id] if !@login_user.nil? and (@login_user.admin?(User::AUTH_FOLDER) or (!@folder.nil? and @folder.in_my_folder_of?(@login_user.id))) render(:partial => 'ajax_auth_users', :layout => false) else render(:partial => 'ajax_auth_disp', :layout => false) end end",True,Ruby,get_auth_users,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def get_folder_items Log.add_info(request, params.inspect) unless params[:thetisBoxSelKeeper].blank? @folder_id = params[:thetisBoxSelKeeper].split(':').last end begin if Folder.check_user_auth(@folder_id, @login_user, 'r', true) @items = Folder.get_items(@login_user, @folder_id) end rescue => evar Log.add_error(request, evar) end submit_url = url_for(:controller => 'schedules', :action => 'get_folder_items') render(:partial => 'common/select_items', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end"
791,"def ajax_delete_items Log.add_info(request, params.inspect) folder_id = params[:id] unless params[:check_item].blank? is_admin = @login_user.admin?(User::AUTH_ITEM) count = 0 params[:check_item].each do |item_id, value| if value == '1' begin item = Item.find(item_id) next if !is_admin and item.user_id != @login_user.id item.destroy rescue => evar Log.add_error(request, evar) end count += 1 end end flash[:notice] = t('item.deleted', :count => count) end get_items end",True,Ruby,ajax_delete_items,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def day Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today else @date = Date.parse(date_s) end if params[:user_id].blank? user_id = @login_user.id unless @login_user.nil? @schedules = Schedule.get_user_day(@login_user, @date) else user_id = params[:user_id].to_i @schedules = Schedule.get_somebody_day(@login_user, user_id, @date) end schedule_id = nil schedule_id = params[:show_id] unless params[:show_id].nil? schedule_id = params[:edit_id] unless params[:edit_id].nil? unless schedule_id.nil? begin @schedule = Schedule.find(schedule_id) unless @schedule.check_user_auth(@login_user, 'r', true) Log.add_check(request, '[Schedule.check_user_auth]'+request.to_s) if @login_user.nil? check_login else redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') end return end rescue end end if !@login_user.nil? and user_id == @login_user.id and !@schedules.nil? equip_ary = [] @schedules.each do |schedule| equip_ary = equip_ary | schedule.get_equipment_a end overlap_h = {} equip_ary.each do |equip_id| schedule_ary = Schedule.get_equipment_day(equip_id, @date) overlaps = Schedule.check_overlap_equipment(equip_id, schedule_ary, @date) unless overlaps.empty? overlap_h[equip_id] = overlaps end end unless overlap_h.empty? flash[:notice] = 'ERROR:' + t('schedule.conflict_equipment') flash[:notice] << '<br/>' overlap_h.each do |equip_id, schedule_ary| flash[:notice] << '&laquo;' + Equipment.get_name(equip_id) + '&raquo;<br/>' flash[:notice] << '<ul style=\'padding-left:40px;\'>' schedule_ary.each do |schedule_id| flash[:notice] << '<li>' + Schedule.get_title(schedule_id) + '</li>' end flash[:notice] << '</ul>' end end end params[:display] = 'day' end"
796,"def get_auth_teams Log.add_info(request, params.inspect) begin @folder = Folder.find(params[:id]) rescue @folder = nil end target_user_id = (@login_user.admin?(User::AUTH_TEAM))?(nil):(@login_user.id) @teams = Team.get_for(target_user_id, true) session[:folder_id] = params[:id] render(:partial => 'ajax_auth_teams', :layout => false) end",True,Ruby,get_auth_teams,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def week Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today else @date = Date.parse(date_s) end params[:display] = 'week' end"
802,"def get_disp_ctrl Log.add_info(request, params.inspect) if params[:id] != '0' begin @folder = Folder.find(params[:id]) rescue => evar @folder = nil end end session[:folder_id] = params[:id] render(:partial => 'ajax_disp_ctrl', :layout => false) end",True,Ruby,get_disp_ctrl,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def new Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] if mail_account_id.blank? account_xtype = params[:mail_account_xtype] SqlHelper.validate_token([account_xtype]) @mail_account = MailAccount.get_default_for(@login_user.id, account_xtype) else @mail_account = MailAccount.find(mail_account_id) if @mail_account.user_id != @login_user.id flash[:notice] = 'ERROR:' + t('msg.need_to_be_owner') render(:partial => 'common/flash_notice', :layout => false) return end end if $thetis_config[:menu]['disp_user_list'] == '1' unless params[:to_user_ids].blank? @email = Email.new to_addrs = [] @user_obj_cache ||= {} params[:to_user_ids].each do |user_id| user = User.find_with_cache(user_id, @user_obj_cache) user_emails = user.get_emails_by_type(nil) user_emails.each do |user_email| disp = EmailsHelper.format_address_exp(user.get_name, user_email, false) entry_val = ""#{disp}"" # ""#{disp}#{Email::ADDR_ORDER_SEPARATOR}#{user.get_xorder(@group_id)}"" to_addrs << entry_val end end @email.to_addresses = to_addrs.join(Email::ADDRESS_SEPARATOR) end end render(:action => 'edit', :layout => (!request.xhr?)) end"
803,"def set_auth_groups Log.add_info(request, params.inspect) @folder = Folder.find(params[:id]) if Folder.check_user_auth(@folder.id, @login_user, 'w', true) read_groups = [] write_groups = [] groups_auth = params[:groups_auth] unless groups_auth.nil? groups_auth.each do |auth_param| user_id = auth_param.split(':').first auths = auth_param.split(':').last.split('+') if auths.include?('r') read_groups << user_id end if auths.include?('w') write_groups << user_id end end end @folder.set_read_groups read_groups @folder.set_write_groups write_groups @folder.save flash[:notice] = t('msg.register_success') else flash[:notice] = 'ERROR:' + t('folder.need_auth_to_modify') end @groups = Group.where(nil).to_a render(:partial => 'ajax_auth_groups', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_auth_groups', :layout => false) end",True,Ruby,set_auth_groups,folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_member return if params[:id].blank? or @login_user.nil? if Item.find(params[:id]).user_id != @login_user.id Log.add_check(request, '[check_member]'+request.to_s) flash[:notice] = t('team.need_to_be_member') redirect_to(:controller => 'desktop', :action => 'show') end end"
805,"def rename Log.add_info(request, params.inspect) @group = Group.find(params[:id]) unless params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @group.rename params[:thetisBoxEdit] end render(:partial => 'ajax_group_name', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_group_name', :layout => false) end",True,Ruby,rename,groups_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def create_workflow Log.add_info(request, params.inspect) return unless request.post? @tmpl_folder, @tmpl_workflows_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_WORKFLOWS) @group_id = params[:group_id] SqlHelper.validate_token([@group_id]) if @group_id.blank? @group_id = '0' # '0' for ROOT elsif @group_id == '0' ; else group = nil begin group = Group.find(@group_id) rescue end if group.nil? render(:text => 'ERROR:' + t('msg.already_deleted', :name => Group.model_name.human)) return end end unless @tmpl_workflows_folder.nil? item = Item.new_workflow(@tmpl_workflows_folder.id) item.title = t('workflow.new') item.user_id = 0 item.save! workflow = Workflow.new workflow.item_id = item.id workflow.user_id = 0 workflow.status = Workflow::STATUS_NOT_APPLIED if @group_id == '0' workflow.groups = nil else workflow.groups = '|' + @group_id + '|' end workflow.save! else Log.add_error(request, nil, '/'+TemplatesHelper::TMPL_ROOT+'/'+TemplatesHelper::TMPL_WORKFLOWS+' NOT found!') end render(:partial => 'groups/ajax_group_workflows', :layout => false) end"
813,"def get_path Log.add_info(request, params.inspect) if params[:thetisBoxSelKeeper].nil? or params[:thetisBoxSelKeeper].empty? @group_path = '/' + t('paren.unknown') render(:partial => 'ajax_group_path', :layout => false) return end @selected_id = params[:thetisBoxSelKeeper].split(':').last @group_path = Group.get_path(@selected_id) render(:partial => 'ajax_group_path', :layout => false) end",True,Ruby,get_path,groups_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def destroy_workflow Log.add_info(request, params.inspect) return unless request.post? Item.find(params[:id]).destroy @tmpl_folder, @tmpl_workflows_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_WORKFLOWS) @group_id = params[:group_id] SqlHelper.validate_token([@group_id]) if @group_id.blank? @group_id = '0' # '0' for ROOT end render(:partial => 'groups/ajax_group_workflows', :layout => false) end"
815,"def create Log.add_info(request, params.inspect) if params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @group = nil else @group = Group.new @group.name = params[:thetisBoxEdit] @group.parent_id = params[:selectedGroupId] @group.save! @group.create_group_folder end render(:partial => 'ajax_group_entry', :layout => false) end",True,Ruby,create,groups_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update Log.add_info(request, params.inspect) return unless request.post? if params[:id].blank? @timecard = Timecard.new else @timecard = Timecard.find(params[:id]) end options = params[:timecard]['options'] if options.nil? params[:timecard]['options'] = nil else params[:timecard]['options'] = '|' + options.join('|') + '|' end if params[:user_id].blank? @selected_user = @login_user elsif (@login_user.id.to_s == params[:user_id]) @selected_user = @login_user else unless @login_user.admin?(User::AUTH_TIMECARD) Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end @selected_user = User.find(params[:user_id]) end if Timecard.off?(params[:timecard]['workcode']) params[:timecard]['start'] = nil params[:timecard]['end'] = nil params[:timecard]['options'] = nil else breaks = @timecard.get_breaks_a unless breaks.empty? check_error = false unless params[:timecard]['start'].blank? start_t = UtilDateTime.parse(params[:timecard]['start']).to_time check_error = true if breaks.first.first < start_t end unless params[:timecard]['end'].blank? end_t = UtilDateTime.parse(params[:timecard]['end']).to_time check_error = true if end_t < breaks.last.last end if check_error flash[:notice] = 'ERROR:' + t('timecard.break_out_of_labor') render(:partial => 'ajax_update_break', :layout => false) return end end end if (@login_user.id.to_s != params[:timecard][:user_id] and !@login_user.admin?(User::AUTH_TIMECARD)) \ or (!@timecard.user_id.nil? and @timecard.user_id.to_s != params[:timecard][:user_id]) Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end if @timecard.update_attributes(params.require(:timecard).permit(Timecard::PERMIT_BASE)) if @timecard.off? and !@timecard.get_breaks_a.empty? @timecard.update_breaks(nil) end flash[:notice] = t('msg.update_success') unless @timecard.start.nil? or @timecard.end.nil? @timecard.set_default_breaks end end"
821,"def set_description Log.add_info(request, params.inspect) if params[:id].nil? or params[:id].empty? @item = Item.new_info(0) @item.attributes = params.require(:item).permit(Item::PERMIT_BASE) @item.user_id = @login_user.id @item.title = t('paren.no_title') @item.save else @item = Item.find(params[:id]) @item.update_attributes(params.require(:item).permit(Item::PERMIT_BASE)) end render(:partial => 'ajax_item_description', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_item_description', :layout => false) end",True,Ruby,set_description,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def update_config Log.add_info(request, params.inspect) return unless request.post? yaml = ApplicationHelper.get_config_yaml unless params[:timecard].blank? yaml[:timecard] = Hash.new if yaml[:timecard].nil? params[:timecard].each do |key, val| yaml[:timecard][key] = val end ApplicationHelper.save_config_yaml(yaml) end @yaml_timecard = yaml[:timecard] @yaml_timecard = Hash.new if @yaml_timecard.nil? flash[:notice] = t('msg.update_success') render(:action => 'configure') end"
822,"def set_workflow Log.add_info(request, params.inspect) @item = Item.find(params[:id]) orders_hash = params.dup orders_hash.reject! { |key, value| key.index(/order-/) != 0 } orders_hash.sort_by { |key, value| key.split('-').last.to_i } orders = [] orders_hash.each do |key, value| orders << '|' + value.split(',').join('|') + '|' end @item.workflow.update_attribute(:users, orders.join(',')) render(:partial => 'ajax_item_workflow', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_item_workflow', :layout => false) end",True,Ruby,set_workflow,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def group Log.add_info(request, params.inspect) date_s = params[:date] if date_s.blank? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse(date_s) end if params[:display] == 'mine' redirect_to(:action => 'month') else display_type = params[:display].split('_').first display_id = params[:display].split('_').last SqlHelper.validate_token([display_id]) @selected_users = Group.get_users(display_id) @group_id = display_id if !@login_user.get_groups_a.include?(@group_id.to_s) and !@login_user.admin?(User::AUTH_TIMECARD) Log.add_check(request, '[User.get_groups_a.include?]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end end end"
825,"def bbs Log.add_info(request, params.inspect) if !params[:select_sorting].nil? sort_a = params[:select_sorting].split(' ') params[:sort_col] = sort_a.first params[:sort_type] = sort_a.last end list render(:action => 'bbs') end",True,Ruby,bbs,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def month if params[:action] == 'month' Log.add_info(request, params.inspect) end if !params[:display].nil? and params[:display].split('_').first == 'group' @group_id = params[:display].split('_').last end if params[:user_id].nil? @selected_user = @login_user else @selected_user = User.find(params[:user_id]) if @selected_user.id != @login_user.id and !@login_user.admin?(User::AUTH_TIMECARD) if (@selected_user.get_groups_a & @login_user.get_groups_a).empty? Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end end end year_begins_from, month_begins_at = TimecardsHelper.get_fiscal_params date_s = params[:date] if date_s.blank? date = Date.today else date_params = date_s.split('-') if date_params.length == 2 @year = date_params.first.to_i @month = date_params.last.to_i date = TimecardsHelper.get_first_day_in_fiscal_month(@year, @month, month_begins_at) else date = Date.parse(date_s) end end @fiscal_year = TimecardsHelper.get_fiscal_year(date, year_begins_from, month_begins_at) fiscal_month = TimecardsHelper.get_fiscal_month(date, month_begins_at) if @year.nil? or @month.nil? @month = fiscal_month if fiscal_month < date.month and fiscal_month == 1 @year = date.year + 1 elsif fiscal_month > date.month and fiscal_month == 12 @year = date.year - 1 else @year = date.year end end @start_date, @end_date = TimecardsHelper.get_month_span(date, month_begins_at) @timecards = Timecard.find_term(@selected_user.id, @start_date, @end_date) @paid_holiday = PaidHoliday.get_for(@selected_user.id, @fiscal_year) year_start, year_end = TimecardsHelper.get_year_span(@fiscal_year, year_begins_from, month_begins_at) @applied_paid_hlds = Timecard.applied_paid_hlds(@selected_user.id, year_start, @start_date - 1) end"
827,"def get_attachment Log.add_info(request, params.inspect) attach = Attachment.find(params[:id]) if attach.nil? redirect_to(THETIS_RELATIVE_URL_ROOT + '/404.html') return end parent_item = attach.item || ((attach.comment.nil?) ? nil : attach.comment.item) if parent_item.nil? or !parent_item.check_user_auth(@login_user, 'r', true) Log.add_check(request, '[Item.check_user_auth]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end attach_name = attach.name agent = request.env['HTTP_USER_AGENT'] unless agent.nil? ie_ver = nil agent.scan(/\sMSIE\s?(\d+)[.](\d+)/){|m| ie_ver = m[0].to_i + (0.1 * m[1].to_i) } attach_name = CGI::escape(attach_name) unless ie_ver.nil? end begin attach_location = attach.location rescue attach_location = Attachment::LOCATION_DB # for lower versions end if attach_location == Attachment::LOCATION_DIR filepath = AttachmentsHelper.get_path(attach) send_file(filepath, :filename => attach_name, :stream => true, :disposition => 'attachment') else send_data(attach.content, :type => (attach.content_type || 'application/octet-stream')+';charset=UTF-8', :disposition => 'attachment;filename=""'+attach_name+'""') end end",True,Ruby,get_attachment,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def destroy Log.add_info(request, params.inspect) return unless request.post? if params[:check_user].nil? list render(:action => 'list') return end count = 0 params[:check_user].each do |user_id, value| if value == '1' SqlHelper.validate_token([user_id]) begin User.destroy(user_id) rescue => evar Log.add_error(request, evar) end count += 1 end end flash[:notice] = count.to_s + t('user.deleted') redirect_to(:action => 'list') end"
833,"def update_attachments_order Log.add_info(request, params.inspect) order_ary = params[:attachments_order] item = Item.find(params[:id]) item.attachments_without_content.each do |attach| class << attach def record_timestamps; false; end end attach.update_attribute(:xorder, order_ary.index(attach.id.to_s) + 1) class << attach remove_method :record_timestamps end end render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end",True,Ruby,update_attachments_order,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def exclude_from_group Log.add_info(request, params.inspect) return unless request.post? if params[:group_id].blank? render(:partial => 'ajax_groups', :layout => false) return end group_id = params[:group_id] begin @user = User.find(params[:id]) unless @user.nil? if @user.exclude_from(group_id) @user.save if @user.id == @login_user.id @login_user = @user end end end rescue => evar Log.add_error(request, evar) end render(:partial => 'ajax_groups', :layout => false) end"
834,"def team_organize Log.add_info(request, params.inspect) team_id = params[:team_id] unless team_id.blank? begin @team = Team.find(team_id) rescue @team = nil ensure if @team.nil? flash[:notice] = t('msg.already_deleted', :name => Team.model_name.human) return end end users = @team.get_users_a end team_members = params[:team_members] SqlHelper.validate_token([team_members]) created = false modified = false if team_members.nil? or team_members.empty? unless team_id.blank? # @team must not be nil. @team.save if modified = @team.clear_users end else if team_members != users if team_id.blank? item = Item.find(params[:id]) created = true @team = Team.new @team.name = item.title @team.item_id = params[:id] @team.status = Team::STATUS_STANDBY else @team.clear_users end @team.add_users(team_members) @team.save @team.remove_application(team_members) modified = true end end if created @team.create_team_folder end @item = @team.item if modified flash[:notice] = t('msg.register_success') end render(:partial => 'ajax_team_info', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_team_info', :layout => false) end",True,Ruby,team_organize,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def create_title return unless request.post? titles = User.get_config_titles titles = [] if titles.nil? titles << t('user.new_title') User.save_config_titles(titles) render(:partial => 'ajax_title', :layout => false) end"
840,"def set_attachment Log.add_info(request, params.inspect) created = false if params[:id].nil? or params[:id].empty? @item = Item.new_info(0) @item.attributes = params[:item] @item.user_id = @login_user.id @item.title = t('paren.no_title') [:attachment0, :attachment1].each do |attach| next if params[attach].nil? or params[attach][:file].nil? or params[attach][:file].size == 0 @item.save! created = true break end else @item = Item.find(params[:id]) end modified = false item_attachments = @item.attachments_without_content [:attachment0, :attachment1].each do |attach| next if params[attach].nil? or params[attach][:file].nil? or params[attach][:file].size == 0 attachment = Attachment.create(params[attach], @item, item_attachments.length) modified = true item_attachments << attachment end if modified and !created @item.update_attribute(:updated_at, Time.now) end render(:partial => 'ajax_item_attachment', :layout => false) rescue => evar Log.add_error(request, evar) @attachment = Attachment.new @attachment.errors.add_to_base(evar.to_s[0, 256]) render(:partial => 'ajax_item_attachment', :layout => false) end",True,Ruby,set_attachment,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def _process_user_attrs(user, attrs) if attrs[:birthday].nil? begin attrs[:birthday] = attrs[:birthday_y] + '-' + attrs[:birthday_m] + '-' + attrs[:birthday_d] rescue end attrs.delete(:birthday_y) attrs.delete(:birthday_m) attrs.delete(:birthday_d) end if !attrs[:name].nil? or !attrs[:password].nil? user_name = attrs[:name] user_name ||= user.name unless user.nil? password = attrs[:password] if password.blank? password = UsersHelper.generate_password attrs[:password] = password end attrs[:pass_md5] = UsersHelper.generate_digest_pass(user_name, password) end return attrs end"
842,"def update_images_order Log.add_info(request, params.inspect) order_ary = params[:images_order] item = Item.find(params[:id]) item.images_without_content.each do |img| class << img def record_timestamps; false; end end img.update_attribute(:xorder, order_ary.index(img.id.to_s) + 1) class << img remove_method :record_timestamps end end render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end",True,Ruby,update_images_order,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def add_to_group Log.add_info(request, params.inspect) return unless request.post? if params[:thetisBoxSelKeeper].blank? render(:partial => 'ajax_groups', :layout => false) return end group_id = params[:thetisBoxSelKeeper].split(':').last unless group_id == '0' # '0' for ROOT begin group = Group.find(group_id) rescue => evar Log.add_error(request, evar) ensure if group.nil? render(:partial => 'ajax_groups', :layout => false) return end end end begin @user = User.find(params[:user_id]) rescue => evar Log.add_error(request, evar) end unless @user.nil? is_modified = false # Change, not simply Add unless params[:current_id].blank? if @user.exclude_from(params[:current_id]) is_modified = true end end is_modified = true if @user.add_to(group_id) if is_modified == true @user.save! if @user.id == @login_user.id @login_user = @user end end end render(:partial => 'ajax_groups', :layout => false) end"
843,def new @item = Item.new if params[:folder_id].nil? or params[:folder_id].empty? my_folder = @login_user.get_my_folder if my_folder.nil? @item.folder_id = 0 else @item.folder_id = my_folder.id end else @item.folder_id = params[:folder_id].to_i end @item.xtype= Item::XTYPE_INFO @item.layout = 'C' render(:action => 'edit') end,True,Ruby,new,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def import_csv Log.add_info(request, params.inspect) return unless request.post? file = params[:imp_file] mode = params[:mode] enc = params[:enc] all_users = User.find_all user_names = [] # user_emails = [] if mode == 'add' all_users.each do |user| user_names << user.name # user_emails << user.email end end @imp_errs = {} count = -1 # 0 for Header-line users = [] opt = { :skip_blanks => true } csv = file.read begin csv.encode!(Encoding::UTF_8, enc, {:invalid => :replace, :undef => :replace, :replace => ' '}) rescue => evar Log.add_error(request, evar) end found_update = false CSV.parse(csv, opt) do |row| unless row.first.nil? next if row.first.lstrip.index('#') == 0 end next if row.compact.empty? count += 1 next if count == 0 # for Header Line user = User.parse_csv_row(row) check = user.check_import(mode, user_names) #, user_emails @imp_errs[count] = check unless check.empty? users << user if mode == 'update' update_user = all_users.find do |u| u.id == user.id end unless update_user.nil? all_users.delete(update_user) found_update = true end end end if users.empty? @imp_errs[0] = [t('user.nothing_to_import')] else if mode == 'update' if found_update user_admin = users.find do |user| user.admin?(User::AUTH_USER) end if user_admin.nil? @imp_errs[0] = [t('user.no_user_auth_import')] end else @imp_errs[0] = [t('user.nothing_to_update')] end end end # Create or Update count = 0 @imp_cnt = 0 if @imp_errs.empty? users.each do |user| count += 1 begin user_id = user.id user.save! if user_id.nil? user.setup end @imp_cnt += 1 rescue => evar @imp_errs[count] = [t('user.failed_to_save') + evar.to_s] end end end # Delete # Actually, the correct order of the process is Delete -> Create, # not to duplicate a User Name. # 3: morita <- Delete # : morita <- Create # But such a case is most likely to be considered as a # user's miss-operation. We can avoid this case with # 'opposite' process. del_cnt = 0 if @imp_errs.empty? and mode == 'update' all_users.each do |user| user.destroy del_cnt += 1 end end # Set order to display User.update_xorder(nil, User::XORDER_MAX) titles = User.get_config_titles unless titles.nil? idx = 0 titles.each do |title| User.update_xorder title, idx idx += 1 end end if @imp_errs.empty? flash[:notice] = users.length.to_s + t('user.imported') if del_cnt > 0 flash[:notice] << '<br/>' + del_cnt.to_s + t('user.deleted') end end list render(:action => 'list') end"
844,"def wf_issue Log.add_info(request, params.inspect) begin @item = Item.find(params[:id]) @workflow = @item.workflow rescue => evar Log.add_error(request, evar) end attrs = ActionController::Parameters.new({status: Workflow::STATUS_ACTIVE, issued_at: Time.now}) @workflow.update_attributes(attrs.permit(Workflow::PERMIT_BASE)) @orders = @workflow.get_orders render(:partial => 'ajax_workflow', :layout => false) end",True,Ruby,wf_issue,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def rename_title Log.add_info(request, params.inspect) return unless request.post? org_title = params[:org_title] new_title = params[:new_title] if org_title.nil? or new_title.nil? or org_title == new_title render(:partial => 'ajax_title', :layout => false) return end titles = User.get_config_titles unless titles.nil? if titles.include?(new_title) flash[:notice] = 'ERROR:' + t('user.title_duplicated') else idx = titles.index(org_title) unless idx.nil? titles[idx] = new_title User.save_config_titles(titles) User.rename_title(org_title, new_title) User.update_xorder(new_title, idx) end end end render(:partial => 'ajax_title', :layout => false) end"
851,"def set_image Log.add_info(request, params.inspect) created = false if params[:id].nil? or params[:id].empty? @item = Item.new_info(0) @item.attributes = params[:item] @item.user_id = @login_user.id @item.title = t('paren.no_title') [:image0, :image1].each do |img| next if params[img].nil? or params[img][:file].size == 0 @item.save! created = true break end else @item = Item.find(params[:id]) end modified = false item_images = @item.images_without_content [:image0, :image1].each do |img| next if params[img].nil? or params[img][:file].nil? or params[img][:file].size == 0 image = Image.new image.item_id = @item.id image.file = params[img][:file] image.title = params[img][:title] image.memo = params[img][:memo] image.xorder = item_images.length image.save! modified = true item_images << image end if modified and !created @item.update_attribute(:updated_at, Time.now) end render(:partial => 'ajax_item_image', :layout => false) rescue => evar Log.add_error(request, evar) @image = Image.new @image.errors.add_to_base(evar.to_s[0, 256]) render(:partial => 'ajax_item_image', :layout => false) end",True,Ruby,set_image,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_owner return if params[:id].blank? or @login_user.nil? begin owner_id = Workflow.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_WORKFLOW) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end"
861,"def search Log.add_info(request, params.inspect) unless params[:select_sorting].nil? or params[:select_sorting].empty? sort_a = params[:select_sorting].split(' ') params[:sort_col] = sort_a.first params[:sort_type] = sort_a.last end list if params[:keyword].nil? or params[:keyword].empty? if params[:from_action].nil? or params[:from_action] == 'bbs' render(:action => 'bbs') else render(:action => 'list') end end end",True,Ruby,search,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def reply Log.add_info(request, '') # Not to show passwords. return unless request.post? unless params[:attach_id].blank? target = Attachment.find(params[:attach_id]) end unless params[:cmd_id].blank? target = ZeptairCommand.find(params[:cmd_id]) end if target.nil? or target.item.nil? \ or target.item.xtype != Item::XTYPE_ZEPTAIR_DIST render(:text => 'ERROR:' + t('msg.system_error')) return end item = target.item comment = ZeptairDistHelper.get_comment_of(item.id, @login_user.id) case params[:status] when ZeptairDistHelper::ENTRY_STATUS_SAVED, ZeptairDistHelper::ENTRY_STATUS_EXECUTED, ZeptairDistHelper::ENTRY_STATUS_ERROR new_entry = ""#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}#{params[:timestamp]}#{ZeptairDistHelper::ACK_TS_SEP}#{params[:status]}"" if comment.nil? comment = Comment.new comment.user_id = @login_user.id comment.item_id = item.id comment.xtype = Comment::XTYPE_DIST_ACK comment.message = new_entry + ""\n"" comment.save! else class_order = {'Attachment' => 0, 'ZeptairCommand' => 1} target_order = class_order[target.class.to_s] entries = ZeptairDistHelper.get_ack_array_of(comment) unless entries.include?(new_entry) msg = '' inserted = false entries.each do |entry| next if entry.nil? or entry.empty? regexp = Regexp.new(""^([a-zA-Z]+)#{ZeptairDistHelper::ACK_CLASS_SEP}(\\d+)[#{ZeptairDistHelper::ACK_ID_SEP}]"") matched_ary = entry.scan(regexp) next if matched_ary.nil? matched_ary = matched_ary.flatten next if matched_ary.length < 2 entry_class = matched_ary.first entry_order = class_order[entry_class] entry_id = matched_ary.last.to_i if entry_class == target.class.to_s \ and entry_id == target.id msg << new_entry + ""\n"" inserted = true elsif !inserted \ and \ ((entry_class == target.class.to_s and target.id < entry_id) \ or (entry_class != target.class.to_s and target_order < entry_order)) msg << new_entry + ""\n"" msg << entry + ""\n"" inserted = true else msg << entry + ""\n"" end end unless inserted msg << new_entry + ""\n"" end comment.update_attribute(:message, msg) end end when 'canceled' unless comment.nil? if comment.message.nil? entries = [] else entries = comment.message.split(""\n"") end msg = '' exp = ""^#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}"" entries.each do |entry| next if entry.nil? or entry.empty? if entry.match(exp).nil? msg << entry + ""\n"" end end if msg.empty? comment.destroy else comment.update_attribute(:message, msg) end end end"
865,"def check_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? begin owner_id = Location.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_LOCATION) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,locations_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def delete_attachment Log.add_info(request, '') # Not to show passwords. return unless request.post? target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] attachment_id = params[:attachment_id] SqlHelper.validate_token([user_id, zeptair_id, attachment_id]) unless user_id.blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == user_id.to_s target_user = User.find(user_id) end end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if attachment_id.blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(attachment_id) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end"
866,"def on_moved Log.add_info(request, params.inspect) location_id = params[:id] if location_id.nil? or location_id.empty? location = Location.get_for(@login_user) if location.nil? location = Location.new location.user_id = @login_user.id end else begin location = Location.find(location_id) rescue end end unless location.nil? group_id = params[:group_id] group_id = nil if group_id.empty? attrs = ActionController::Parameters.new({group_id: group_id, x: params[:x], y: params[:y]}) location.update_attributes(attrs.permit(Location::PERMIT_BASE)) end render(:text => (location.nil?)?'':location.id.to_s) end",True,Ruby,on_moved,locations_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def self.delete_statistics_group(group_id) yaml = Research.get_config_yaml if yaml.nil? or yaml[:statistics].nil? return [] end groups = yaml[:statistics][:groups] return [] if groups.nil? ary = groups.split('|') ary.delete group_id.to_s ary.compact! ary.delete('') yaml[:statistics][:groups] = ary.join('|') Research.save_config_yaml(yaml) return ary end
870,"def login Log.add_info(request, '') # Not to show passwords. user = User.authenticate(params[:user]) if user.nil? flash[:notice] = '<span class=\'font_msg_bold\'>'+t('user.u_name')+'</span>'+t('msg.or')+'<span class=\'font_msg_bold\'>'+t('password.name')+'</span>'+t('msg.is_invalid') if params[:fwd_controller].nil? or params[:fwd_controller].empty? redirect_to(:controller => 'login', :action => 'index') else url_h = {:controller => 'login', :action => 'index', :fwd_controller => params[:fwd_controller], :fwd_action => params[:fwd_action]} unless params[:fwd_params].nil? params[:fwd_params].each do |key, val| url_h[""fwd_params[#{key}]""] = val end end redirect_to(url_h) end else @login_user = LoginHelper.on_login(user, session) if params[:fwd_controller].nil? or params[:fwd_controller].empty? prms = ApplicationHelper.get_fwd_params(params) prms.delete('user') prms[:controller] = 'desktop' prms[:action] = 'show' redirect_to(prms) else url_h = {:controller => params[:fwd_controller], :action => params[:fwd_action]} url_h = url_h.update(params[:fwd_params]) unless params[:fwd_params].nil? redirect_to(url_h) end end end",True,Ruby,login,login_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def self.add_statistics_group(group_id) yaml = Research.get_config_yaml yaml = Hash.new if yaml.nil? if yaml[:statistics].nil? yaml[:statistics] = Hash.new end groups = yaml[:statistics][:groups] if groups.nil? yaml[:statistics][:groups] = group_id ary = [group_id.to_s] else ary = groups.split('|') ary << group_id ary.compact! ary.delete('') yaml[:statistics][:groups] = ary.join('|') end Research.save_config_yaml(yaml) return ary end
877,"def check_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? mail_account = MailAccount.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and mail_account.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,mail_accounts_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def self.set_statistics_groups(group_ids) yaml = Research.get_config_yaml yaml = Hash.new if yaml.nil? if group_ids.nil? unless yaml[:statistics].nil? yaml[:statistics].delete(:groups) end else if yaml[:statistics].nil? yaml[:statistics] = Hash.new end yaml[:statistics][:groups] = group_ids.join('|') end Research.save_config_yaml(yaml) return ary end
881,"def check_owner return if (params[:id].nil? or params[:id].empty? or @login_user.nil?) mail_filter = MailFilter.find(params[:id]) if !@login_user.admin?(User::AUTH_MAIL) and mail_filter.mail_account.user_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,mail_filters_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def destroy Log.add_info(request, params.inspect) return unless request.post? begin Item.destroy(params[:id]) rescue => evar Log.add_error(request, evar) end if params[:from_action].nil? render(:text => params[:id]) else flash[:notice] = t('msg.delete_success') self.send(params[:from_action]) end end"
885,"def get_mails if params[:action] == 'get_mails' Log.add_info(request, params.inspect) end if !params[:pop].nil? and params[:pop] == 'true' begin new_arrivals_h = {} mail_account_id = params[:mail_account_id] if mail_account_id.blank? mail_accounts = MailAccount.find_all(""user_id=#{@login_user.id}"") mail_accounts.each do |mail_account| emails = Email.do_pop(mail_account) unless emails.empty? new_arrivals_h[mail_account.id] ||= [] new_arrivals_h[mail_account.id] |= emails end end else mail_account = MailAccount.find(mail_account_id) emails = Email.do_pop(mail_account) unless emails.empty? new_arrivals_h[mail_account.id] ||= [] new_arrivals_h[mail_account.id] |= emails end end unless new_arrivals_h.empty? flash[:notice] = t('mail.received', :count => new_arrivals_h.values.flatten.length) # FEATURE_MAIL_FILTERS >>> new_arrivals_h.each do |mail_account_id, emails| mail_filters = MailFilter.get_for(mail_account_id, true, MailFilter::TRIGGER_CHECKING) filter_next = true emails.each do |email| mail_filters.each do |filter| filter_next = filter.execute(email) break unless filter_next end break unless filter_next end end # FEATURE_MAIL_FILTERS <<< end rescue => evar if evar.to_s.starts_with?('ERROR:') flash[:notice] = evar.to_s else flash[:notice] = 'ERROR:' + t('mail.receive_error') + '<br/>' + evar.to_s end Log.add_error(nil, evar) end end @folder_id = params[:id] if @folder_id == TreeElement::ROOT_ID.to_s @emails = nil else # FEATURE_PAGING_IN_TREE >>> @sort_col = (params[:sort_col] || 'sent_at') @sort_type = (params[:sort_type] || 'DESC') folder_ids = nil add_con = nil folder_ids = [@folder_id] sql = EmailsHelper.get_list_sql(@login_user, params[:keyword], folder_ids, @sort_col, @sort_type, 0, add_con) @email_pages, @emails, @total_num = paginate_by_sql(Email, sql, 10) # FEATURE_PAGING_IN_TREE <<< end session[:mailfolder_id] = @folder_id render(:partial => 'ajax_folder_mails', :layout => false) end",True,Ruby,get_mails,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def open_map Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) unless params[:keyword].blank? con_prim = [] con_second = [] key_array = params[:keyword].split(nil) key_array.each do |key| key_quot = SqlHelper.quote(key) con_prim << ""(name=#{key_quot} or fullname=#{key_quot} or email=#{key_quot})"" con_second << SqlHelper.get_sql_like([:name, :fullname, :email], key) end [con_prim, con_second].each do |con| next if con.empty? begin @target_user = User.where(con.join(' and ')).first rescue end next if @target_user.nil? target_location = Location.get_for(@target_user) unless target_location.nil? @group_id ||= target_location.group_id end break end end @location = Location.get_for(@login_user) unless @location.nil? @group_id ||= @location.group_id end group_ids = [] @group_obj_cache = {} if @location.nil? and @group_id.nil? group_ids = @login_user.get_groups_a(true, @group_obj_cache) group_ids << '0' # '0' for ROOT elsif !@group_id.nil? group_ids << @group_id if @group_id.to_i != 0 group = Group.find_with_cache(@group_id, @group_obj_cache) group_ids |= group.get_parents(false, @group_obj_cache) end end @map_group_id = nil group_ids.each do |grp_id| @office_map = OfficeMap.get_for_group(grp_id) if @office_map.img_enabled and (@office_map.img_size > 0) @map_group_id = @office_map.group_id break end end @locations = Location.get_for_group(@map_group_id) unless @location.nil? if @location.group_id == @map_group_id @location.update_attribute(:updated_at, Time.now) else @location = nil end end end"
886,"def create Log.add_info(request, params.inspect) parent_id = params[:selectedFolderId] if params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @mail_folder = nil else @mail_folder = MailFolder.new @mail_folder.name = params[:thetisBoxEdit] @mail_folder.parent_id = parent_id @mail_folder.user_id = @login_user.id @mail_folder.xtype = nil @mail_folder.save! end render(:partial => 'ajax_folder_entry', :layout => false) end",True,Ruby,create,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def delete_attachment Log.add_info(request, '') # Not to show passwords. return unless request.post? target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] attachment_id = params[:attachment_id] SqlHelper.validate_token([user_id, zeptair_id, attachment_id]) unless user_id.blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == user_id.to_s target_user = User.find(user_id) end end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id.to_i}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if attachment_id.blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(attachment_id) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end"
887,"def check_mail_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? begin owner_id = Email.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_MAIL) and owner_id != @login_user.id Log.add_check(request, '[check_mail_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_mail_owner,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def query Log.add_info(request, '') # Not to show passwords. unless @login_user.admin?(User::AUTH_ZEPTAIR) render(:text => 'ERROR:' + t('msg.need_to_be_admin')) return end target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] group_id = params[:group_id] SqlHelper.validate_token([user_id, zeptair_id, group_id]) unless user_id.blank? target_user = User.find(user_id) end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id.to_i}"").first end if target_user.nil? if group_id.blank? sql = 'select distinct Item.* from items Item, attachments Attachment' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << ' order by Item.user_id ASC' else group_ids = [group_id] if params[:recursive] == 'true' group_ids += Group.get_childs(group_id, true, false) end groups_con = [] group_ids.each do |grp_id| groups_con << SqlHelper.get_sql_like(['User.groups'], ""|#{grp_id}|"") end sql = 'select distinct Item.* from items Item, attachments Attachment, users User' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << "" and (Item.user_id=User.id and (#{groups_con.join(' or ')}))"" sql << ' order by Item.user_id ASC' end @post_items = Item.find_by_sql(sql) else @post_item = ZeptairPostHelper.get_item_for(target_user) end rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end"
892,"def empty Log.add_info(request, params.inspect) @folder_id = params[:id] mail_account_id = params[:mail_account_id] SqlHelper.validate_token([mail_account_id]) trash_folder = MailFolder.get_for(@login_user, mail_account_id, MailFolder::XTYPE_TRASH) mail_folder = MailFolder.find(@folder_id) emails = MailFolder.get_mails(mail_folder.id, @login_user) || [] if mail_folder.id == trash_folder.id \ or mail_folder.get_parents(false).include?(trash_folder.id.to_s) emails.each do |email| email.destroy end flash[:notice] = t('msg.delete_success') else emails.each do |email| email.update_attribute(:mail_folder_id, trash_folder.id) end flash[:notice] = t('msg.moved_to_trash') end get_mails end",True,Ruby,empty,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_copies_folder(user_id) my_folder = User.get_my_folder(user_id) unless my_folder.nil? folder_name_quot = SqlHelper.quote(Item.copies_folder) con = ""(parent_id=#{my_folder.id}) and (name=#{folder_name_quot})"" begin copies_folder = Folder.where(con).first rescue end if copies_folder.nil? folder = Folder.new folder.name = Item.copies_folder folder.parent_id = my_folder.id folder.owner_id = user_id.to_i folder.xtype = nil folder.read_users = '|' + user_id.to_s + '|' folder.write_users = '|' + user_id.to_s + '|' folder.save! copies_folder = folder end end return copies_folder end"
900,"def get_mail_content Log.add_info(request, params.inspect) mail_id = params[:id] begin @email = Email.find(mail_id) render(:partial => 'ajax_mail_content', :layout => false) rescue => evar Log.add_error(nil, evar) render(:text => '') end end",True,Ruby,get_mail_content,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_next_revision(user_id, source_id) SqlHelper.validate_token([user_id, source_id]) copied_items = Item.where(""user_id=#{user_id.to_i} and source_id=#{source_id.to_i}"").order('created_at DESC').to_a rev = 0 copied_items.each do |item| rev_ary = item.title.scan(/[#](\d\d\d)$/) next if rev_ary.nil? rev = rev_ary.first.to_a.first.to_i break end return ('#' + sprintf('%03d', rev+1)) end"
901,"def get_folders_order Log.add_info(request, params.inspect) @folder_id = params[:id] if @folder_id == '0' @folders = MailFolder.get_account_roots_for(@login_user) else mail_folder = MailFolder.find(@folder_id) if mail_folder.user_id == @login_user.id @folders = MailFolder.get_childs(@folder_id, false, true) end end render(:partial => 'ajax_folders_order', :layout => false) rescue => evar Log.add_error(request, evar) render(:partial => 'ajax_folders_order', :layout => false) end",True,Ruby,get_folders_order,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.exists_copies_folder?(user_id) my_folder = User.get_my_folder(user_id) unless my_folder.nil? folder_name_quot = SqlHelper.quote(Item.copies_folder) con = ""(parent_id=#{my_folder.id}) and (name=#{folder_name_quot})"" begin copies_folder = Folder.where(con).first rescue end end return !copies_folder.nil? end"
904,"def rename Log.add_info(request, params.inspect) @mail_folder = MailFolder.find(params[:id]) unless params[:thetisBoxEdit].nil? or params[:thetisBoxEdit].empty? @mail_folder.name = params[:thetisBoxEdit] @mail_folder.save end render(:partial => 'ajax_folder_name', :layout => false) end",True,Ruby,rename,mail_folders_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_sql_like(attr_names, keyword) key = SqlHelper.quote(""%#{SqlHelper.escape_for_like(keyword)}%"") con = [] attr_names.each do |attr_name| con << ""(#{attr_name} like #{key})"" end sql = con.join(' or ') sql = '(' + sql + ')' if con.length > 1 return sql end"
906,"def edit Log.add_info(request, params.inspect) @group_id = params[:group_id] official_title_id = params[:id] unless official_title_id.nil? or official_title_id.empty? @official_title = OfficialTitle.find(official_title_id) end render(:partial => 'ajax_official_title_form', :layout => (!request.xhr?)) end",True,Ruby,edit,official_titles_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_tmpl_subfolder(name) SqlHelper.validate_token([name]) tmpl_folder = Folder.where(name: TMPL_ROOT).first unless tmpl_folder.nil? name_quot = SqlHelper.quote(name) con = ""(parent_id=#{tmpl_folder.id}) and (name=#{name_quot})"" begin child = Folder.where(con).first rescue => evar Log.add_error(nil, evar) end end return [tmpl_folder, child] end"
907,"def show Log.add_info(request, params.inspect) @group_id = params[:group_id] official_title_id = params[:id] unless official_title_id.nil? or official_title_id.empty? @official_title = OfficialTitle.find(official_title_id) end render(:layout => (!request.xhr?)) end",True,Ruby,show,official_titles_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.setup_tmpl_folder begin tmpl_folder = Folder.where(name: TMPL_ROOT).first rescue end if tmpl_folder.nil? # Setup initial template-folders folder = Folder.new folder.name = TMPL_ROOT folder.parent_id = 0 folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_folder = folder end childs = Folder.where(""folders.parent_id=#{tmpl_folder.id}"").to_a # System tmpl_system_folder = childs.find{|child| child.name == TMPL_SYSTEM} if tmpl_system_folder.nil? folder = Folder.new folder.name = TMPL_SYSTEM folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_system_folder = folder # System - Profile Sheet item = Item.new_profile(tmpl_system_folder.id) item.title = Item.profile_title_def item.user_id = 0 item.save! end # Workflow tmpl_workflows_folder = childs.find{|child| child.name == TMPL_WORKFLOWS} if tmpl_workflows_folder.nil? folder = Folder.new folder.name = TMPL_WORKFLOWS folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_workflows_folder = folder end # Local tmpl_local_folder = childs.find{|child| child.name == TMPL_LOCAL} if tmpl_local_folder.nil? folder = Folder.new folder.name = TMPL_LOCAL folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_local_folder = folder end # Research tmpl_q_folder = childs.find{|child| child.name == TMPL_RESEARCH} if tmpl_q_folder.nil? folder = Folder.new folder.name = TMPL_RESEARCH folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_q_folder = folder end return [tmpl_folder, tmpl_system_folder, tmpl_workflows_folder, tmpl_local_folder, tmpl_q_folder] rescue => evar Log.add_error(nil, evar) return nil end"
912,"def destroy Log.add_info(request, params.inspect) begin OfficialTitle.destroy(params[:id]) rescue => evar Log.add_error(nil, evar) end @group_id = params[:group_id] if @group_id.nil? or @group_id.empty? @group_id = '0' # '0' for ROOT end render(:partial => 'groups/ajax_group_official_titles', :layout => false) end",True,Ruby,destroy,official_titles_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_tmpl_folder tmpl_folder = Folder.where(name: TMPL_ROOT).first if tmpl_folder.nil? ary = self.setup_tmpl_folder unless ary.nil? or ary.empty? tmpl_folder = ary[0] tmpl_system_folder = ary[1] tmpl_workflows_folder = ary[2] tmpl_local_folder = ary[3] tmpl_q_folder = ary[4] end else folders = Folder.where(""parent_id=#{tmpl_folder.id}"").to_a unless folders.nil? folders.each do |child| case child.name when TMPL_SYSTEM tmpl_system_folder = child when TMPL_WORKFLOWS tmpl_workflows_folder = child when TMPL_LOCAL tmpl_local_folder = child when TMPL_RESEARCH tmpl_q_folder = child end end end end"
916,"def delete_statistics_group Log.add_info(request, params.inspect) group_id = params[:group_id] if group_id.nil? or group_id.empty? @group_ids = Research.get_statistics_groups render(:partial => 'ajax_statistics_groups', :layout => false) return end @group_ids = Research.delete_statistics_group group_id render(:partial => 'ajax_statistics_groups', :layout => false) end",True,Ruby,delete_statistics_group,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_childs(klass, node_id, recursive, ret_obj) SqlHelper.validate_token([node_id]) array = [] if recursive tree = klass.get_tree(Hash.new, nil, node_id) return array if tree.nil? tree.each do |parent_id, childs| if ret_obj array |= childs else childs.each do |node| node_id = node.id.to_s array << node_id unless array.include?(node_id) end end end else nodes = klass.where(""parent_id=#{node_id.to_i}"").order('xorder ASC, id ASC').to_a if ret_obj array = nodes else nodes.each do |node| array << node.id.to_s end end end return array end"
917,"def update_q_ctrl Log.add_info(request, params.inspect) item_id = params[:item_id] q_code = params[:q_code] q_param = params[:q_param] cap = params[:caption] yaml = Research.get_config_yaml type = q_param.split(':').first vals = q_param[type.length+1 .. -1] yaml[q_code] = {:item_id => item_id, :type => type, :values => vals, :caption => cap.to_s } Research.save_config_yaml yaml render(:text => '') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end",True,Ruby,update_q_ctrl,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_tree(klass, tree, conditions, node_id, order_by) SqlHelper.validate_token([node_id]) if conditions.nil? con = '' else con = Marshal.load(Marshal.dump(conditions)) + ' and ' end con << ""(parent_id=#{node_id.to_i})"" tree[node_id] = klass.where(con).order(order_by).to_a tree[node_id].each do |node| tree = klass.get_tree(tree, conditions, node.id.to_s) end return tree end"
920,"def add_statistics_group Log.add_info(request, params.inspect) current_id = params[:current_id] if !params[:thetisBoxSelKeeper].nil? group_id = params[:thetisBoxSelKeeper].split(':').last end if group_id.nil? or group_id.empty? @group_ids = Research.get_statistics_groups render(:partial => 'ajax_statistics_groups', :layout => false) return end unless current_id.nil? or current_id.empty? Research.delete_statistics_group current_id end @group_ids = Research.add_statistics_group group_id render(:partial => 'ajax_statistics_groups', :layout => false) end",True,Ruby,add_statistics_group,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_comment_of(item_id, user_id) SqlHelper.validate_token([item_id, user_id]) begin comment = Comment.where(""(user_id=#{user_id.to_i}) and (item_id=#{item_id.to_i}) and (xtype='#{Comment::XTYPE_DIST_ACK}')"").first rescue => evar Log.add_error(nil, evar) end return comment end"
922,"def update_groups_order Log.add_info(request, params.inspect) order_ary = params[:groups_order] Research.set_statistics_groups order_ary render(:text => '') end",True,Ruby,update_groups_order,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.count_ack_users(item_id) SqlHelper.validate_token([item_id]) return Comment.where(""(item_id=#{item_id.to_i}) and (xtype='#{Comment::XTYPE_DIST_ACK}')"").count end"
924,"def reset_users Log.add_info(request, params.inspect) count = 0 unless params[:check_user].nil? params[:check_user].each do |user_id, value| if value == '1' begin Research.destroy_all('user_id=' + user_id.to_s) count += 1 rescue => evar Log.add_error(request, evar) end end end end if count > 0 flash[:notice] = t('msg.status_of')+ count.to_s + t('user.status_reset') end redirect_to(:controller => 'researches', :action => 'users') rescue => evar Log.add_error(request, evar) render(:text => evar.to_s) end",True,Ruby,reset_users,researches_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.count_completed_users(item_id) SqlHelper.validate_token([item_id]) ack_msg = ZeptairDistHelper.completed_ack_message(item_id) return Comment.where(""(item_id=#{item_id.to_i}) and (xtype='#{Comment::XTYPE_DIST_ACK}') and (message='#{ack_msg}')"").count end"
933,"def group Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end @group_id = params[:id] group_users = Group.get_users(params[:id]) @user_schedule_hash = {} unless group_users.nil? @holidays = Schedule.get_holidays group_users.each do |user| @user_schedule_hash[user.id.to_s] = Schedule.get_somebody_week(@login_user, user.id, @date, @holidays) end end params[:display] = params[:action] + '_' + params[:id] end",True,Ruby,group,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.trim_by_capacity(user_id, mail_account_id, capacity_mb) # FEATURE_MAIL_STRICT_CAPACITY >>> # FEATURE_MAIL_STRICT_CAPACITY <<< end"
934,"def team Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end begin team = Team.find(params[:id]) team_users = team.get_users_a rescue => evar Log.add_error(request, evar) end @user_schedule_hash = {} unless team_users.nil? @holidays = Schedule.get_holidays team_users.each do |user_id| @user_schedule_hash[user_id] = Schedule.get_somebody_week(@login_user, user_id, @date, @holidays) end end params[:display] = params[:action] + '_' + params[:id] end",True,Ruby,team,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.trim(user_id, mail_account_id, max) SqlHelper.validate_token([user_id, mail_account_id]) begin count = Email.where(""mail_account_id=#{mail_account_id.to_i}"").count if count > max #logger.fatal(""[INFO] Email.trim(user_id:#{user_id}, mail_account_id:#{mail_account_id}, max:#{max})"") over_num = count - max emails = [] # First, empty Trashbox user = User.find(user_id) trashbox = MailFolder.get_for(user, mail_account_id, MailFolder::XTYPE_TRASH) trash_nodes = [trashbox.id.to_s] trash_nodes += MailFolder.get_childs(trash_nodes.first, true, false) con = ""mail_folder_id in (#{trash_nodes.join(',')})"" emails = Email.where(con).order('updated_at ASC').limit(over_num).to_a # Now, remove others if emails.length < over_num over_num -= emails.length emails += Email.where(""mail_account_id=#{mail_account_id.to_i}"").order('updated_at ASC').limit(over_num).to_a end emails.each do |email| email.destroy end end rescue end end"
936,"def save Log.add_info(request, params.inspect) date = Date.parse(params[:date]) unless params[:id].blank? begin schedule = Schedule.find(params[:id]) rescue => evar Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('msg.already_deleted', :name => Schedule.model_name.human) redirect_to(:action => 'day', :date => date.strftime(Schedule::SYS_DATE_FORM)) return end unless schedule.check_user_auth(@login_user, 'w', true) Log.add_check(request, '[Schedule.check_user_auth]'+request.to_s) if @login_user.nil? check_login else redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') end return end end if params[:users].blank? \ and params[:groups].blank? \ and params[:teams].blank? \ and (params[:schedule][:scope] != Schedule::SCOPE_ALL) nearest_day = schedule.get_nearest_day(date) schedule.destroy unless schedule.nil? else [:users, :groups, :teams, :items].each do |attr| if params[attr].blank? params[:schedule][attr] = nil else params[:schedule][attr] = '|' + params[attr].join('|') + '|' end end equipment_ids = (params[:equipment] || []) equipment_ids.delete('') if equipment_ids.empty? params[:schedule][:equipment] = nil else equipment_ids.each do |equipment_id| equipment = Equipment.find(equipment_id) if equipment.nil? or !equipment.is_accessible_by(@login_user) flash[:notice] = 'ERROR:' + t('msg.need_auth_to_access') + t('cap.suffix') + Equipment.get_name(equipment_id) redirect_to(:action => 'day', :date => params[:date]) return end end params[:schedule][:equipment] = '|' + equipment_ids.join('|') + '|' end if params[:is_repeat] == '1' if params[:repeat_rules].blank? params[:schedule][:repeat_rule] = nil else params[:schedule][:repeat_rule] = '|' + params[:repeat_rules].join('|') + '|' end if params[:excepts].blank? params[:schedule][:except] = nil else excepts = params[:excepts] excepts.sort! excepts.reverse! params[:schedule][:except] = '|' + excepts.join('|') + '|' end else params[:schedule][:repeat_rule] = nil params[:schedule][:repeat_start] = nil params[:schedule][:repeat_end] = nil params[:schedule][:except] = nil end params[:schedule][:end] = SchedulesHelper.regularize(params[:schedule][:end]) check_schedule = Schedule.new(params.require(:schedule).permit(Schedule::PERMIT_BASE)) nearest_day = check_schedule.get_nearest_day(date) if nearest_day.nil? check_schedule.id = params[:id].to_i unless params[:id].nil? or params[:id].empty? flash[:notice] = 'ERROR:' + t('schedule.no_day_in_rule') if params[:fwd_controller].nil? or params[:fwd_controller].empty? self.index else prms = ApplicationHelper.get_fwd_params(params) prms.delete('id') prms.delete('schedule') prms[:controller] = params[:fwd_controller] prms[:action] = params[:fwd_action] redirect_to(prms) end # redirect_to(:action => 'day', :date => params[:date]) return end created = false if schedule.nil? or params[:repeat_update_target] == 'each' # Create params[:schedule][:created_by] = @login_user.id params[:schedule][:created_at] = Time.now schedule = Schedule.new(params.require(:schedule).permit(Schedule::PERMIT_BASE)) schedule.save! created = true else # Update params[:schedule][:updated_by] = @login_user.id params[:schedule][:updated_at] = Time.now schedule.update_attributes(params.require(:schedule).permit(Schedule::PERMIT_BASE)) end if params[:repeat_update_target] == 'each' # Update original repeated schedule org_schedule = Schedule.find(params[:id]) attrs = ActionController::Parameters.new() attrs[:updated_by] = @login_user.id attrs[:updated_at] = Time.now excepts = org_schedule.get_excepts_a excepts << params[:date] excepts.sort! excepts.reverse! attrs[:except] = '|' + excepts.join('|') + '|' org_schedule.update_attributes(attrs.permit(Schedule::PERMIT_BASE)) end # prms = {:show_id => schedule.id} end if created flash[:notice] = t('msg.register_success') else flash[:notice] = t('msg.update_success') end params[:date] = nearest_day.strftime(Schedule::SYS_DATE_FORM) if params[:fwd_controller].blank? self.index self.show unless self.performed? else prms = ApplicationHelper.get_fwd_params(params) prms.delete('id') prms.delete('schedule') prms[:controller] = params[:fwd_controller] prms[:action] = params[:fwd_action] redirect_to(prms) end rescue => evar Log.add_error(request, evar) date = Date.parse(params[:date]) redirect_to(:action => 'day', :date => date.strftime(Schedule::SYS_DATE_FORM)) end",True,Ruby,save,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.destroy_by_user(user_id, add_con=nil) SqlHelper.validate_token([user_id]) con = ""(user_id=#{user_id.to_i})"" con << "" and (#{add_con})"" unless add_con.nil? or add_con.empty? emails = Email.where(con).to_a emails.each do |email| email.destroy end end"
941,"def get_folder_items Log.add_info(request, params.inspect) unless params[:thetisBoxSelKeeper].nil? or params[:thetisBoxSelKeeper].empty? @folder_id = params[:thetisBoxSelKeeper].split(':').last end begin if Folder.check_user_auth(@folder_id, @login_user, 'r', true) @items = Folder.get_items(@login_user, @folder_id) end rescue => evar Log.add_error(request, evar) end submit_url = url_for(:controller => 'schedules', :action => 'get_folder_items') render(:partial => 'common/select_items', :layout => false, :locals => {:target_attr => :id, :submit_url => submit_url}) end",True,Ruby,get_folder_items,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_tree(folder_tree, conditions, parent, admin) if parent.instance_of?(Folder) tree_id = parent.id.to_s else tree_id = parent.to_s parent = nil if tree_id != '0' begin parent = Folder.find(tree_id) rescue end return folder_tree if parent.nil? end end group_obj_cache = {} folder_tree[tree_id] = [] if !parent.nil? and (parent.xtype == Folder::XTYPE_GROUP) Group.get_childs(parent.owner_id, false, true).each do |group| group_obj_cache[group.id] = group con = Marshal.load(Marshal.dump(conditions)) unless conditions.nil? if con.nil? con = '' else con << ' and ' end con << ""(xtype='#{Folder::XTYPE_GROUP}') and (owner_id=#{group.id})"" begin group_folder = Folder.where(con).first rescue => evar Log.add_error(nil, evar) end unless group_folder.nil? folder_tree[tree_id] << group_folder end end end con = Marshal.load(Marshal.dump(conditions)) unless conditions.nil? if con.nil? con = '' else con << ' and ' end con << ""parent_id=#{tree_id.to_i}"" folder_tree[tree_id] += Folder.where(con).order('xorder ASC, id ASC').to_a delete_ary = [] folder_tree[tree_id].each do |folder| if !admin and (folder.xtype == Folder::XTYPE_SYSTEM) delete_ary << folder next end if (tree_id == '0') and (folder.xtype == Folder::XTYPE_GROUP) group = Group.find_with_cache(folder.owner_id, group_obj_cache) unless group.nil? if group.parent_id != 0 delete_ary << folder next end end end folder_tree = Folder.get_tree(folder_tree, conditions, folder, admin) end folder_tree[tree_id] -= delete_ary return folder_tree end"
943,"def day Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end if params[:user_id].blank? user_id = @login_user.id unless @login_user.nil? @schedules = Schedule.get_user_day(@login_user, @date) else user_id = params[:user_id].to_i @schedules = Schedule.get_somebody_day(@login_user, user_id, @date) end schedule_id = nil schedule_id = params[:show_id] unless params[:show_id].nil? schedule_id = params[:edit_id] unless params[:edit_id].nil? unless schedule_id.nil? begin @schedule = Schedule.find(schedule_id) unless @schedule.check_user_auth(@login_user, 'r', true) Log.add_check(request, '[Schedule.check_user_auth]'+request.to_s) if @login_user.nil? check_login else redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') end return end rescue end end if !@login_user.nil? and user_id == @login_user.id and !@schedules.nil? equip_ary = [] @schedules.each do |schedule| equip_ary = equip_ary | schedule.get_equipment_a end overlap_h = {} equip_ary.each do |equip_id| schedule_ary = Schedule.get_equipment_day(equip_id, @date) overlaps = Schedule.check_overlap_equipment(equip_id, schedule_ary, @date) unless overlaps.empty? overlap_h[equip_id] = overlaps end end unless overlap_h.empty? flash[:notice] = 'ERROR:' + t('schedule.conflict_equipment') flash[:notice] << '<br/>' overlap_h.each do |equip_id, schedule_ary| flash[:notice] << '&laquo;' + Equipment.get_name(equip_id) + '&raquo;<br/>' flash[:notice] << '<ul style=\'padding-left:40px;\'>' schedule_ary.each do |schedule_id| flash[:notice] << '<li>' + Schedule.get_title(schedule_id) + '</li>' end flash[:notice] << '</ul>' end end end params[:display] = 'day' end",True,Ruby,day,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_tree_by_group_for_admin(group_id) SqlHelper.validate_token([group_id]) folder_tree = {} tree_id = '0' if group_id.to_s == '0' sql = 'select distinct * from folders' where = "" where (parent_id=#{tree_id.to_i})"" where << "" and ((xtype is null) or not((xtype='#{XTYPE_GROUP}') or (xtype='#{XTYPE_USER}')))"" order_by = ' order by xorder ASC, id ASC' else sql = 'select distinct Folder.* from folders Folder, users User' where = "" where (Folder.parent_id=#{tree_id.to_i})"" where << ' and (' where << ""((Folder.xtype='#{XTYPE_GROUP}') and (Folder.owner_id=#{group_id.to_i}))"" where << ' or ' where << ""((Folder.xtype='#{XTYPE_USER}') and (Folder.owner_id=User.id) and #{SqlHelper.get_sql_like(['User.groups'], ""|#{group_id}|"")})"" where << ' )' order_by = ' order by Folder.xorder ASC, Folder.id ASC' end sql << where + order_by folder_tree[tree_id] = Folder.find_by_sql(sql) folder_tree[tree_id].each do |folder| folder_tree = Folder.get_tree(folder_tree, nil, folder, true) end return Folder.sort_tree(folder_tree) end"
944,"def week Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today else @date = Date.parse(date_s) end params[:display] = 'week' end",True,Ruby,week,schedules_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_childs(folder_id, conditions, recursive, admin, ret_obj) SqlHelper.validate_token([folder_id]) arr = [] if recursive folder_tree = Folder.get_tree(Hash.new, conditions, folder_id, admin) return [] if folder_tree.nil? folder_tree.each do |parent_id, childs| if ret_obj arr |= childs else childs.each do |folder| folder_id = folder.id.to_s arr << folder_id unless arr.include?(folder_id) end end end else con = Marshal.load(Marshal.dump(conditions)) if con.nil? con = '' else con << ' and ' end con << ""parent_id=#{folder_id.to_i}"" unless admin con << "" and (xtype is null or not (xtype='#{Folder::XTYPE_SYSTEM}'))"" end folders = Folder.where(con).order('xorder ASC').to_a if ret_obj arr = folders else folders.each do |folder| arr << folder.id.to_s end end end return arr end"
949,"def new Log.add_info(request, params.inspect) mail_account_id = params[:mail_account_id] if mail_account_id.nil? or mail_account_id.empty? account_xtype = params[:mail_account_xtype] @mail_account = MailAccount.get_default_for(@login_user.id, account_xtype) else @mail_account = MailAccount.find(mail_account_id) if @mail_account.user_id != @login_user.id flash[:notice] = 'ERROR:' + t('msg.need_to_be_owner') render(:partial => 'common/flash_notice', :layout => false) return end end if $thetis_config[:menu]['disp_user_list'] == '1' unless params[:to_user_ids].blank? @email = Email.new to_addrs = [] @user_obj_cache ||= {} params[:to_user_ids].each do |user_id| user = User.find_with_cache(user_id, @user_obj_cache) user_emails = user.get_emails_by_type(nil) user_emails.each do |user_email| disp = EmailsHelper.format_address_exp(user.get_name, user_email, false) entry_val = ""#{disp}"" # ""#{disp}#{Email::ADDR_ORDER_SEPARATOR}#{user.get_xorder(@group_id)}"" to_addrs << entry_val end end @email.to_addresses = to_addrs.join(Email::ADDRESS_SEPARATOR) end end render(:action => 'edit', :layout => (!request.xhr?)) end",True,Ruby,new,send_mails_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_group_folder(group_id) SqlHelper.validate_token([group_id]) begin return Folder.where(""(owner_id=#{group_id.to_i}) and (xtype='#{Folder::XTYPE_GROUP}')"").first rescue => evar Log.add_error(nil, evar) return nil end end"
954,"def check_member return if params[:id].nil? or params[:id].empty? or @login_user.nil? if Item.find(params[:id]).user_id != @login_user.id Log.add_check(request, '[check_member]'+request.to_s) flash[:notice] = t('team.need_to_be_member') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_member,teams_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for_group(group_id) SqlHelper.validate_token([group_id]) if group_id.nil? con = 'group_id is null' else con = ""group_id=#{group_id.to_i}"" end Location.do_expire(con) return Location.where(con).to_a end"
960,"def create_workflow Log.add_info(request, params.inspect) @tmpl_folder, @tmpl_workflows_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_WORKFLOWS) @group_id = params[:group_id] if @group_id.nil? or @group_id.empty? @group_id = '0' # '0' for ROOT elsif @group_id == '0' ; else group = nil begin group = Group.find(@group_id) rescue end if group.nil? render(:text => 'ERROR:' + t('msg.already_deleted', :name => Group.model_name.human)) return end end unless @tmpl_workflows_folder.nil? item = Item.new_workflow(@tmpl_workflows_folder.id) item.title = t('workflow.new') item.user_id = 0 item.save! workflow = Workflow.new workflow.item_id = item.id workflow.user_id = 0 workflow.status = Workflow::STATUS_NOT_APPLIED if @group_id == '0' workflow.groups = nil else workflow.groups = '|' + @group_id + '|' end workflow.save! else Log.add_error(request, nil, '/'+TemplatesHelper::TMPL_ROOT+'/'+TemplatesHelper::TMPL_WORKFLOWS+' NOT found!') end render(:partial => 'groups/ajax_group_workflows', :layout => false) end",True,Ruby,create_workflow,templates_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_using_size(mail_account_id, add_con=nil) SqlHelper.validate_token([mail_account_id]) con = [] con << ""(mail_account_id=#{mail_account_id.to_i})"" con << ""(#{add_con})"" unless add_con.nil? or add_con.empty? return (Email.count_by_sql(""select SUM(size) from emails where #{con.join(' and ')}"") || 0) end"
962,"def destroy_workflow Log.add_info(request, params.inspect) Item.find(params[:id]).destroy @tmpl_folder, @tmpl_workflows_folder = TemplatesHelper.get_tmpl_subfolder(TemplatesHelper::TMPL_WORKFLOWS) @group_id = params[:group_id] if @group_id.nil? or @group_id.empty? @group_id = '0' # '0' for ROOT end render(:partial => 'groups/ajax_group_workflows', :layout => false) end",True,Ruby,destroy_workflow,templates_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.destroy_by_user(user_id, add_con=nil) SqlHelper.validate_token([user_id]) con = ""(user_id=#{user_id.to_i})"" con << "" and (#{add_con})"" unless add_con.nil? or add_con.empty? mail_accounts = MailAccount.where(con).to_a mail_accounts.each do |mail_account| mail_account.destroy end end"
964,"def update Log.add_info(request, params.inspect) if params[:id].nil? or params[:id].empty? @timecard = Timecard.new else @timecard = Timecard.find(params[:id]) end options = params[:timecard]['options'] if options.nil? params[:timecard]['options'] = nil else params[:timecard]['options'] = '|' + options.join('|') + '|' end if params[:user_id].nil? or params[:user_id].empty? @selected_user = @login_user elsif @login_user.id.to_s == params[:user_id] @selected_user = @login_user else unless @login_user.admin?(User::AUTH_TIMECARD) Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end @selected_user = User.find(params[:user_id]) end if Timecard.off?(params[:timecard]['workcode']) params[:timecard]['start'] = nil params[:timecard]['end'] = nil params[:timecard]['options'] = nil else breaks = @timecard.get_breaks_a unless breaks.empty? check_error = false unless params[:timecard]['start'].nil? or params[:timecard]['start'].empty? start_t = UtilDateTime.parse(params[:timecard]['start']).to_time check_error = true if breaks.first.first < start_t end unless params[:timecard]['end'].nil? or params[:timecard]['end'].empty? end_t = UtilDateTime.parse(params[:timecard]['end']).to_time check_error = true if end_t < breaks.last.last end if check_error flash[:notice] = 'ERROR:' + t('timecard.break_out_of_labor') render(:partial => 'ajax_update_break', :layout => false) return end end end if (@login_user.id.to_s != params[:timecard][:user_id] and !@login_user.admin?(User::AUTH_TIMECARD)) \ or (!@timecard.user_id.nil? and @timecard.user_id.to_s != params[:timecard][:user_id]) Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end if @timecard.update_attributes(params.require(:timecard).permit(Timecard::PERMIT_BASE)) if @timecard.off? and !@timecard.get_breaks_a.empty? @timecard.update_breaks(nil) end flash[:notice] = t('msg.update_success') unless @timecard.start.nil? or @timecard.end.nil? @timecard.set_default_breaks end end",True,Ruby,update,timecards_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_default_for(user_id, xtype=nil) SqlHelper.validate_token([user_id, xtype]) con = [] con << ""(user_id=#{user_id.to_i})"" con << '(is_default=1)' con << ""(xtype='#{xtype}')"" unless xtype.blank? where = '' unless con.nil? or con.empty? where = 'where ' + con.join(' and ') end mail_accounts = MailAccount.find_by_sql('select * from mail_accounts ' + where + ' order by xorder ASC, title ASC') if mail_accounts.nil? or mail_accounts.empty? return nil else return mail_accounts.first end end"
969,"def update_config Log.add_info(request, params.inspect) yaml = ApplicationHelper.get_config_yaml unless params[:timecard].nil? or params[:timecard].empty? yaml[:timecard] = Hash.new if yaml[:timecard].nil? params[:timecard].each do |key, val| yaml[:timecard][key] = val end ApplicationHelper.save_config_yaml(yaml) end @yaml_timecard = yaml[:timecard] @yaml_timecard = Hash.new if @yaml_timecard.nil? flash[:notice] = t('msg.update_success') render(:action => 'configure') end",True,Ruby,update_config,timecards_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(mail_account_id, enabled=nil, trigger=nil) return [] if mail_account_id.nil? SqlHelper.validate_token([mail_account_id, trigger]) con = [] con << ""(mail_account_id=#{mail_account_id.to_i})"" con << ""(enabled=#{(enabled)?(1):(0)})"" unless enabled.nil? con << SqlHelper.get_sql_like([:triggers], ""|#{trigger}|"") unless trigger.nil? return MailFilter.where(con.join(' and ')).order('(xorder is null) ASC, xorder ASC, id ASC').to_a end"
975,"def group Log.add_info(request, params.inspect) date_s = params[:date] if date_s.nil? or date_s.empty? @date = Date.today date_s = @date.strftime(Schedule::SYS_DATE_FORM) else @date = Date.parse date_s end if params[:display] == 'mine' redirect_to(:action => 'month') else display_type = params[:display].split('_').first display_id = params[:display].split('_').last @selected_users = Group.get_users(display_id) @group_id = display_id if !@login_user.get_groups_a.include?(@group_id.to_s) and !@login_user.admin?(User::AUTH_TIMECARD) Log.add_check(request, '[User.get_groups_a.include?]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end end end",True,Ruby,group,timecards_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_account_roots_for(user) return nil if user.nil? if user.kind_of?(User) user_id = user.id else user_id = user.to_s end SqlHelper.validate_token([user_id]) con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(xtype='#{MailFolder::XTYPE_ACCOUNT_ROOT}')"" order_by = 'xorder ASC, id ASC' return MailFolder.where(con.join(' and ')).order(order_by).to_a end"
977,"def month if params[:action] == 'month' Log.add_info(request, params.inspect) end if !params[:display].nil? and params[:display].split('_').first == 'group' @group_id = params[:display].split('_').last end if params[:user_id].nil? @selected_user = @login_user else @selected_user = User.find(params[:user_id]) if @selected_user.id != @login_user.id and !@login_user.admin?(User::AUTH_TIMECARD) if (@selected_user.get_groups_a & @login_user.get_groups_a).empty? Log.add_check(request, '[User::AUTH_TIMECARD]'+request.to_s) redirect_to(:controller => 'frames', :action => 'http_error', :id => '401') return end end end year_begins_from, month_begins_at = TimecardsHelper.get_fiscal_params date_s = params[:date] if date_s.nil? or date_s.empty? date = Date.today else date_params = date_s.split('-') if date_params.length == 2 @year = date_params.first.to_i @month = date_params.last.to_i date = TimecardsHelper.get_first_day_in_fiscal_month(@year, @month, month_begins_at) else date = Date.parse date_s end end @fiscal_year = TimecardsHelper.get_fiscal_year(date, year_begins_from, month_begins_at) fiscal_month = TimecardsHelper.get_fiscal_month(date, month_begins_at) if @year.nil? or @month.nil? @month = fiscal_month if fiscal_month < date.month and fiscal_month == 1 @year = date.year + 1 elsif fiscal_month > date.month and fiscal_month == 12 @year = date.year - 1 else @year = date.year end end @start_date, @end_date = TimecardsHelper.get_month_span(date, month_begins_at) @timecards = Timecard.find_term(@selected_user.id, @start_date, @end_date) @paid_holiday = PaidHoliday.get_for(@selected_user.id, @fiscal_year) year_start, year_end = TimecardsHelper.get_year_span(@fiscal_year, year_begins_from, month_begins_at) @applied_paid_hlds = Timecard.applied_paid_hlds(@selected_user.id, year_start, @start_date - 1) end",True,Ruby,month,timecards_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(user, mail_account_id, xtype) return nil if user.nil? or mail_account_id.blank? if user.kind_of?(User) user_id = user.id else user_id = user.to_s end SqlHelper.validate_token([user_id, mail_account_id, xtype]) con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(mail_account_id=#{mail_account_id.to_i})"" con << ""(xtype='#{xtype}')"" return MailFolder.where(con.join(' and ')).first end"
979,"def destroy Log.add_info(request, params.inspect) if params[:check_user].nil? list render(:action => 'list') return end count = 0 params[:check_user].each do |user_id, value| if value == '1' begin User.destroy(user_id) rescue => evar Log.add_error(request, evar) end count += 1 end end flash[:notice] = count.to_s + t('user.deleted') redirect_to(:action => 'list') end",True,Ruby,destroy,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for_group(group_id, incl_img_content=false) SqlHelper.validate_token([group_id]) if group_id.nil? office_map = nil else if incl_img_content office_map = OfficeMap.where(""group_id=#{group_id.to_i}"").first else sql = 'select id, group_id, img_enabled, img_name, img_size, img_content_type, created_at, updated_at from office_maps' sql << "" where group_id=#{group_id.to_i}"" begin office_map = OfficeMap.find_by_sql(sql).first rescue end end end if office_map.nil? office_map = OfficeMap.new office_map.group_id = group_id.to_i unless group_id.nil? office_map.img_enabled = false end return office_map end"
988,"def exclude_from_group Log.add_info(request, params.inspect) if params[:group_id].nil? or params[:group_id].empty? render(:partial => 'ajax_groups', :layout => false) return end group_id = params[:group_id] begin @user = User.find(params[:id]) unless @user.nil? if @user.exclude_from(group_id) @user.save if @user.id == @login_user.id @login_user = @user end end end rescue => evar Log.add_error(request, evar) end render(:partial => 'ajax_groups', :layout => false) end",True,Ruby,exclude_from_group,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(group_id, include_parents=false, enabled=nil) SqlHelper.validate_token([group_id]) con = [] #con << ""(disabled=#{!enabled})"" unless enabled.nil? if include_parents group_con = '(group_id is null)' unless group_id.nil? or group_id.to_s == '0' group_obj_cache = {} group = Group.find_with_cache(group_id, group_obj_cache) group_ids = group.get_parents(false, group_obj_cache) group_ids << group_id group_con << "" or (group_id in (#{group_ids.join(',')}))"" end con << '(' + group_con + ')' else con << ""(group_id=#{group_id.to_i})"" end order_by = 'order by xorder ASC, id ASC' #order_by = 'order by disabled ASC, xorder ASC, id ASC' sql = 'select * from official_titles where ' + con.join(' and ') + ' ' + order_by return OfficialTitle.find_by_sql(sql) end"
989,"def create_title titles = User.get_config_titles titles = [] if titles.nil? titles << t('user.new_title') User.save_config_titles titles render(:partial => 'ajax_title', :layout => false) end",True,Ruby,create_title,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.update_for(user_id, fiscal_year, num) SqlHelper.validate_token([user_id, fiscal_year]) if num <= 0 con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(year=#{fiscal_year.to_i})"" PaidHoliday.destroy_all(con.join(' and ')) return end paid_holiday = PaidHoliday.get_for(user_id, fiscal_year) if paid_holiday.nil? paid_holiday = PaidHoliday.new paid_holiday.user_id = user_id paid_holiday.year = fiscal_year paid_holiday.num = num paid_holiday.save! else paid_holiday.update_attribute(:num, num) end end"
990,"def _process_user_attrs(user, attrs) if attrs[:birthday].nil? begin attrs[:birthday] = attrs[:birthday_y] + '-' + attrs[:birthday_m] + '-' + attrs[:birthday_d] rescue end attrs.delete(:birthday_y) attrs.delete(:birthday_m) attrs.delete(:birthday_d) end if !attrs[:name].nil? or !attrs[:password].nil? user_name = attrs[:name] user_name ||= user.name unless user.nil? password = attrs[:password] if password.nil? or password.empty? password = UsersHelper.generate_password attrs[:password] = password end attrs[:pass_md5] = UsersHelper.generate_digest_pass(user_name, password) end return attrs end",True,Ruby,_process_user_attrs,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_carried_over(user_id, year) SqlHelper.validate_token([user_id, year]) yaml = ApplicationHelper.get_config_yaml unless yaml[:timecard].nil? paidhld_carry_over = yaml[:timecard]['paidhld_carry_over'] end return 0 if paidhld_carry_over.nil? or paidhld_carry_over.empty? or paidhld_carry_over == PaidHoliday::CARRY_OVER_NONE begin con = ""(user_id=#{user_id.to_i}) and (year < #{year.to_i})"" paidhlds = PaidHoliday.where(con).order('year ASC').to_a rescue end return 0 if paidhlds.nil? or paidhlds.empty? sum = 0 year_begins_from, month_begins_at = TimecardsHelper.get_fiscal_params if paidhld_carry_over == PaidHoliday::CARRY_OVER_1_YEAR last_carried_out = 0 for y in paidhlds.first.year .. year - 1 paidhld = paidhlds.find { |hld| hld.year == y } given_num = (paidhld.nil?)?0:paidhld.num start_date, end_date = TimecardsHelper.get_year_span(y, year_begins_from, month_begins_at) applied_paid_hlds = Timecard.applied_paid_hlds(user_id, start_date, end_date) if applied_paid_hlds >= last_carried_out last_carried_out = given_num - (applied_paid_hlds - last_carried_out) else last_carried_out = given_num end end return last_carried_out elsif paidhld_carry_over == PaidHoliday::CARRY_OVER_NO_EXPIRATION paidhlds.each do |paidhld| sum += paidhld.num end start_date, dummy = TimecardsHelper.get_year_span(paidhlds.first.year, year_begins_from, month_begins_at) dummy, end_date = TimecardsHelper.get_year_span(year - 1, year_begins_from, month_begins_at) applied_paid_hlds = Timecard.applied_paid_hlds(user_id, start_date, end_date) return (sum - applied_paid_hlds) else return 0 end end"
991,"def add_to_group Log.add_info(request, params.inspect) if params[:thetisBoxSelKeeper].nil? or params[:thetisBoxSelKeeper].empty? render(:partial => 'ajax_groups', :layout => false) return end group_id = params[:thetisBoxSelKeeper].split(':').last unless group_id == '0' # '0' for ROOT begin group = Group.find(group_id) rescue => evar Log.add_error(request, evar) ensure if group.nil? render(:partial => 'ajax_groups', :layout => false) return end end end begin @user = User.find(params[:user_id]) rescue => evar Log.add_error(request, evar) end unless @user.nil? is_modified = false # Change, not simply Add unless params[:current_id] == nil or params[:current_id].empty? if @user.exclude_from(params[:current_id]) is_modified = true end end is_modified = true if @user.add_to(group_id) if is_modified == true # @user.update_attribute(:groups, @user.groups) @user.save! if @user.id == @login_user.id @login_user = @user end end end render(:partial => 'ajax_groups', :layout => false) end",True,Ruby,add_to_group,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(user_id, fiscal_year=nil) SqlHelper.validate_token([user_id, fiscal_year]) begin con = [] con << ""(user_id=#{user_id.to_i})"" if fiscal_year.nil? return PaidHoliday.where(con).order('year ASC').to_a else con << ""(year=#{fiscal_year.to_i})"" return PaidHoliday.where(con.join(' and ')).first end rescue end return nil end"
994,"def import_csv Log.add_info(request, params.inspect) file = params[:imp_file] mode = params[:mode] enc = params[:enc] all_users = User.find_all user_names = [] # user_emails = [] if mode == 'add' all_users.each do |user| user_names << user.name # user_emails << user.email end end @imp_errs = {} count = -1 # 0 for Header-line users = [] opt = { :skip_blanks => true } csv = file.read begin csv.encode!(Encoding::UTF_8, enc, {:invalid => :replace, :undef => :replace, :replace => ' '}) rescue => evar Log.add_error(request, evar) end found_update = false CSV.parse(csv, opt) do |row| unless row.first.nil? next if row.first.lstrip.index('#') == 0 end next if row.compact.empty? count += 1 next if count == 0 # for Header Line user = User.parse_csv_row(row) check = user.check_import(mode, user_names) #, user_emails @imp_errs[count] = check unless check.empty? users << user if mode == 'update' update_user = all_users.find do |u| u.id == user.id end unless update_user.nil? all_users.delete(update_user) found_update = true end end end if users.empty? @imp_errs[0] = [t('user.nothing_to_import')] else if mode == 'update' if found_update user_admin = users.find do |user| user.admin?(User::AUTH_USER) end if user_admin.nil? @imp_errs[0] = [t('user.no_user_auth_import')] end else @imp_errs[0] = [t('user.nothing_to_update')] end end end # Create or Update count = 0 @imp_cnt = 0 if @imp_errs.empty? users.each do |user| count += 1 begin user_id = user.id user.save! if user_id.nil? user.setup end @imp_cnt += 1 rescue => evar @imp_errs[count] = [t('user.failed_to_save') + evar.to_s] end end end # Delete # Actually, the correct order of the process is Delete -> Create, # not to duplicate a User Name. # 3: morita <- Delete # : morita <- Create # But such a case is most likely to be considered as a # user's miss-operation. We can avoid this case with # 'opposite' process. del_cnt = 0 if @imp_errs.empty? and mode == 'update' all_users.each do |user| user.destroy del_cnt += 1 end end # Set order to display User.update_xorder(nil, User::XORDER_MAX) titles = User.get_config_titles unless titles.nil? idx = 0 titles.each do |title| User.update_xorder title, idx idx += 1 end end if @imp_errs.empty? flash[:notice] = users.length.to_s + t('user.imported') if del_cnt > 0 flash[:notice] << '<br/>' + del_cnt.to_s + t('user.deleted') end end list render(:action => 'list') end",True,Ruby,import_csv,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(user_id) SqlHelper.validate_token([user_id]) return Research.where(""user_id=#{user_id.to_i}"").first end"
997,"def update_auth Log.add_info(request, params.inspect) return unless request.post? auth = nil if params[:check_auth_all] == '1' auth = User::AUTH_ALL else auth_selected = params[:auth_selected] unless auth_selected.nil? or auth_selected.empty? auth = '|' + auth_selected.join('|') + '|' end if auth_selected.nil? or !auth_selected.include?(User::AUTH_USER) user_admin_err = false user_admins = User.where(""auth like '%|#{User::AUTH_USER}|%' or auth='#{User::AUTH_ALL}'"").to_a if user_admins.nil? or user_admins.empty? user_admin_err = true elsif user_admins.length == 1 if user_admins.first.id.to_s == params[:id] user_admin_err = true end end if user_admin_err render(:text => t('user.no_user_auth')) return end end end begin user = User.find(params[:id]) rescue => evar Log.add_error(request, evar) end if user.nil? render(:text => t('msg.already_deleted', :name => User.model_name.human)) else user.update_attribute(:auth, auth) if user.id == @login_user.id @login_user = user end render(:text => '') end end",True,Ruby,update_auth,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_group_value(group_id, category, key) SqlHelper.validate_token([group_id, category, key]) con = [] con << ""(group_id=#{group_id.to_i})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first return setting.xvalue unless setting.nil? return nil end"
1000,"def rename_title Log.add_info(request, params.inspect) org_title = params[:org_title] new_title = params[:new_title] if org_title.nil? or new_title.nil? or org_title == new_title render(:partial => 'ajax_title', :layout => false) return end titles = User.get_config_titles unless titles.nil? if titles.include?(new_title) flash[:notice] = 'ERROR:' + t('user.title_duplicated') else idx = titles.index(org_title) unless idx.nil? titles[idx] = new_title User.save_config_titles titles User.rename_title(org_title, new_title) User.update_xorder(new_title, idx) end end end render(:partial => 'ajax_title', :layout => false) end",True,Ruby,rename_title,users_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_value(user_id, category, key) SqlHelper.validate_token([user_id, category, key]) con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first return setting.xvalue unless setting.nil? return nil end"
1008,"def check_owner return if params[:id].nil? or params[:id].empty? or @login_user.nil? begin owner_id = Workflow.find(params[:id]).user_id rescue owner_id = -1 end if !@login_user.admin?(User::AUTH_WORKFLOW) and owner_id != @login_user.id Log.add_check(request, '[check_owner]'+request.to_s) flash[:notice] = t('msg.need_to_be_owner') redirect_to(:controller => 'desktop', :action => 'show') end end",True,Ruby,check_owner,workflows_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.save_group_value(group_id, category, key, value) SqlHelper.validate_token([group_id, category, key]) con = [] con << ""(group_id=#{group_id.to_i})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first if value.nil? unless setting.nil? setting.destroy end else if setting.nil? setting = Setting.new setting.group_id = group_id setting.category = category setting.xkey = key setting.xvalue = value setting.save! else setting.update_attribute(:xvalue, value) end end end"
1010,"def reply Log.add_info(request, '') # Not to show passwords. unless params[:attach_id].nil? or params[:attach_id].empty? target = Attachment.find(params[:attach_id]) end unless params[:cmd_id].nil? or params[:cmd_id].empty? target = ZeptairCommand.find(params[:cmd_id]) end if target.nil? or target.item.nil? \ or target.item.xtype != Item::XTYPE_ZEPTAIR_DIST render(:text => 'ERROR:' + t('msg.system_error')) return end item = target.item comment = ZeptairDistHelper.get_comment_of(item.id, @login_user.id) case params[:status] when ZeptairDistHelper::ENTRY_STATUS_SAVED, ZeptairDistHelper::ENTRY_STATUS_EXECUTED, ZeptairDistHelper::ENTRY_STATUS_ERROR new_entry = ""#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}#{params[:timestamp]}#{ZeptairDistHelper::ACK_TS_SEP}#{params[:status]}"" if comment.nil? comment = Comment.new comment.user_id = @login_user.id comment.item_id = item.id comment.xtype = Comment::XTYPE_DIST_ACK comment.message = new_entry + ""\n"" comment.save! else class_order = {'Attachment' => 0, 'ZeptairCommand' => 1} target_order = class_order[target.class.to_s] entries = ZeptairDistHelper.get_ack_array_of(comment) unless entries.include?(new_entry) msg = '' inserted = false entries.each do |entry| next if entry.nil? or entry.empty? regexp = Regexp.new(""^([a-zA-Z]+)#{ZeptairDistHelper::ACK_CLASS_SEP}(\\d+)[#{ZeptairDistHelper::ACK_ID_SEP}]"") matched_ary = entry.scan(regexp) next if matched_ary.nil? matched_ary = matched_ary.flatten next if matched_ary.length < 2 entry_class = matched_ary.first entry_order = class_order[entry_class] entry_id = matched_ary.last.to_i if entry_class == target.class.to_s \ and entry_id == target.id msg << new_entry + ""\n"" inserted = true elsif !inserted \ and \ ((entry_class == target.class.to_s and target.id < entry_id) \ or (entry_class != target.class.to_s and target_order < entry_order)) msg << new_entry + ""\n"" msg << entry + ""\n"" inserted = true else msg << entry + ""\n"" end end unless inserted msg << new_entry + ""\n"" end comment.update_attribute(:message, msg) end end when 'canceled' unless comment.nil? if comment.message.nil? entries = [] else entries = comment.message.split(""\n"") end msg = '' exp = ""^#{target.class}#{ZeptairDistHelper::ACK_CLASS_SEP}#{target.id}#{ZeptairDistHelper::ACK_ID_SEP}"" entries.each do |entry| next if entry.nil? or entry.empty? if entry.match(exp).nil? msg << entry + ""\n"" end end if msg.empty? comment.destroy else comment.update_attribute(:message, msg) end end end",True,Ruby,reply,zeptair_dist_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(user_id, category=nil) SqlHelper.validate_token([user_id, category]) con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(category='#{category}')"" unless category.nil? settings = Setting.where(con.join(' and ')).to_a return nil if settings.nil? or settings.empty? hash = Hash.new settings.each do |setting| hash[setting.xkey] = setting.xvalue end return hash end"
1011,"def delete_attachment Log.add_info(request, '') # Not to show passwords. target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] attachment_id = params[:attachment_id] SqlHelper.validate_token([user_id, zeptair_id, attachment_id]) unless user_id.blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == user_id.to_s target_user = User.find(user_id) end end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if attachment_id.blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(attachment_id) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end",True,Ruby,delete_attachment,zeptair_post_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.save_value(user_id, category, key, value) SqlHelper.validate_token([user_id, category, key]) con = [] con << ""(user_id=#{user_id.to_i})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first if value.nil? unless setting.nil? setting.destroy end else if setting.nil? setting = Setting.new setting.user_id = user_id setting.category = category setting.xkey = key setting.xvalue = value setting.save! else setting.update_attribute(:xvalue, value) end end end"
1021,def self.delete_statistics_group(group_id) yaml = Research.get_config_yaml if yaml.nil? or yaml[:statistics].nil? return [] end groups = yaml[:statistics][:groups] return [] if groups.nil? ary = groups.split('|') ary.delete group_id.to_s ary.compact! ary.delete '' yaml[:statistics][:groups] = ary.join('|') Research.save_config_yaml yaml return ary end,True,Ruby,self.delete_statistics_group,research.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for_group(group_id, category=nil) SqlHelper.validate_token([group_id, category]) con = [] con << ""(group_id=#{group_id.to_i})"" con << ""(category='#{category}')"" unless category.nil? settings = Setting.where(con.join(' and ')).to_a return nil if settings.nil? or settings.empty? hash = Hash.new settings.each do |setting| hash[setting.xkey] = setting.xvalue end return hash end"
1022,def self.add_statistics_group(group_id) yaml = Research.get_config_yaml yaml = Hash.new if yaml.nil? if yaml[:statistics].nil? yaml[:statistics] = Hash.new end groups = yaml[:statistics][:groups] if groups.nil? yaml[:statistics][:groups] = group_id ary = [group_id.to_s] else ary = groups.split('|') ary << group_id ary.compact! ary.delete '' yaml[:statistics][:groups] = ary.join('|') end Research.save_config_yaml yaml return ary end,True,Ruby,self.add_statistics_group,research.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def remove_application(user_ids) return if user_ids.nil? or user_ids.empty? SqlHelper.validate_token([user_ids]) con = [""(xtype='#{Comment::XTYPE_APPLY}')""] con << ""(item_id=#{self.item_id})"" user_con_a = [] user_ids.each do |user_id| user_con_a << ""(user_id=#{user_id.to_i})"" end con << '(' + user_con_a.join(' or ') + ')' Comment.destroy_all(con.join(' and ')) end"
1023,"def self.find_q_codes(html) q_hash = {} # |q_code, q_param| return q_hash if html.nil? all = Research.get_q_codes q_codes = html.scan(/[$](q\d{2}_\d{2})/) unless q_codes.nil? yaml = Research.get_config_yaml q_codes.each do |q_code_a| q_code = q_code_a.first if all.include?(q_code) if yaml[q_code].nil? q_hash[q_code] = nil else q_hash[q_code] = Marshal.load(Marshal.dump(yaml[q_code])) end end end end return q_hash end",True,Ruby,self.find_q_codes,research.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_team_folder(team_id) SqlHelper.validate_token([team_id]) begin return Folder.where(""(owner_id=#{team_id.to_i}) and (xtype='#{Folder::XTYPE_TEAM}')"").first rescue => evar Log.add_error(nil, evar) return nil end end"
1024,def self.set_statistics_groups(group_ids) yaml = Research.get_config_yaml yaml = Hash.new if yaml.nil? if group_ids.nil? unless yaml[:statistics].nil? yaml[:statistics].delete :groups end else if yaml[:statistics].nil? yaml[:statistics] = Hash.new end yaml[:statistics][:groups] = group_ids.join('|') end Research.save_config_yaml yaml return ary end,True,Ruby,self.set_statistics_groups,research.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-09 22:49:16+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_for(user_id, date_s) SqlHelper.validate_token([user_id, date_s]) begin con = ""(user_id=#{user_id.to_i}) and (date='#{date_s}')"" return Timecard.where(con).first rescue end return nil end"
1026,"def destroy Log.add_info(request, params.inspect) return unless request.post? begin Item.destroy(params[:id]) rescue => evar Log.add_error(request, evar) end if params[:from_action].nil? render(:text => params[:id]) else params.delete(:controller) params.delete(:action) params.delete(:id) flash[:notice] = t('msg.delete_success') params[:action] = params[:from_action] redirect_to(params) end end",True,Ruby,destroy,items_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.find_term(user_id, start_date, end_date) SqlHelper.validate_token([user_id]) start_s = start_date.strftime(Schedule::SYS_DATE_FORM) end_s = end_date.strftime(Schedule::SYS_DATE_FORM) con = ""(user_id=#{user_id.to_i}) and (date >= '#{start_s}') and (date <= '#{end_s}')"" ary = Timecard.where(con).order('date ASC').to_a timecards_h = Hash.new unless ary.nil? ary.each do |timecard| timecards_h[timecard.date.strftime(Schedule::SYS_DATE_FORM)] = timecard end end return timecards_h end"
1028,"def open_map Log.add_info(request, params.inspect) @group_id = nil if !params[:thetisBoxSelKeeper].nil? @group_id = params[:thetisBoxSelKeeper].split(':').last elsif !params[:group_id].blank? @group_id = params[:group_id] end SqlHelper.validate_token([@group_id]) unless params[:keyword].blank? con_prim = [] con_second = [] key_array = params[:keyword].split(nil) key_array.each do |key| key_quot = ActiveRecord::Base.connection.quote(key) con_prim << ""(name=#{key_quot} or fullname=#{key_quot} or email=#{key_quot})"" con_second << SqlHelper.get_sql_like([:name, :fullname, :email], key) end [con_prim, con_second].each do |con| next if con.empty? begin @target_user = User.where(con.join(' and ')).first rescue end next if @target_user.nil? target_location = Location.get_for(@target_user) unless target_location.nil? @group_id ||= target_location.group_id end break end end @location = Location.get_for(@login_user) unless @location.nil? @group_id ||= @location.group_id end group_ids = [] @group_obj_cache = {} if @location.nil? and @group_id.nil? group_ids = @login_user.get_groups_a(true, @group_obj_cache) group_ids << '0' # '0' for ROOT elsif !@group_id.nil? group_ids << @group_id if @group_id.to_i != 0 group = Group.find_with_cache(@group_id, @group_obj_cache) group_ids |= group.get_parents(false, @group_obj_cache) end end @map_group_id = nil group_ids.each do |grp_id| @office_map = OfficeMap.get_for_group(grp_id) if @office_map.img_enabled and (@office_map.img_size > 0) @map_group_id = @office_map.group_id break end end @locations = Location.get_for_group(@map_group_id) unless @location.nil? if @location.group_id == @map_group_id @location.update_attribute(:updated_at, Time.now) else @location = nil end end end",True,Ruby,open_map,locations_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.on_desktop?(user, xtype, target_id) return false if user.nil? or xtype.nil? or target_id.nil? SqlHelper.validate_token([xtype, target_id]) con = ""(user_id=#{user.id}) and (xtype='#{xtype}') and (target_id=#{target_id.to_i})"" begin toy = Toy.where(con).first rescue => evar Log.add_error(nil, evar) end return (!toy.nil?) end"
1029,"def copy Log.add_info(request, params.inspect) return unless request.post? tmpl_id = params[:thetisBoxSelKeeper].split(':').last tmpl_item = Item.find(tmpl_id) item = tmpl_item.copy(@login_user.id, @login_user.get_my_folder.id) if item.public != false item.update_attribute(:public, false) end redirect_to(:controller => 'items', :action => 'edit', :id => item.id) rescue => evar Log.add_error(request, evar) redirect_to(:controller => 'items', :action => 'new') end",True,Ruby,copy,templates_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.update_xorder(title, order) if title.nil? con = nil else con = ['title=?', title] end SqlHelper.validate_token([order]) User.update_all(""xorder=#{order.to_i}"", con) end"
1030,"def delete_attachment Log.add_info(request, '') # Not to show passwords. return unless request.post? target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] attachment_id = params[:attachment_id] SqlHelper.validate_token([user_id, zeptair_id, attachment_id]) unless user_id.blank? if @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id.to_s == user_id.to_s target_user = User.find(user_id) end end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first unless @login_user.admin?(User::AUTH_ZEPTAIR) or @login_user.id == target_user.id target_user = nil end end if target_user.nil? if attachment_id.blank? query unless @post_items.nil? @post_items.each do |post_item| post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end end else attach = Attachment.find(attachment_id) item = Item.find(attach.item_id) if !@login_user.admin?(User::AUTH_ZEPTAIR) and item.user_id != @login_user.id raise t('msg.need_to_be_owner') end if item.xtype != Item::XTYPE_ZEPTAIR_POST raise t('msg.system_error') end attach.destroy item.update_attribute(:updated_at, Time.now) end else post_item = ZeptairPostHelper.get_item_for(target_user) post_item.attachments_without_content.each do |attach| attach.destroy end post_item.update_attribute(:updated_at, Time.now) end render(:text => t('msg.delete_success')) rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end",True,Ruby,delete_attachment,zeptair_post_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_my_folder(user_id) SqlHelper.validate_token([user_id]) return Folder.where(""(owner_id=#{user_id.to_i}) and (xtype='#{Folder::XTYPE_USER}')"").first end"
1032,"def query Log.add_info(request, '') # Not to show passwords. unless @login_user.admin?(User::AUTH_ZEPTAIR) render(:text => 'ERROR:' + t('msg.need_to_be_admin')) return end target_user = nil user_id = params[:user_id] zeptair_id = params[:zeptair_id] group_id = params[:group_id] SqlHelper.validate_token([user_id, zeptair_id, group_id]) unless user_id.blank? target_user = User.find(user_id) end unless zeptair_id.blank? target_user = User.where(""zeptair_id=#{zeptair_id}"").first end if target_user.nil? if group_id.blank? sql = 'select distinct Item.* from items Item, attachments Attachment' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << ' order by Item.user_id ASC' else group_ids = [group_id] if params[:recursive] == 'true' group_ids += Group.get_childs(group_id, true, false) end groups_con = [] group_ids.each do |grp_id| groups_con << SqlHelper.get_sql_like(['User.groups'], ""|#{grp_id}|"") end sql = 'select distinct Item.* from items Item, attachments Attachment, users User' sql << "" where Item.xtype='#{Item::XTYPE_ZEPTAIR_POST}' and Item.id=Attachment.item_id"" sql << "" and (Item.user_id=User.id and (#{groups_con.join(' or ')}))"" sql << ' order by Item.user_id ASC' end @post_items = Item.find_by_sql(sql) else @post_item = ZeptairPostHelper.get_item_for(target_user) end rescue => evar Log.add_error(request, evar) render(:text => 'ERROR:' + t('msg.system_error')) end",True,Ruby,query,zeptair_post_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def send_password Log.add_info(request, params.inspect) mail_addr = params[:thetisBoxEdit] begin users = User.where(email: mail_addr).to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end"
1034,"def self.get_copies_folder(user_id) my_folder = User.get_my_folder(user_id) unless my_folder.nil? con = ""(parent_id=#{my_folder.id}) and (name='#{Item.copies_folder}')"" begin copies_folder = Folder.where(con).first rescue end if copies_folder.nil? folder = Folder.new folder.name = Item.copies_folder folder.parent_id = my_folder.id folder.owner_id = user_id.to_i folder.xtype = nil folder.read_users = '|' + user_id.to_s + '|' folder.write_users = '|' + user_id.to_s + '|' folder.save! copies_folder = folder end end return copies_folder end",True,Ruby,self.get_copies_folder,items_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.validate_token(tokens, extra_chars=nil) if extra_chars.nil? extra_chars = '' else extra_chars = Regexp.escape(extra_chars.join()) end regexp = Regexp.new(""^[ ]*[a-zA-Z0-9_#{extra_chars}]+[ ]*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? \ and token.to_s.match(/^[ ]*\d+-\d+-\d+[ ]*$/).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end"
1036,"def self.get_next_revision(user_id, source_id) SqlHelper.validate_token([user_id, source_id]) copied_items = Item.where(""user_id=#{user_id} and source_id=#{source_id}"").order('created_at DESC').to_a rev = 0 copied_items.each do |item| rev_ary = item.title.scan(/[#](\d\d\d)$/) next if rev_ary.nil? rev = rev_ary.first.to_a.first.to_i break end return ('#' + sprintf('%03d', rev+1)) end",True,Ruby,self.get_next_revision,items_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_by_email(mail_addr, user, book=Address::BOOK_BOTH) mail_quote = SqlHelper.quote(mail_addr) email_con = [] email_con.push(""(email1=#{mail_quote})"") email_con.push(""(email2=#{mail_quote})"") email_con.push(""(email3=#{mail_quote})"") con = [] con.push('('+email_con.join(' or ')+')') con.push(AddressbookHelper.get_scope_condition_for(user, book)) return Address.where(con.join(' and ')).to_a end"
1039,"def self.exists_copies_folder?(user_id) my_folder = User.get_my_folder(user_id) unless my_folder.nil? con = ""(parent_id=#{my_folder.id}) and (name='#{Item.copies_folder}')"" begin copies_folder = Folder.where(con).first rescue end end return !copies_folder.nil? end",True,Ruby,self.exists_copies_folder?,items_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.parse_csv_row(row, book, idxs, user) imp_id = (idxs[0].nil? or row[idxs[0]].nil?)?(nil):(row[idxs[0]].strip) SqlHelper.validate_token([imp_id]) unless imp_id.blank? begin org_address = Address.find(imp_id) rescue => evar org_address = nil end end if org_address.nil? address = Address.new else address = org_address end address.id = imp_id attr_names = [ :name, :name_ruby, :nickname, :screenname, :email1, :email2, :email3, :postalcode, :address, :tel1_note, :tel1, :tel2_note, :tel2, :tel3_note, :tel3, :fax, :url, :organization, :title, :memo, :xorder, :groups, :teams ] attr_names.each_with_index do |attr_name, idx| row_idx = idxs[idx+1] break if row_idx.nil? val = (row[row_idx].nil?)?(nil):(row[row_idx].strip) address.send(attr_name.to_s + '=', val) end if (address.groups == Address::EXP_IMP_FOR_ALL) \ or (book == Address::BOOK_COMMON and address.groups.blank? and address.teams.blank?) address.groups = nil address.teams = nil address.owner_id = 0 elsif !address.groups.blank? or !address.teams.blank? address.owner_id = 0 else address.owner_id = user.id end return address end"
1041,"def self.get_sql_like(attr_names, keyword) key = ActiveRecord::Base.connection.quote(""%#{SqlHelper.escape_for_like(keyword)}%"") con = [] attr_names.each do |attr_name| con << ""(#{attr_name} like #{key})"" end sql = con.join(' or ') sql = '(' + sql + ')' if con.length > 1 return sql end",True,Ruby,self.get_sql_like,sql_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.get_from_name(user_name) SqlHelper.validate_token([user_name]) begin user = User.where(name: user_name).first rescue => evar Log.add_error(nil, evar) end return user end"
1043,"def self.get_tmpl_subfolder(name) SqlHelper.validate_token([name]) tmpl_folder = Folder.where(""folders.name='#{TMPL_ROOT}'"").first unless tmpl_folder.nil? con = ""(parent_id=#{tmpl_folder.id}) and (name='#{name}')"" begin child = Folder.where(con).first rescue => evar Log.add_error(nil, evar) end end return [tmpl_folder, child] end",True,Ruby,self.get_tmpl_subfolder,templates_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.load_yaml return if @yaml_loaded return unless defined?(gem) test_syck = ENV['TEST_SYCK'] # Only Ruby 1.8 and 1.9 have syck test_syck = false unless /^1\./ =~ RUBY_VERSION unless test_syck begin gem 'psych', '>= 2.0.0' rescue Gem::LoadError # It's OK if the user does not have the psych gem installed. We will # attempt to require the stdlib version end begin # Try requiring the gem version *or* stdlib version of psych. require 'psych' rescue ::LoadError # If we can't load psych, thats fine, go on. else # If 'yaml' has already been required, then we have to # be sure to switch it over to the newly loaded psych. if defined?(YAML::ENGINE) && YAML::ENGINE.yamler != ""psych"" YAML::ENGINE.yamler = ""psych"" end require 'rubygems/psych_additions' require 'rubygems/psych_tree' end end require 'yaml' require 'rubygems/safe_yaml' # If we're supposed to be using syck, then we may have to force # activate it via the YAML::ENGINE API. if test_syck and defined?(YAML::ENGINE) YAML::ENGINE.yamler = ""syck"" unless YAML::ENGINE.syck? end # Now that we're sure some kind of yaml library is loaded, pull # in our hack to deal with Syck's DefaultKey ugliness. require 'rubygems/syck_hack' @yaml_loaded = true end"
1044,"def self.setup_tmpl_folder begin tmpl_folder = Folder.where(""folders.name='#{TMPL_ROOT}'"").first rescue end if tmpl_folder.nil? # Setup initial template-folders folder = Folder.new folder.name = TMPL_ROOT folder.parent_id = 0 folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_folder = folder end childs = Folder.where(""folders.parent_id=#{tmpl_folder.id}"").to_a # System tmpl_system_folder = childs.find{|child| child.name == TMPL_SYSTEM} if tmpl_system_folder.nil? folder = Folder.new folder.name = TMPL_SYSTEM folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_system_folder = folder # System - Profile Sheet item = Item.new_profile(tmpl_system_folder.id) item.title = Item.profile_title_def item.user_id = 0 item.save! end # Workflow tmpl_workflows_folder = childs.find{|child| child.name == TMPL_WORKFLOWS} if tmpl_workflows_folder.nil? folder = Folder.new folder.name = TMPL_WORKFLOWS folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_workflows_folder = folder end # Local tmpl_local_folder = childs.find{|child| child.name == TMPL_LOCAL} if tmpl_local_folder.nil? folder = Folder.new folder.name = TMPL_LOCAL folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_local_folder = folder end # Research tmpl_q_folder = childs.find{|child| child.name == TMPL_RESEARCH} if tmpl_q_folder.nil? folder = Folder.new folder.name = TMPL_RESEARCH folder.parent_id = tmpl_folder.id folder.owner_id = 0 folder.xtype = Folder::XTYPE_SYSTEM folder.save! tmpl_q_folder = folder end return [tmpl_folder, tmpl_system_folder, tmpl_workflows_folder, tmpl_local_folder, tmpl_q_folder] rescue => evar Log.add_error(nil, evar) return nil end",True,Ruby,self.setup_tmpl_folder,templates_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def load_file(filename) Gem.load_yaml yaml_errors = [ArgumentError] yaml_errors << Psych::SyntaxError if defined?(Psych::SyntaxError) return {} unless filename and File.exist? filename begin content = Gem::SafeYAML.load(File.read(filename)) unless content.kind_of? Hash warn ""Failed to load #{filename} because it doesn't contain valid YAML hash"" return {} end return content rescue *yaml_errors => e warn ""Failed to load #{filename}, #{e}"" rescue Errno::EACCES warn ""Failed to load #{filename} due to permissions problem."" end {} end"
1046,"def self.get_tmpl_folder tmpl_folder = Folder.where(""folders.name='#{TMPL_ROOT}'"").first if tmpl_folder.nil? ary = self.setup_tmpl_folder unless ary.nil? or ary.empty? tmpl_folder = ary[0] tmpl_system_folder = ary[1] tmpl_workflows_folder = ary[2] tmpl_local_folder = ary[3] tmpl_q_folder = ary[4] end else folders = Folder.where(""parent_id=#{tmpl_folder.id}"").to_a unless folders.nil? folders.each do |child| case child.name when TMPL_SYSTEM tmpl_system_folder = child when TMPL_WORKFLOWS tmpl_workflows_folder = child when TMPL_LOCAL tmpl_local_folder = child when TMPL_RESEARCH tmpl_q_folder = child end end end end",True,Ruby,self.get_tmpl_folder,templates_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def check_credentials_permissions return if Gem.win_platform? # windows doesn't write 0600 as 0600 return unless File.exist? credentials_path existing_permissions = File.stat(credentials_path).mode & 0777 return if existing_permissions == 0600 alert_error <<-ERROR Your gem push credentials file located at: \t#{credentials_path} has file permissions of 0#{existing_permissions.to_s 8} but 0600 is required. To fix this error run: \tchmod 0600 #{credentials_path} You should reset your credentials at: \thttps://rubygems.org/profile/edit if you believe they were disclosed to a third party. ERROR terminate_interaction 1 end ## # Location of RubyGems.org credentials def credentials_path File.join Gem.user_home, '.gem', 'credentials' end def load_api_keys check_credentials_permissions @api_keys = if File.exist? credentials_path then load_file(credentials_path) else @hash end if @api_keys.key? :rubygems_api_key then @rubygems_api_key = @api_keys[:rubygems_api_key] @api_keys[:rubygems] = @api_keys.delete :rubygems_api_key unless @api_keys.key? :rubygems end end ## # Returns the RubyGems.org API key def rubygems_api_key load_api_keys unless @rubygems_api_key @rubygems_api_key end ## # Sets the RubyGems.org API key to +api_key+ def rubygems_api_key= api_key set_api_key :rubygems_api_key, api_key @rubygems_api_key = api_key end ## # Set a specific host's API key to +api_key+ def set_api_key host, api_key check_credentials_permissions config = load_file(credentials_path).merge(host => api_key) dirname = File.dirname credentials_path Dir.mkdir(dirname) unless File.exist? dirname Gem.load_yaml permissions = 0600 & (~File.umask) File.open(credentials_path, 'w', permissions) do |f| f.write config.to_yaml end load_api_keys # reload end def load_file(filename) Gem.load_yaml yaml_errors = [ArgumentError] yaml_errors << Psych::SyntaxError if defined?(Psych::SyntaxError) return {} unless filename and File.exist? filename begin content = Gem::SafeYAML.load(File.read(filename)) unless content.kind_of? Hash warn ""Failed to load #{filename} because it doesn't contain valid YAML hash"" return {} end return content rescue *yaml_errors => e warn ""Failed to load #{filename}, #{e}"" rescue Errno::EACCES warn ""Failed to load #{filename} due to permissions problem."" end {} end # True if the backtrace option has been specified, or debug is on. def backtrace @backtrace or $DEBUG end # The name of the configuration file. def config_file_name @config_file_name || Gem.config_file end # Delegates to @hash def each(&block) hash = @hash.dup hash.delete :update_sources hash.delete :verbose hash.delete :backtrace hash.delete :bulk_threshold yield :update_sources, @update_sources yield :verbose, @verbose yield :backtrace, @backtrace yield :bulk_threshold, @bulk_threshold yield 'config_file_name', @config_file_name if @config_file_name hash.each(&block) end # Handle the command arguments. def handle_arguments(arg_list) @args = [] arg_list.each do |arg| case arg when /^--(backtrace|traceback)$/ then @backtrace = true when /^--debug$/ then $DEBUG = true warn 'NOTE: Debugging mode prints all exceptions even when rescued' else @args << arg end end end"
1050,"def self.get_childs(klass, node_id, recursive, ret_obj) SqlHelper.validate_token([node_id]) array = [] if recursive tree = klass.get_tree(Hash.new, nil, node_id) return array if tree.nil? tree.each do |parent_id, childs| if ret_obj array |= childs else childs.each do |node| node_id = node.id.to_s array << node_id unless array.include?(node_id) end end end else nodes = klass.where(""parent_id=#{node_id}"").order('xorder ASC, id ASC').to_a if ret_obj array = nodes else nodes.each do |node| array << node.id.to_s end end end return array end",True,Ruby,self.get_childs,tree_element.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def read_checksums gem Gem.load_yaml @checksums = gem.seek 'checksums.yaml.gz' do |entry| Zlib::GzipReader.wrap entry do |gz_io| Gem::SafeYAML.safe_load gz_io.read end end end
1052,"def self.get_tree(klass, tree, conditions, node_id, order_by) SqlHelper.validate_token([node_id]) if conditions.nil? con = '' else con = Marshal.load(Marshal.dump(conditions)) + ' and ' end con << ""(parent_id=#{node_id})"" tree[node_id] = klass.where(con).order(order_by).to_a tree[node_id].each do |node| tree = klass.get_tree(tree, conditions, node.id.to_s) end return tree end",True,Ruby,self.get_tree,tree_element.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def file_list io # :nodoc: header = String.new read_until_dashes io do |line| header << line end Gem::SafeYAML.safe_load header end
1053,"def self.get_comment_of(item_id, user_id) SqlHelper.validate_token([item_id, user_id]) begin comment = Comment.where(""(user_id=#{user_id}) and (item_id=#{item_id}) and (xtype='#{Comment::XTYPE_DIST_ACK}')"").first rescue => evar Log.add_error(nil, evar) end return comment end",True,Ruby,self.get_comment_of,zeptair_dist_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.from_yaml(input) Gem.load_yaml input = normalize_yaml_input input spec = Gem::SafeYAML.safe_load input if spec && spec.class == FalseClass then raise Gem::EndOfYAMLException end unless Gem::Specification === spec then raise Gem::Exception, ""YAML data doesn't evaluate to gem specification"" end spec.specification_version ||= NONEXISTENT_SPECIFICATION_VERSION spec.reset_nil_attributes_to_default spec end"
1057,"def self.count_completed_users(item_id) SqlHelper.validate_token([item_id]) ack_msg = ZeptairDistHelper.completed_ack_message(item_id) return Comment.where(""(item_id=#{item_id}) and (xtype='#{Comment::XTYPE_DIST_ACK}') and (message='#{ack_msg}')"").count end",True,Ruby,self.count_completed_users,zeptair_dist_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def install_location filename, destination_dir # :nodoc: raise Gem::Package::PathError.new(filename, destination_dir) if filename.start_with? '/' destination_dir = File.realpath destination_dir if File.respond_to? :realpath destination_dir = File.expand_path destination_dir destination = File.join destination_dir, filename destination = File.expand_path destination raise Gem::Package::PathError.new(destination, destination_dir) unless destination.start_with? destination_dir + '/' destination.untaint destination end"
1060,"def self.trim_by_capacity(user_id, mail_account_id, capacity_mb) # FEATURE_MAIL_STRICT_CAPACITY >>> # FEATURE_MAIL_STRICT_CAPACITY <<< end",True,Ruby,self.trim_by_capacity,email.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def test_verify_security_policy_checksum_missing skip 'openssl is missing' unless defined?(OpenSSL::SSL) @spec.cert_chain = [PUBLIC_CERT.to_pem] @spec.signing_key = PRIVATE_KEY build = Gem::Package.new @gem build.spec = @spec build.setup_signer FileUtils.mkdir 'lib' FileUtils.touch 'lib/code.rb' File.open @gem, 'wb' do |gem_io| Gem::Package::TarWriter.new gem_io do |gem| build.add_metadata gem build.add_contents gem # write bogus data.tar.gz to foil signature bogus_data = Gem.gzip 'hello' fake_signer = Class.new do def digest_name; 'SHA512'; end def digest_algorithm; Digest(:SHA512); end def key; 'key'; end def sign(*); 'fake_sig'; end end gem.add_file_signed 'data2.tar.gz', 0444, fake_signer.new do |io| io.write bogus_data end # pre rubygems 2.0 gems do not add checksums end end Gem::Security.trust_dir.trust_cert PUBLIC_CERT package = Gem::Package.new @gem package.security_policy = Gem::Security::HighSecurity e = assert_raises Gem::Security::Exception do package.verify end assert_equal 'invalid signature', e.message refute package.instance_variable_get(:@spec), '@spec must not be loaded' assert_empty package.instance_variable_get(:@files), '@files must empty' end"
1061,"def self.trim(user_id, mail_account_id, max) SqlHelper.validate_token([user_id, mail_account_id]) begin count = Email.where(""mail_account_id=#{mail_account_id}"").count if count > max #logger.fatal(""[INFO] Email.trim(user_id:#{user_id}, mail_account_id:#{mail_account_id}, max:#{max})"") over_num = count - max emails = [] # First, empty Trashbox user = User.find(user_id) trashbox = MailFolder.get_for(user, mail_account_id, MailFolder::XTYPE_TRASH) trash_nodes = [trashbox.id.to_s] trash_nodes += MailFolder.get_childs(trash_nodes.first, true, false) con = ""mail_folder_id in (#{trash_nodes.join(',')})"" emails = Email.where(con).order('updated_at ASC').limit(over_num).to_a # Now, remove others if emails.length < over_num over_num -= emails.length emails += Email.where(""mail_account_id=#{mail_account_id}"").order('updated_at ASC').limit(over_num).to_a end emails.each do |email| email.destroy end end rescue end end",True,Ruby,self.trim,email.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def self.from(stream) header = stream.read 512 empty = (header == ""\0"" * 512) fields = header.unpack UNPACK_FORMAT new :name => fields.shift, :mode => strict_oct(fields.shift), :uid => strict_oct(fields.shift), :gid => strict_oct(fields.shift), :size => strict_oct(fields.shift), :mtime => strict_oct(fields.shift), :checksum => strict_oct(fields.shift), :typeflag => fields.shift, :linkname => fields.shift, :magic => fields.shift, :version => strict_oct(fields.shift), :uname => fields.shift, :gname => fields.shift, :devmajor => strict_oct(fields.shift), :devminor => strict_oct(fields.shift), :prefix => fields.shift, :empty => empty end"
1063,"def self.destroy_by_user(user_id, add_con=nil) SqlHelper.validate_token([user_id]) con = ""user_id=#{user_id}"" con << "" and (#{add_con})"" unless add_con.nil? or add_con.empty? emails = Email.where(con).to_a emails.each do |email| email.destroy end end",True,Ruby,self.destroy_by_user,email.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def show_owners name response = rubygems_api_request :get, ""api/v1/gems/#{name}/owners.yaml"" do |request| request.add_field ""Authorization"", api_key end with_response response do |resp| owners = Gem::SafeYAML.load resp.body say ""Owners for gem: #{name}"" owners.each do |owner| say ""- #{owner['email'] || owner['handle'] || owner['id']}"" end end end"
1065,"def self.get_tree(folder_tree, conditions, parent, admin) if parent.instance_of?(Folder) tree_id = parent.id.to_s else tree_id = parent.to_s parent = nil if tree_id != '0' begin parent = Folder.find(tree_id) rescue end return folder_tree if parent.nil? end end group_obj_cache = {} folder_tree[tree_id] = [] if !parent.nil? and (parent.xtype == Folder::XTYPE_GROUP) Group.get_childs(parent.owner_id, false, true).each do |group| group_obj_cache[group.id] = group con = Marshal.load(Marshal.dump(conditions)) unless conditions.nil? if con.nil? con = '' else con << ' and ' end con << ""(xtype='#{Folder::XTYPE_GROUP}') and (owner_id=#{group.id})"" begin group_folder = Folder.where(con).first rescue => evar Log.add_error(nil, evar) end unless group_folder.nil? folder_tree[tree_id] << group_folder end end end con = Marshal.load(Marshal.dump(conditions)) unless conditions.nil? if con.nil? con = '' else con << ' and ' end con << ""parent_id=#{tree_id}"" folder_tree[tree_id] += Folder.where(con).order('xorder ASC, id ASC').to_a delete_ary = [] folder_tree[tree_id].each do |folder| if !admin and (folder.xtype == Folder::XTYPE_SYSTEM) delete_ary << folder next end if (tree_id == '0') and (folder.xtype == Folder::XTYPE_GROUP) group = Group.find_with_cache(folder.owner_id, group_obj_cache) unless group.nil? if group.parent_id != 0 delete_ary << folder next end end end folder_tree = Folder.get_tree(folder_tree, conditions, folder, admin) end folder_tree[tree_id] -= delete_ary return folder_tree end",True,Ruby,self.get_tree,folder.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def extract_tar_gz io, destination_dir, pattern = ""*"" # :nodoc: open_tar_gz io do |tar| tar.each do |entry| next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH destination = install_location entry.full_name, destination_dir FileUtils.rm_rf destination mkdir_options = {} mkdir_options[:mode] = entry.header.mode if entry.directory? mkdir = if entry.directory? then destination else File.dirname destination end mkdir_p_safe mkdir, mkdir_options, destination_dir, entry.full_name File.open destination, 'wb' do |out| out.write entry.read FileUtils.chmod entry.header.mode, destination end if entry.file? File.symlink(entry.header.linkname, destination) if entry.symlink? verbose destination end end end"
1066,"def self.get_tree_by_group_for_admin(group_id) SqlHelper.validate_token([group_id]) folder_tree = {} tree_id = '0' if group_id.to_s == '0' sql = 'select distinct * from folders' where = "" where (parent_id = #{tree_id})"" where << "" and ((xtype is null) or not(xtype = '#{XTYPE_GROUP}' or xtype = '#{XTYPE_USER}'))"" order_by = ' order by xorder ASC, id ASC' else sql = 'select distinct Folder.* from folders Folder, users User' where = "" where (Folder.parent_id = #{tree_id})"" where << ' and (' where << ""(Folder.xtype = '#{XTYPE_GROUP}' and Folder.owner_id = #{group_id})"" where << ' or ' where << ""(Folder.xtype = '#{XTYPE_USER}' and Folder.owner_id = User.id and #{SqlHelper.get_sql_like(['User.groups'], ""|#{group_id}|"")})"" where << ' )' order_by = ' order by Folder.xorder ASC, Folder.id ASC' end sql << where + order_by folder_tree[tree_id] = Folder.find_by_sql(sql) folder_tree[tree_id].each do |folder| folder_tree = Folder.get_tree(folder_tree, nil, folder, true) end return Folder.sort_tree(folder_tree) end",True,Ruby,self.get_tree_by_group_for_admin,folder.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def install_location filename, destination_dir # :nodoc: raise Gem::Package::PathError.new(filename, destination_dir) if filename.start_with? '/' destination_dir = realpath destination_dir destination_dir = File.expand_path destination_dir destination = File.join destination_dir, filename destination = File.expand_path destination raise Gem::Package::PathError.new(destination, destination_dir) unless destination.start_with? destination_dir + '/' destination.untaint destination end"
1067,"def self.get_childs(folder_id, conditions, recursive, admin, ret_obj) SqlHelper.validate_token([folder_id]) arr = [] if recursive folder_tree = Folder.get_tree(Hash.new, conditions, folder_id, admin) return [] if folder_tree.nil? folder_tree.each do |parent_id, childs| if ret_obj arr |= childs else childs.each do |folder| folder_id = folder.id.to_s arr << folder_id unless arr.include?(folder_id) end end end else con = Marshal.load(Marshal.dump(conditions)) if con.nil? con = '' else con << ' and ' end con << ""parent_id=#{folder_id}"" unless admin con << "" and (xtype is null or not (xtype='#{Folder::XTYPE_SYSTEM}'))"" end folders = Folder.where(con).order('xorder ASC').to_a if ret_obj arr = folders else folders.each do |folder| arr << folder.id.to_s end end end return arr end",True,Ruby,self.get_childs,folder.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def test_extract_symlink_parent skip 'symlink not supported' if Gem.win_platform? package = Gem::Package.new @gem tgz_io = util_tar_gz do |tar| tar.mkdir 'lib', 0755 tar.add_symlink 'lib/link', '../..', 0644 tar.add_file 'lib/link/outside.txt', 0644 do |io| io.write 'hi' end end # Extract into a subdirectory of @destination; if this test fails it writes # a file outside destination_subdir, but we want the file to remain inside # @destination so it will be cleaned up. destination_subdir = File.join @destination, 'subdir' FileUtils.mkdir_p destination_subdir e = assert_raises Gem::Package::PathError do package.extract_tar_gz tgz_io, destination_subdir end assert_equal(""installing into parent path lib/link/outside.txt of "" + ""#{destination_subdir} is not allowed"", e.message) end"
1071,"def self.get_group_folder(group_id) SqlHelper.validate_token([group_id]) begin return Folder.where(""(owner_id=#{group_id}) and (xtype='#{Folder::XTYPE_GROUP}')"").first rescue => evar Log.add_error(nil, evar) return nil end end",True,Ruby,self.get_group_folder,group.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def api_endpoint(uri) host = uri.host begin res = @dns.getresource ""_rubygems._tcp.#{host}"", Resolv::DNS::Resource::IN::SRV rescue Resolv::ResolvError => e verbose ""Getting SRV record failed: #{e}"" uri else target = res.target.to_s.strip if URI(""http://"" + target).host.end_with?("".#{host}"") return URI.parse ""#{uri.scheme}://#{target}#{uri.path}"" end uri end end"
1074,"def self.get_for_group(group_id) SqlHelper.validate_token([group_id]) if group_id.nil? con = 'group_id is null' else con = ""group_id=#{group_id}"" end Location.do_expire(con) return Location.where(con).to_a end",True,Ruby,self.get_for_group,location.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def output_versions output, versions versions.each do |gem_name, matching_tuples| matching_tuples = matching_tuples.sort_by { |n,_| n.version }.reverse platforms = Hash.new { |h,version| h[version] = [] } matching_tuples.each do |n, _| platforms[n.version] << n.platform if n.platform end seen = {} matching_tuples.delete_if do |n,_| if seen[n.version] then true else seen[n.version] = true false end end output << clean_text(make_entry(matching_tuples, platforms)) end end"
1077,"def self.get_using_size(mail_account_id, add_con=nil) SqlHelper.validate_token([mail_account_id]) con = [] con << ""(mail_account_id=#{mail_account_id})"" con << ""(#{add_con})"" unless add_con.nil? or add_con.empty? return (Email.count_by_sql(""select SUM(size) from emails where #{con.join(' and ')}"") || 0) end",True,Ruby,self.get_using_size,mail_account.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def format_text(text, wrap, indent=0) result = [] work = clean_text(text) while work.length > wrap do if work =~ /^(.{0,#{wrap}})[ \n]/ then result << $1.rstrip work.slice!(0, $&.length) else result << work.slice!(0, wrap) end end result << work if work.length.nonzero? result.join(""\n"").gsub(/^/, "" "" * indent) end"
1078,"def self.destroy_by_user(user_id, add_con=nil) SqlHelper.validate_token([user_id]) con = ""user_id=#{user_id}"" con << "" and (#{add_con})"" unless add_con.nil? or add_con.empty? mail_accounts = MailAccount.where(con).to_a mail_accounts.each do |mail_account| mail_account.destroy end end",True,Ruby,self.destroy_by_user,mail_account.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def clean_text(text) text.gsub(/[\000-\b\v-\f\016-\037\177]/, ""."".freeze) end"
1079,"def self.get_default_for(user_id, xtype=nil) SqlHelper.validate_token([user_id, xtype]) con = [] con << ""(user_id=#{user_id})"" con << '(is_default=1)' con << ""(xtype='#{xtype}')"" unless xtype.blank? where = '' unless con.nil? or con.empty? where = 'where ' + con.join(' and ') end mail_accounts = MailAccount.find_by_sql('select * from mail_accounts ' + where + ' order by xorder ASC, title ASC') if mail_accounts.nil? or mail_accounts.empty? return nil else return mail_accounts.first end end",True,Ruby,self.get_default_for,mail_account.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def test_execute_details_cleans_text spec_fetcher do |fetcher| fetcher.spec 'a', 2 do |s| s.summary = 'This is a lot of text. ' * 4 s.authors = [""Abraham Lincoln \x01"", ""\x02 Hirohito""] s.homepage = ""http://a.example.com/\x03"" end fetcher.legacy_platform end @cmd.handle_options %w[-r -d] use_ui @ui do @cmd.execute end expected = <<-EOF *** REMOTE GEMS *** a (2) Authors: Abraham Lincoln ., . Hirohito Homepage: http://a.example.com/. This is a lot of text. This is a lot of text. This is a lot of text. This is a lot of text. pl (1) Platform: i386-linux Author: A User Homepage: http://example.com this is a summary EOF assert_equal expected, @ui.output assert_equal '', @ui.error end"
1081,"def self.get_for(mail_account_id, enabled=nil, trigger=nil) return [] if mail_account_id.nil? SqlHelper.validate_token([mail_account_id, trigger]) con = [] con << ""(mail_account_id=#{mail_account_id})"" con << ""(enabled=#{(enabled)?(1):(0)})"" unless enabled.nil? con << SqlHelper.get_sql_like([:triggers], ""|#{trigger}|"") unless trigger.nil? return MailFilter.where(con.join(' and ')).order('(xorder is null) ASC, xorder ASC, id ASC').to_a end",True,Ruby,self.get_for,mail_filter.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def spec_summary entry, spec summary = truncate_text(spec.summary, ""the summary for #{spec.full_name}"") entry << ""\n\n"" << format_text(summary, 68, 4) end"
1085,"def self.get_account_roots_for(user) return nil if user.nil? if user.kind_of?(User) user_id = user.id else user_id = user.to_s end SqlHelper.validate_token([user_id]) con = [] con << ""(user_id=#{user_id})"" con << ""(xtype='#{MailFolder::XTYPE_ACCOUNT_ROOT}')"" order_by = 'xorder ASC, id ASC' return MailFolder.where(con.join(' and ')).order(order_by).to_a end",True,Ruby,self.get_account_roots_for,mail_folder.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def build_gem_lines(conservative_versioning) @deps.map do |d| name = d.name.dump requirement = if conservative_versioning "", \""#{conservative_version(@definition.specs[d.name][0])}\"""" else "", #{d.requirement.as_list.map(&:dump).join("", "")}"" end if d.groups != Array(:default) group = d.groups.size == 1 ? "", :group => #{d.groups.first.inspect}"" : "", :groups => #{d.groups.inspect}"" end source = "", :source => \""#{d.source}\"""" unless d.source.nil? git = "", :git => \""#{d.git}\"""" unless d.git.nil? branch = "", :branch => \""#{d.branch}\"""" unless d.branch.nil? require_path = "", :require => #{convert_autorequire(d.autorequire)}"" unless d.autorequire.nil? %(gem #{name}#{requirement}#{group}#{source}#{git}#{branch}#{require_path}) end.join(""\n"")"
1086,"def self.get_for(user, mail_account_id, xtype) return nil if user.nil? or mail_account_id.blank? if user.kind_of?(User) user_id = user.id else user_id = user.to_s end SqlHelper.validate_token([user_id, mail_account_id, xtype]) con = [] con << ""(user_id=#{user_id})"" con << ""(mail_account_id=#{mail_account_id})"" con << ""(xtype='#{xtype}')"" return MailFolder.where(con.join(' and ')).first end",True,Ruby,self.get_for,mail_folder.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def legal?(str) !!str.match(/\A\h{24}\Z/i) end
1088,"def self.get_for_group(group_id, incl_img_content=false) SqlHelper.validate_token([group_id]) if group_id.nil? office_map = nil else if incl_img_content office_map = OfficeMap.where(""group_id=#{group_id}"").first else sql = 'select id, group_id, img_enabled, img_name, img_size, img_content_type, created_at, updated_at from office_maps' sql << "" where group_id=#{group_id}"" begin office_map = OfficeMap.find_by_sql(sql).first rescue end end end if office_map.nil? office_map = OfficeMap.new office_map.group_id = group_id.to_i unless group_id.nil? office_map.img_enabled = false end return office_map end",True,Ruby,self.get_for_group,office_map.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def legal?(str) !!str.match(/\A\h{24}\Z/i) end
1091,"def self.get_for(group_id, include_parents=false, enabled=nil) SqlHelper.validate_token([group_id]) con = [] #con << ""(disabled=#{!enabled})"" unless enabled.nil? if include_parents group_con = '(group_id is null)' unless group_id.nil? or group_id.to_s == '0' group_obj_cache = {} group = Group.find_with_cache(group_id, group_obj_cache) group_ids = group.get_parents(false, group_obj_cache) group_ids << group_id group_con << "" or (group_id in (#{group_ids.join(',')}))"" end con << '(' + group_con + ')' else con << ""(group_id=#{group_id})"" end order_by = 'order by xorder ASC, id ASC' #order_by = 'order by disabled ASC, xorder ASC, id ASC' sql = 'select * from official_titles where ' + con.join(' and ') + ' ' + order_by return OfficialTitle.find_by_sql(sql) end",True,Ruby,self.get_for,official_title.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def legal?(str) !!str.match(/\A\h{24}\Z/i) end
1092,"def self.update_for(user_id, fiscal_year, num) SqlHelper.validate_token([user_id, fiscal_year]) if num <= 0 con = [] con << ""(user_id=#{user_id})"" con << ""(year=#{fiscal_year})"" PaidHoliday.destroy_all(con.join(' and ')) return end paid_holiday = PaidHoliday.get_for(user_id, fiscal_year) if paid_holiday.nil? paid_holiday = PaidHoliday.new paid_holiday.user_id = user_id paid_holiday.year = fiscal_year paid_holiday.num = num paid_holiday.save! else paid_holiday.update_attribute(:num, num) end end",True,Ruby,self.update_for,paid_holiday.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,def legal?(str) !!str.match(/\A\h{24}\Z/i) end
1093,"def self.get_carried_over(user_id, year) SqlHelper.validate_token([user_id, year]) yaml = ApplicationHelper.get_config_yaml unless yaml[:timecard].nil? paidhld_carry_over = yaml[:timecard]['paidhld_carry_over'] end return 0 if paidhld_carry_over.nil? or paidhld_carry_over.empty? or paidhld_carry_over == PaidHoliday::CARRY_OVER_NONE begin con = ""(user_id=#{user_id}) and (year < #{year})"" paidhlds = PaidHoliday.where(con).order('year ASC').to_a rescue end return 0 if paidhlds.nil? or paidhlds.empty? sum = 0 year_begins_from, month_begins_at = TimecardsHelper.get_fiscal_params if paidhld_carry_over == PaidHoliday::CARRY_OVER_1_YEAR last_carried_out = 0 for y in paidhlds.first.year .. year - 1 paidhld = paidhlds.find { |hld| hld.year == y } given_num = (paidhld.nil?)?0:paidhld.num start_date, end_date = TimecardsHelper.get_year_span(y, year_begins_from, month_begins_at) applied_paid_hlds = Timecard.applied_paid_hlds(user_id, start_date, end_date) if applied_paid_hlds >= last_carried_out last_carried_out = given_num - (applied_paid_hlds - last_carried_out) else last_carried_out = given_num end end return last_carried_out elsif paidhld_carry_over == PaidHoliday::CARRY_OVER_NO_EXPIRATION paidhlds.each do |paidhld| sum += paidhld.num end start_date, dummy = TimecardsHelper.get_year_span(paidhlds.first.year, year_begins_from, month_begins_at) dummy, end_date = TimecardsHelper.get_year_span(year - 1, year_begins_from, month_begins_at) applied_paid_hlds = Timecard.applied_paid_hlds(user_id, start_date, end_date) return (sum - applied_paid_hlds) else return 0 end end",True,Ruby,self.get_carried_over,paid_holiday.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def generation_time Time.at(data.unpack(""N"")[0]).utc end"
1095,"def self.get_for(user_id, fiscal_year=nil) SqlHelper.validate_token([user_id, fiscal_year]) begin con = [] con << ""(user_id=#{user_id})"" if fiscal_year.nil? return PaidHoliday.where(con).order('year ASC').to_a else con << ""(year=#{fiscal_year})"" return PaidHoliday.where(con.join(' and ')).first end rescue end return nil end",True,Ruby,self.get_for,paid_holiday.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def generation_time Time.at(data.unpack(""N"")[0]).utc end"
1099,"def self.get_for(user_id) SqlHelper.validate_token([user_id]) return Research.where(""user_id=#{user_id}"").first end",True,Ruby,self.get_for,research.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def generation_time Time.at(data.unpack(""N"")[0]).utc end"
1101,"def self.get_group_value(group_id, category, key) SqlHelper.validate_token([group_id, category, key]) con = [] con << ""(group_id=#{group_id})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first return setting.xvalue unless setting.nil? return nil end",True,Ruby,self.get_group_value,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def generation_time Time.at(data.unpack(""N"")[0]).utc end"
1103,"def self.get_value(user_id, category, key) SqlHelper.validate_token([user_id, category, key]) con = [] con << ""(user_id=#{user_id})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first return setting.xvalue unless setting.nil? return nil end",True,Ruby,self.get_value,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1104,"def self.save_group_value(group_id, category, key, value) SqlHelper.validate_token([group_id, category, key]) con = [] con << ""(group_id=#{group_id})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first if value.nil? unless setting.nil? setting.destroy end else if setting.nil? setting = Setting.new setting.group_id = group_id setting.category = category setting.xkey = key setting.xvalue = value setting.save! else setting.update_attribute(:xvalue, value) end end end",True,Ruby,self.save_group_value,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1105,"def self.get_for(user_id, category=nil) SqlHelper.validate_token([user_id, category]) con = [] con << ""(user_id=#{user_id})"" con << ""(category='#{category}')"" unless category.nil? settings = Setting.where(con.join(' and ')).to_a return nil if settings.nil? or settings.empty? hash = Hash.new settings.each do |setting| hash[setting.xkey] = setting.xvalue end return hash end",True,Ruby,self.get_for,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1106,"def self.save_value(user_id, category, key, value) SqlHelper.validate_token([user_id, category, key]) con = [] con << ""(user_id=#{user_id})"" con << ""(category='#{category}')"" con << ""(xkey='#{key}')"" setting = Setting.where(con.join(' and ')).first if value.nil? unless setting.nil? setting.destroy end else if setting.nil? setting = Setting.new setting.user_id = user_id setting.category = category setting.xkey = key setting.xvalue = value setting.save! else setting.update_attribute(:xvalue, value) end end end",True,Ruby,self.save_value,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1107,"def self.get_for_group(group_id, category=nil) SqlHelper.validate_token([group_id, category]) con = [] con << ""(group_id=#{group_id})"" con << ""(category='#{category}')"" unless category.nil? settings = Setting.where(con.join(' and ')).to_a return nil if settings.nil? or settings.empty? hash = Hash.new settings.each do |setting| hash[setting.xkey] = setting.xvalue end return hash end",True,Ruby,self.get_for_group,setting.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data end"
1112,"def remove_application(user_ids) return if user_ids.nil? or user_ids.empty? SqlHelper.validate_token([user_ids]) con = [""(xtype='#{Comment::XTYPE_APPLY}')""] con << ""(item_id=#{self.item_id})"" user_con_a = [] user_ids.each do |user_id| user_con_a << ""(user_id=#{user_id})"" end con << '(' + user_con_a.join(' or ') + ')' Comment.destroy_all(con.join(' and ')) end",True,Ruby,remove_application,team.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data end"
1115,"def self.get_team_folder(team_id) SqlHelper.validate_token([team_id]) begin return Folder.where(""(owner_id=#{team_id}) and (xtype='#{Folder::XTYPE_TEAM}')"").first rescue => evar Log.add_error(nil, evar) return nil end end",True,Ruby,self.get_team_folder,team.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data end"
1118,"def self.get_for(user_id, date_s) SqlHelper.validate_token([user_id, date_s]) begin con = ""(user_id=#{user_id}) and (date='#{date_s}')"" return Timecard.where(con).first rescue end return nil end",True,Ruby,self.get_for,timecard.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data end"
1119,"def self.find_term(user_id, start_date, end_date) SqlHelper.validate_token([user_id]) start_s = start_date.strftime(Schedule::SYS_DATE_FORM) end_s = end_date.strftime(Schedule::SYS_DATE_FORM) con = ""(user_id=#{user_id}) and (date >= '#{start_s}') and (date <= '#{end_s}')"" ary = Timecard.where(con).order('date ASC').to_a timecards_h = Hash.new unless ary.nil? ary.each do |timecard| timecards_h[timecard.date.strftime(Schedule::SYS_DATE_FORM)] = timecard end end return timecards_h end",True,Ruby,self.find_term,timecard.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def next @mutex.lock begin counter = @counter = (@counter + 1) % 0xFFFFFF ensure @mutex.unlock rescue nil end generate(Time.new.to_i, counter) end"
1120,"def self.on_desktop?(user, xtype, target_id) return false if user.nil? or xtype.nil? or target_id.nil? SqlHelper.validate_token([xtype, target_id]) con = ""(user_id=#{user.id}) and (xtype='#{xtype}') and (target_id=#{target_id})"" begin toy = Toy.where(con).first rescue => evar Log.add_error(nil, evar) end return (!toy.nil?) end",True,Ruby,self.on_desktop?,toy.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def next @mutex.lock begin counter = @counter = (@counter + 1) % 0xFFFFFF ensure @mutex.unlock rescue nil end generate(Time.new.to_i, counter) end"
1124,"def self.update_xorder(title, order) if title.nil? con = nil else con = ['title=?', title] end SqlHelper.validate_token([order]) User.update_all(""xorder=#{order}"", con) end",True,Ruby,self.update_xorder,user.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def next @mutex.lock begin counter = @counter = (@counter + 1) % 0xFFFFFF ensure @mutex.unlock rescue nil end generate(Time.new.to_i, counter) end"
1125,"def self.get_my_folder(user_id) SqlHelper.validate_token([user_id]) return Folder.where(""(owner_id=#{user_id}) and (xtype='#{Folder::XTYPE_USER}')"").first end",True,Ruby,self.get_my_folder,user.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-12 22:32:50+09:00,"Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def next @mutex.lock begin counter = @counter = (@counter + 1) % 0xFFFFFF ensure @mutex.unlock rescue nil end generate(Time.new.to_i, counter) end"
1126,"def send_password Log.add_info(request, params.inspect) mail_addr = params[:thetisBoxEdit] SqlHelper.validate_token([mail_addr]) begin users = User.where(""email='#{mail_addr}'"").to_a rescue => evar end if users.nil? or users.empty? Log.add_error(request, evar) flash[:notice] = 'ERROR:' + t('email.address_not_found') else user_passwords_h = {} users.each do |user| newpass = UsersHelper.generate_password user.update_attribute(:pass_md5, UsersHelper.generate_digest_pass(user.name, newpass)) user_passwords_h[user] = newpass end NoticeMailer.password(user_passwords_h, ApplicationHelper.root_url(request)).deliver; flash[:notice] = t('email.sent') end render(:controller => 'login', :action => 'index') end",True,Ruby,send_password,login_controller.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-14 08:56:18+09:00,"Thetis ver.2.3.0: Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1129,"def self.validate_token(tokens, extra_chars=nil) if extra_chars.nil? extra_chars = '' else extra_chars = Regexp.escape(extra_chars.join()) end regexp = Regexp.new(""^[ ]*[a-zA-Z0-9_.@\\-#{extra_chars}]+[ ]*$"") [tokens].flatten.each do |token| next if token.blank? if token.to_s.match(regexp).nil? raise(""[ERROR] SqlHelper.validate_token failed: #{token}"") end end end",True,Ruby,self.validate_token,sql_helper.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-14 08:56:18+09:00,"Thetis ver.2.3.0: Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1130,"def self.get_by_email(mail_addr, user, book=Address::BOOK_BOTH) SqlHelper.validate_token([mail_addr]) email_con = [] email_con.push(""(email1='#{mail_addr}')"") email_con.push(""(email2='#{mail_addr}')"") email_con.push(""(email3='#{mail_addr}')"") con = [] con.push('('+email_con.join(' or ')+')') con.push(AddressbookHelper.get_scope_condition_for(user, book)) return Address.where(con.join(' and ')).to_a end",True,Ruby,self.get_by_email,address.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-14 08:56:18+09:00,"Thetis ver.2.3.0: Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1131,"def self.parse_csv_row(row, book, idxs, user) imp_id = (idxs[0].nil? or row[idxs[0]].nil?)?(nil):(row[idxs[0]].strip) SqlHelper.validate_token([imp_id]) unless imp_id.blank? org_address = Address.find_by_id(imp_id) end if org_address.nil? address = Address.new else address = org_address end address.id = imp_id attr_names = [ :name, :name_ruby, :nickname, :screenname, :email1, :email2, :email3, :postalcode, :address, :tel1_note, :tel1, :tel2_note, :tel2, :tel3_note, :tel3, :fax, :url, :organization, :title, :memo, :xorder, :groups, :teams ] attr_names.each_with_index do |attr_name, idx| row_idx = idxs[idx+1] break if row_idx.nil? val = (row[row_idx].nil?)?(nil):(row[row_idx].strip) address.send(attr_name.to_s + '=', val) end if (address.groups == Address::EXP_IMP_FOR_ALL) \ or (book == Address::BOOK_COMMON and address.groups.blank? and address.teams.blank?) address.groups = nil address.teams = nil address.owner_id = 0 elsif !address.groups.blank? or !address.teams.blank? address.owner_id = 0 else address.owner_id = user.id end return address end",True,Ruby,self.parse_csv_row,address.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-14 08:56:18+09:00,"Thetis ver.2.3.0: Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""N"")[0] @mutex = Mutex.new @counter = 0 end"
1134,"def self.get_from_name(user_name) SqlHelper.validate_token([user_name]) begin user = User.where(""name='#{user_name}'"").first rescue => evar Log.add_error(nil, evar) end return user end",True,Ruby,self.get_from_name,user.rb,https://github.com/sysphonic/thetis,sysphonic,MORITA Shintaro,2015-07-14 08:56:18+09:00,"Thetis ver.2.3.0: Reinforcement of security.
Signed-off-by: MORITA Shintaro <shin@sysphonic.com>",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-2972,"def to_s @@string_format % data.unpack(""C12"") end"
1137,"def self.load_yaml return if @yaml_loaded return unless defined?(gem) test_syck = ENV['TEST_SYCK'] # Only Ruby 1.8 and 1.9 have syck test_syck = false unless /^1\./ =~ RUBY_VERSION unless test_syck begin gem 'psych', '>= 1.2.1' rescue Gem::LoadError # It's OK if the user does not have the psych gem installed. We will # attempt to require the stdlib version end begin # Try requiring the gem version *or* stdlib version of psych. require 'psych' rescue ::LoadError # If we can't load psych, thats fine, go on. else # If 'yaml' has already been required, then we have to # be sure to switch it over to the newly loaded psych. if defined?(YAML::ENGINE) && YAML::ENGINE.yamler != ""psych"" YAML::ENGINE.yamler = ""psych"" end require 'rubygems/psych_additions' require 'rubygems/psych_tree' end end require 'yaml' # If we're supposed to be using syck, then we may have to force # activate it via the YAML::ENGINE API. if test_syck and defined?(YAML::ENGINE) YAML::ENGINE.yamler = ""syck"" unless YAML::ENGINE.syck? end # Now that we're sure some kind of yaml library is loaded, pull # in our hack to deal with Syck's DefaultKey ugliness. require 'rubygems/syck_hack' @yaml_loaded = true end",True,Ruby,self.load_yaml,rubygems.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def to_s @@string_format % data.unpack(""C12"") end"
1140,"def load_file(filename) Gem.load_yaml yaml_errors = [ArgumentError] yaml_errors << Psych::SyntaxError if defined?(Psych::SyntaxError) return {} unless filename and File.exist? filename begin content = YAML.load(File.read(filename)) unless content.kind_of? Hash warn ""Failed to load #{filename} because it doesn't contain valid YAML hash"" return {} end return content rescue *yaml_errors => e warn ""Failed to load #{filename}, #{e}"" rescue Errno::EACCES warn ""Failed to load #{filename} due to permissions problem."" end {} end",True,Ruby,load_file,config_file.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def to_s @@string_format % data.unpack(""C12"") end"
1141,"def check_credentials_permissions return if Gem.win_platform? # windows doesn't write 0600 as 0600 return unless File.exist? credentials_path existing_permissions = File.stat(credentials_path).mode & 0777 return if existing_permissions == 0600 alert_error <<-ERROR Your gem push credentials file located at: \t#{credentials_path} has file permissions of 0#{existing_permissions.to_s 8} but 0600 is required. To fix this error run: \tchmod 0600 #{credentials_path} You should reset your credentials at: \thttps://rubygems.org/profile/edit if you believe they were disclosed to a third party. ERROR terminate_interaction 1 end ## # Location of RubyGems.org credentials def credentials_path File.join Gem.user_home, '.gem', 'credentials' end def load_api_keys check_credentials_permissions @api_keys = if File.exist? credentials_path then load_file(credentials_path) else @hash end if @api_keys.key? :rubygems_api_key then @rubygems_api_key = @api_keys[:rubygems_api_key] @api_keys[:rubygems] = @api_keys.delete :rubygems_api_key unless @api_keys.key? :rubygems end end ## # Returns the RubyGems.org API key def rubygems_api_key load_api_keys unless @rubygems_api_key @rubygems_api_key end ## # Sets the RubyGems.org API key to +api_key+ def rubygems_api_key= api_key set_api_key :rubygems_api_key, api_key @rubygems_api_key = api_key end ## # Set a specific host's API key to +api_key+ def set_api_key host, api_key check_credentials_permissions config = load_file(credentials_path).merge(host => api_key) dirname = File.dirname credentials_path Dir.mkdir(dirname) unless File.exist? dirname Gem.load_yaml permissions = 0600 & (~File.umask) File.open(credentials_path, 'w', permissions) do |f| f.write config.to_yaml end load_api_keys # reload end def load_file(filename) Gem.load_yaml yaml_errors = [ArgumentError] yaml_errors << Psych::SyntaxError if defined?(Psych::SyntaxError) return {} unless filename and File.exist? filename begin content = YAML.load(File.read(filename)) unless content.kind_of? Hash warn ""Failed to load #{filename} because it doesn't contain valid YAML hash"" return {} end return content rescue *yaml_errors => e warn ""Failed to load #{filename}, #{e}"" rescue Errno::EACCES warn ""Failed to load #{filename} due to permissions problem."" end {} end # True if the backtrace option has been specified, or debug is on. def backtrace @backtrace or $DEBUG end # The name of the configuration file. def config_file_name @config_file_name || Gem.config_file end # Delegates to @hash def each(&block) hash = @hash.dup hash.delete :update_sources hash.delete :verbose hash.delete :backtrace hash.delete :bulk_threshold yield :update_sources, @update_sources yield :verbose, @verbose yield :backtrace, @backtrace yield :bulk_threshold, @bulk_threshold yield 'config_file_name', @config_file_name if @config_file_name hash.each(&block) end # Handle the command arguments. def handle_arguments(arg_list) @args = [] arg_list.each do |arg| case arg when /^--(backtrace|traceback)$/ then @backtrace = true when /^--debug$/ then $DEBUG = true warn 'NOTE: Debugging mode prints all exceptions even when rescued' else @args << arg end end end",True,Ruby,check_credentials_permissions,config_file.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def to_s @@string_format % data.unpack(""C12"") end"
1142,def read_checksums gem Gem.load_yaml @checksums = gem.seek 'checksums.yaml.gz' do |entry| Zlib::GzipReader.wrap entry do |gz_io| YAML.load gz_io.read end end end,True,Ruby,read_checksums,package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def generate(time, counter = 0) [time, @machine_id, Process.pid, counter << 8].pack(""N NX lXX NX"") end"
1145,def file_list io # :nodoc: header = String.new read_until_dashes io do |line| header << line end YAML.load header end,True,Ruby,file_list,old.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def generate(time, counter = 0) [time, @machine_id, Process.pid, counter << 8].pack(""N NX lXX NX"") end"
1149,"def self.from_yaml(input) Gem.load_yaml input = normalize_yaml_input input spec = YAML.load input if spec && spec.class == FalseClass then raise Gem::EndOfYAMLException end unless Gem::Specification === spec then raise Gem::Exception, ""YAML data doesn't evaluate to gem specification"" end spec.specification_version ||= NONEXISTENT_SPECIFICATION_VERSION spec.reset_nil_attributes_to_default spec end",True,Ruby,self.from_yaml,specification.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-10-09 22:01:08-05:00,"Whitelist classes and symbols that are in Gem spec YAML

This patch adds a method for loading YAML specs from a gem and
whitelists classes and symbols that are allowed in the spec.  Then it
changes calls to YAML.load to call the whitelisted ""safe"" loader
instead.

[CVE-2017-0903]",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-0903,"def generate(time, counter = 0) [time, @machine_id, Process.pid, counter << 8].pack(""N NX lXX NX"") end"
1152,"def install_location filename, destination_dir # :nodoc: raise Gem::Package::PathError.new(filename, destination_dir) if filename.start_with? '/' destination_dir = File.realpath destination_dir if File.respond_to? :realpath destination_dir = File.expand_path destination_dir destination = File.join destination_dir, filename destination = File.expand_path destination raise Gem::Package::PathError.new(destination, destination_dir) unless destination.start_with? destination_dir destination.untaint destination end",True,Ruby,install_location,package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:02-08:00,Add bug fix for #270068,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2018-1000079,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = """" 12.times { |i| data << string[i*2, 2].to_i(16) } from_data data end"
1159,"def test_verify_security_policy_checksum_missing skip 'openssl is missing' unless defined?(OpenSSL::SSL) @spec.cert_chain = [PUBLIC_CERT.to_pem] @spec.signing_key = PRIVATE_KEY build = Gem::Package.new @gem build.spec = @spec build.setup_signer FileUtils.mkdir 'lib' FileUtils.touch 'lib/code.rb' File.open @gem, 'wb' do |gem_io| Gem::Package::TarWriter.new gem_io do |gem| build.add_metadata gem build.add_contents gem # write bogus data.tar.gz to foil signature bogus_data = Gem.gzip 'hello' gem.add_file_simple 'data.tar.gz', 0444, bogus_data.length do |io| io.write bogus_data end # pre rubygems 2.0 gems do not add checksums end end Gem::Security.trust_dir.trust_cert PUBLIC_CERT package = Gem::Package.new @gem package.security_policy = Gem::Security::HighSecurity e = assert_raises Gem::Security::Exception do package.verify end assert_equal 'invalid signature', e.message refute package.instance_variable_get(:@spec), '@spec must not be loaded' assert_empty package.instance_variable_get(:@files), '@files must empty' end",True,Ruby,test_verify_security_policy_checksum_missing,test_gem_package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:03-08:00,"Raise a security error when there are duplicate files in a package

This is a rudimentary fix for an issue where RubyGems would allow a
mis-signed gem to be installed, as the tarball would contain multiple
gem signatures.

Nothing should give us a tarball with multiple entries, so we'll just
disallow that.",CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2018-1000076,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = """" 12.times { |i| data << string[i*2, 2].to_i(16) } from_data data end"
1166,"def self.from(stream) header = stream.read 512 empty = (header == ""\0"" * 512) fields = header.unpack UNPACK_FORMAT new :name => fields.shift, :mode => fields.shift.oct, :uid => fields.shift.oct, :gid => fields.shift.oct, :size => fields.shift.oct, :mtime => fields.shift.oct, :checksum => fields.shift.oct, :typeflag => fields.shift, :linkname => fields.shift, :magic => fields.shift, :version => fields.shift.oct, :uname => fields.shift, :gname => fields.shift, :devmajor => fields.shift.oct, :devminor => fields.shift.oct, :prefix => fields.shift, :empty => empty end",True,Ruby,self.from,tar_header.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:03-08:00,"Strictly interpret octal fields in tar headers

Any octal field that contains characters other that 0-7 will cause acn
exception to be raised.

This prevents a negative size from being set, which could cause an
infinite loop.",CWE-835,Loop with Unreachable Exit Condition ('Infinite Loop'),"The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",https://cwe.mitre.org/data/definitions/835.html,CVE-2018-1000075,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = """" 12.times { |i| data << string[i*2, 2].to_i(16) } from_data data end"
1168,"def show_owners name response = rubygems_api_request :get, ""api/v1/gems/#{name}/owners.yaml"" do |request| request.add_field ""Authorization"", api_key end with_response response do |resp| owners = YAML.load resp.body say ""Owners for gem: #{name}"" owners.each do |owner| say ""- #{owner['email'] || owner['handle'] || owner['id']}"" end end end",True,Ruby,show_owners,owner_command.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:04-08:00,Fix possible Unsafe Object Deserialization Vulnerability in gem owner,CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2018-1000074,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = """" 12.times { |i| data << string[i*2, 2].to_i(16) } from_data data end"
1173,"def extract_tar_gz io, destination_dir, pattern = ""*"" # :nodoc: open_tar_gz io do |tar| tar.each do |entry| next unless File.fnmatch pattern, entry.full_name, File::FNM_DOTMATCH destination = install_location entry.full_name, destination_dir FileUtils.rm_rf destination mkdir_options = {} mkdir_options[:mode] = entry.header.mode if entry.directory? mkdir = if entry.directory? then destination else File.dirname destination end FileUtils.mkdir_p mkdir, mkdir_options File.open destination, 'wb' do |out| out.write entry.read FileUtils.chmod entry.header.mode, destination end if entry.file? File.symlink(entry.header.linkname, destination) if entry.symlink? verbose destination end end end",True,Ruby,extract_tar_gz,package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:04-08:00,Implement a safe mkdir for package that verifies were inside the destination dir for all new directories ccreated,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2018-1000079,def __bson_load__(io) from_data(io.read(12)) end
1175,"def install_location filename, destination_dir # :nodoc: raise Gem::Package::PathError.new(filename, destination_dir) if filename.start_with? '/' destination_dir = File.realpath destination_dir if File.respond_to? :realpath destination_dir = File.expand_path destination_dir destination = File.join destination_dir, filename destination = File.realpath destination if File.respond_to? :realpath destination = File.expand_path destination raise Gem::Package::PathError.new(destination, destination_dir) unless destination.start_with? destination_dir + '/' destination.untaint destination end",True,Ruby,install_location,package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:04-08:00,Implement a safe mkdir for package that verifies were inside the destination dir for all new directories ccreated,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2018-1000079,def __bson_load__(io) from_data(io.read(12)) end
1178,"def test_extract_symlink_parent skip 'symlink not supported' if Gem.win_platform? package = Gem::Package.new @gem tgz_io = util_tar_gz do |tar| tar.mkdir 'lib', 0755 tar.add_symlink 'lib/link', '../..', 0644 tar.add_file 'lib/link/outside.txt', 0644 do |io| io.write 'hi' end end # Extract into a subdirectory of @destination; if this test fails it writes # a file outside destination_subdir, but we want the file to remain inside # @destination so it will be cleaned up. destination_subdir = File.join @destination, 'subdir' FileUtils.mkdir_p destination_subdir e = assert_raises Gem::Package::PathError do package.extract_tar_gz tgz_io, destination_subdir end assert_equal(""installing into parent path ../outside.txt of "" + ""#{destination_subdir} is not allowed"", e.message) end",True,Ruby,test_extract_symlink_parent,test_gem_package.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2018-02-15 22:19:04-08:00,Implement a safe mkdir for package that verifies were inside the destination dir for all new directories ccreated,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2018-1000079,def __bson_load__(io) from_data(io.read(12)) end
1180,"def api_endpoint(uri) host = uri.host begin res = @dns.getresource ""_rubygems._tcp.#{host}"", Resolv::DNS::Resource::IN::SRV rescue Resolv::ResolvError => e verbose ""Getting SRV record failed: #{e}"" uri else target = res.target.to_s.strip if /\.#{Regexp.quote(host)}\z/ =~ target return URI.parse ""#{uri.scheme}://#{target}#{uri.path}"" end uri end end",True,Ruby,api_endpoint,remote_fetcher.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,"[RemoteFetcher] Avoid DNS Hijacking Vulnerability

Reported by @claudijd

**Description:**

The RubyGems client supports a gem server API discovery functionality,
which is used when pushing or pulling gems to a gem distribution/hosting
server, like RubyGems.org.  This functionality is provided via a SRV DNS
request to the users gem source hostname prepended with ""_rubygems._tcp."".
The response to this request tells the RubyGems client (aka: the gem
command) where the users gem server API is.  In the default RubyGems
scenario, with a gem source of https://rubygems.org, the users SRV DNS
request and reply will look like this:

    ~ $ dig srv _rubygems._tcp.rubygems.org +short
    0 1 80 api.rubygems.org.

Due to a deficiency in DNS response verification, a MiTM positioned
attacker can poison the DNS response to this record response and force
the client to unknowingly download and install Ruby gems from an attacker
controlled gem server in an alternate security domain.  An example of
such a scenario would look like so:

    ~ $ dig _rubygems._tcp.rubygems.org SRV +short
    0 0 53 evil.com/api.rubygems.com.

In such a scenario, the attacker is able to serve the client malicious gem
content, resulting in trivial remote code execution scenarios.  For
example, the attacker could simply modify the gem source code and trigger
code execution via the extensions API at install time on the client machine
(a gem trojaning technique described by Ben Smith in his ""Hacking with
Gems"" presentation at Aloha Ruby Conference in 2012 -
https://www.youtube.com/watch?v=z-5bO0Q1J9s)/

This vulnerability has the same net effect/impact as [CVE-2015-3900](https://nvd.nist.gov/vuln/detail/CVE-2015-3900) and
[CVE-2015-4020](https://nvd.nist.gov/vuln/detail/CVE-2015-4020).

**Affected method in Gem::RemoteFetcher:**

https://github.com/rubygems/rubygems/blob/5096fa35c1ca3e0a7d175aaf9d77cd93114fd977/lib/rubygems/remote_fetcher.rb#L101-L119

**PoC DNS SRV Responder:**

    #!/usr/bin/env ruby
    require 'rubydns'
    require 'rubydns/system'
    INTERFACES = [
    	[:udp, ""0.0.0.0"", 53],
    	[:tcp, ""0.0.0.0"", 53]
    ]
    Name = Resolv::DNS::Name
    IN = Resolv::DNS::Resource::IN
    RubyDNS::run_server(:listen => INTERFACES) do
      match(//, IN::SRV) do |transaction|
        transaction.respond!(0,0,53,""evil.com/api.rubygems.com"")
      end
    end

**Fix:**

By parsing the returned target as a URI and only matching against the
`hostname`, we can ensure that only subdomains of the original host
are redirected to. This way, adding URI-delimiting characters to the
`target` cannot be used to front-pad the target, creating a
false-positive match.",CWE-346,Origin Validation Error,The product does not properly verify that the source of data or communication is valid.,https://cwe.mitre.org/data/definitions/346.html,CVE-2017-0902,def __bson_load__(io) from_data(io.read(12)) end
1183,"def output_versions output, versions versions.each do |gem_name, matching_tuples| matching_tuples = matching_tuples.sort_by { |n,_| n.version }.reverse platforms = Hash.new { |h,version| h[version] = [] } matching_tuples.each do |n, _| platforms[n.version] << n.platform if n.platform end seen = {} matching_tuples.delete_if do |n,_| if seen[n.version] then true else seen[n.version] = true false end end output << make_entry(matching_tuples, platforms) end end",True,Ruby,output_versions,query_command.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,"Clean any text present in gems before displaying it

This makes sure that any data pulled out of a gem spec is cleaned of all
non-printable characters before printing it. This prevents a gem from
causing havoc with a users terminal.",CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2017-0899,"def initialize(hosts, options) @options = { down_interval: 30, refresh_interval: 300 }.merge(options) @seeds = hosts @nodes = hosts.map { |host| Node.new(host) } end"
1186,"def format_text(text, wrap, indent=0) result = [] work = text.dup while work.length > wrap do if work =~ /^(.{0,#{wrap}})[ \n]/ then result << $1.rstrip work.slice!(0, $&.length) else result << work.slice!(0, wrap) end end result << work if work.length.nonzero? result.join(""\n"").gsub(/^/, "" "" * indent) end",True,Ruby,format_text,text.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,"Clean any text present in gems before displaying it

This makes sure that any data pulled out of a gem spec is cleaned of all
non-printable characters before printing it. This prevents a gem from
causing havoc with a users terminal.",CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2017-0899,"def initialize(hosts, options) @options = { down_interval: 30, refresh_interval: 300 }.merge(options) @seeds = hosts @nodes = hosts.map { |host| Node.new(host) } end"
1190,"def clean_text(text) text.gsub(/[\u0000-\u0008\u000b-\u000c\u000e-\u001F\u007f]/, ""."".freeze) end",True,Ruby,clean_text,text.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,Use a pattern that works on 1.8.7,CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2017-0899,"def initialize(hosts, options) @options = { down_interval: 30, refresh_interval: 300 }.merge(options) @seeds = hosts @nodes = hosts.map { |host| Node.new(host) } end"
1193,"def test_execute_details_cleans_text spec_fetcher do |fetcher| fetcher.spec 'a', 2 do |s| s.summary = 'This is a lot of text. ' * 4 s.authors = [""Abraham Lincoln \u0001"", ""\u0002 Hirohito""] s.homepage = ""http://a.example.com/\u0003"" end fetcher.legacy_platform end @cmd.handle_options %w[-r -d] use_ui @ui do @cmd.execute end expected = <<-EOF *** REMOTE GEMS *** a (2) Authors: Abraham Lincoln ., . Hirohito Homepage: http://a.example.com/. This is a lot of text. This is a lot of text. This is a lot of text. This is a lot of text. pl (1) Platform: i386-linux Author: A User Homepage: http://example.com this is a summary EOF assert_equal expected, @ui.output assert_equal '', @ui.error end",True,Ruby,test_execute_details_cleans_text,test_gem_commands_query_command.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,Use a pattern that works on 1.8.7,CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2017-0899,"def initialize(hosts, options) @options = { down_interval: 30, refresh_interval: 300 }.merge(options) @seeds = hosts @nodes = hosts.map { |host| Node.new(host) } end"
1194,"def spec_summary entry, spec entry << ""\n\n"" << format_text(spec.summary, 68, 4) end",True,Ruby,spec_summary,query_command.rb,https://github.com/rubygems/rubygems,rubygems,Samuel Giddins,2017-08-27 20:37:15-05:00,"Truncate summaries to 100,000 characters in the query command

This avoids a DOS vector where incredibly large summary strings would hang rubygems due to taking forever in Gem::Text.clean_text",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2017-0900,"def insert(documents) documents = [documents] unless documents.is_a? Array database.session.with(consistency: :strong) do |session| session.context.insert(database.name, name, documents) end end"
1204,"def build_gem_lines(conservative_versioning) @deps.map do |d| name = d.name.dump requirement = if conservative_versioning "", \""#{conservative_version(@definition.specs[d.name][0])}\"""" else "", #{d.requirement.as_list.map(&:dump).join("", "")}"" end if d.groups != Array(:default) group = d.groups.size == 1 ? "", :group => #{d.groups.first.inspect}"" : "", :groups => #{d.groups.inspect}"" end source = "", :source => \""#{d.source}\"""" unless d.source.nil? git = "", :git => \""#{d.git}\"""" unless d.git.nil? branch = "", :branch => \""#{d.branch}\"""" unless d.branch.nil? %(gem #{name}#{requirement}#{group}#{source}#{git}#{branch}) end.join(""\n"")",True,Ruby,build_gem_lines,injector.rb,https://github.com/rubygems/rubygems,rubygems,Simon Fish,2021-12-07 15:21:17+00:00,"Add require parameter to `bundle add``

Test and ensure ""false"" is handled

Don't use yield_self to operate on autorequire

Remove duplicate autorequire

Add banner to require option

Don't use json to break down require params

Pass linter",CWE-88,Improper Neutralization of Argument Delimiters in a Command ('Argument Injection'),"The product constructs a string for a command to be executed by a separate component
in another control sphere, but it does not properly delimit the
intended arguments, options, or switches within that command string.",https://cwe.mitre.org/data/definitions/88.html,CVE-2021-43809,"def insert(documents) documents = [documents] unless documents.is_a? Array database.session.with(consistency: :strong) do |session| session.context.insert(database.name, name, documents) end end"
1212,def legal?(str) !!str.match(/^[0-9a-f]{24}$/i) end,True,Ruby,legal?,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def insert(documents) documents = [documents] unless documents.is_a? Array database.session.with(consistency: :strong) do |session| session.context.insert(database.name, name, documents) end end"
1213,def legal?(str) !!str.match(/^[0-9a-f]{24}$/i) end,True,Ruby,legal?,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def insert(documents) documents = [documents] unless documents.is_a? Array database.session.with(consistency: :strong) do |session| session.context.insert(database.name, name, documents) end end"
1214,"def generation_time Time.at(@data.pack(""C4"").unpack(""N"")[0]).utc end",True,Ruby,generation_time,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def each documents = load documents.each { |doc| yield doc } while more? return kill if limited? && @limit <= 0 documents = get_more documents.each { |doc| yield doc } end end
1215,"def generation_time Time.at(@data.pack(""C4"").unpack(""N"")[0]).utc end",True,Ruby,generation_time,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def each documents = load documents.each { |doc| yield doc } while more? return kill if limited? && @limit <= 0 documents = get_more documents.each { |doc| yield doc } end end
1216,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""C3"") @mutex = Mutex.new @last_timestamp = nil @counter = 0 end",True,Ruby,initialize,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def each documents = load documents.each { |doc| yield doc } while more? return kill if limited? && @limit <= 0 documents = get_more documents.each { |doc| yield doc } end end
1217,"def initialize # Generate and cache 3 bytes of identifying information from the current # machine. @machine_id = Digest::MD5.digest(Socket.gethostname).unpack(""C3"") @mutex = Mutex.new @last_timestamp = nil @counter = 0 end",True,Ruby,initialize,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def each documents = load documents.each { |doc| yield doc } while more? return kill if limited? && @limit <= 0 documents = get_more documents.each { |doc| yield doc } end end
1218,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data.pack('C12') end",True,Ruby,__bson_dump__,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(session, query_operation) @session = session @database = query_operation.database @collection = query_operation.collection @selector = query_operation.selector @cursor_id = 0 @limit = query_operation.limit @limited = @limit > 0 @options = { request_id: query_operation.request_id, flags: query_operation.flags, limit: query_operation.limit, skip: query_operation.skip, fields: query_operation.fields } end"
1219,"def __bson_dump__(io, key) io << Types::OBJECT_ID io << key io << NULL_BYTE io << data.pack('C12') end",True,Ruby,__bson_dump__,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(session, query_operation) @session = session @database = query_operation.database @collection = query_operation.collection @selector = query_operation.selector @cursor_id = 0 @limit = query_operation.limit @limited = @limit > 0 @options = { request_id: query_operation.request_id, flags: query_operation.flags, limit: query_operation.limit, skip: query_operation.skip, fields: query_operation.fields } end"
1224,"def next now = Time.new.to_i counter = @mutex.synchronize do last_timestamp, @last_timestamp = @last_timestamp, now if last_timestamp == now @counter += 1 else @counter = 0 end end generate(now, counter) end",True,Ruby,next,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(session, query_operation) @session = session @database = query_operation.database @collection = query_operation.collection @selector = query_operation.selector @cursor_id = 0 @limit = query_operation.limit @limited = @limit > 0 @options = { request_id: query_operation.request_id, flags: query_operation.flags, limit: query_operation.limit, skip: query_operation.skip, fields: query_operation.fields } end"
1225,"def next now = Time.new.to_i counter = @mutex.synchronize do last_timestamp, @last_timestamp = @last_timestamp, now if last_timestamp == now @counter += 1 else @counter = 0 end end generate(now, counter) end",True,Ruby,next,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(session, query_operation) @session = session @database = query_operation.database @collection = query_operation.collection @selector = query_operation.selector @cursor_id = 0 @limit = query_operation.limit @limited = @limit > 0 @options = { request_id: query_operation.request_id, flags: query_operation.flags, limit: query_operation.limit, skip: query_operation.skip, fields: query_operation.fields } end"
1226,"def initialize(data = nil, time = nil) if data @data = data elsif time @data = @@generator.generate(time.to_i) else @data = @@generator.next end end",True,Ruby,initialize,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def more? @cursor_id != 0 end
1227,"def initialize(data = nil, time = nil) if data @data = data elsif time @data = @@generator.generate(time.to_i) else @data = @@generator.next end end",True,Ruby,initialize,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def more? @cursor_id != 0 end
1228,def to_s @@string_format % data end,True,Ruby,to_s,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def more? @cursor_id != 0 end
1229,def to_s @@string_format % data end,True,Ruby,to_s,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def more? @cursor_id != 0 end
1234,"def generate(time, inc = 0) pid = Process.pid % 0xFFFF [ time >> 24 & 0xFF, # 4 bytes time (network order) time >> 16 & 0xFF, time >> 8 & 0xFF, time & 0xFF, @machine_id[0], # 3 bytes machine @machine_id[1], @machine_id[2], pid >> 8 & 0xFF, # 2 bytes process id pid & 0xFF, inc >> 16 & 0xFF, # 3 bytes increment inc >> 8 & 0xFF, inc & 0xFF, ] end",True,Ruby,generate,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def limited? @limited end
1235,"def generate(time, inc = 0) pid = Process.pid % 0xFFFF [ time >> 24 & 0xFF, # 4 bytes time (network order) time >> 16 & 0xFF, time >> 8 & 0xFF, time & 0xFF, @machine_id[0], # 3 bytes machine @machine_id[1], @machine_id[2], pid >> 8 & 0xFF, # 2 bytes process id pid & 0xFF, inc >> 16 & 0xFF, # 3 bytes increment inc >> 8 & 0xFF, inc & 0xFF, ] end",True,Ruby,generate,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def limited? @limited end
1236,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = [] 12.times { |i| data << string[i*2, 2].to_i(16) } new data end",True,Ruby,from_string,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def limited? @limited end
1237,"def from_string(string) raise Errors::InvalidObjectId.new(string) unless legal?(string) data = [] 12.times { |i| data << string[i*2, 2].to_i(16) } new data end",True,Ruby,from_string,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def limited? @limited end
1252,def __bson_load__(io) new io.read(12).unpack('C*') end,True,Ruby,__bson_load__,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def kill @node.kill_cursors [@cursor_id] end
1253,def __bson_load__(io) new io.read(12).unpack('C*') end,True,Ruby,__bson_load__,object_id.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def kill @node.kill_cursors [@cursor_id] end
1254,def remove(server) servers.delete(server) end,True,Ruby,remove,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def kill @node.kill_cursors [@cursor_id] end
1255,def remove(server) servers.delete(server) end,True,Ruby,remove,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def kill @node.kill_cursors [@cursor_id] end
1256,def logout(database) auth.delete(database.to_s) end,True,Ruby,logout,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def logout session.context.logout(name) end
1257,def logout(database) auth.delete(database.to_s) end,True,Ruby,logout,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def logout session.context.logout(name) end
1260,"def initialize(seeds, direct = false) @seeds = seeds @direct = direct @servers = [] @dynamic_seeds = [] end",True,Ruby,initialize,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def logout session.context.logout(name) end
1261,"def initialize(seeds, direct = false) @seeds = seeds @direct = direct @servers = [] @dynamic_seeds = [] end",True,Ruby,initialize,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def logout session.context.logout(name) end
1262,def sync known = known_addresses.shuffle seen = {} sync_seed = ->(seed) do server = Server.new seed unless seen[server.resolved_address] seen[server.resolved_address] = true hosts = sync_server(server) hosts.each do |host| sync_seed[host] end end end known.each do |seed| sync_seed[seed] end unless servers.empty? @dynamic_seeds = servers.map(&:address) end true end,True,Ruby,sync,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def login(username, password) session.context.login(name, username, password) end"
1263,def sync known = known_addresses.shuffle seen = {} sync_seed = ->(seed) do server = Server.new seed unless seen[server.resolved_address] seen[server.resolved_address] = true hosts = sync_server(server) hosts.each do |host| sync_seed[host] end end end known.each do |seed| sync_seed[seed] end unless servers.empty? @dynamic_seeds = servers.map(&:address) end true end,True,Ruby,sync,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def login(username, password) session.context.login(name, username, password) end"
1264,def primaries servers.select(&:primary?) end,True,Ruby,primaries,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def login(username, password) session.context.login(name, username, password) end"
1265,def primaries servers.select(&:primary?) end,True,Ruby,primaries,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def login(username, password) session.context.login(name, username, password) end"
1266,def socket_for(mode) sync unless primaries.any? || (secondaries.any? && mode == :read) server = nil while primaries.any? || (secondaries.any? && mode == :read) if mode == :write || secondaries.empty? server = primaries.sample else server = secondaries.sample end if server socket = server.socket socket.connect unless socket.connection if socket.alive? break server else remove server end end end,True,Ruby,socket_for,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def command(command) session.context.command name, command end"
1267,def socket_for(mode) sync unless primaries.any? || (secondaries.any? && mode == :read) server = nil while primaries.any? || (secondaries.any? && mode == :read) if mode == :write || secondaries.empty? server = primaries.sample else server = secondaries.sample end if server socket = server.socket socket.connect unless socket.connection if socket.alive? break server else remove server end end end,True,Ruby,socket_for,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def command(command) session.context.command name, command end"
1268,"def login(database, username, password) auth[database.to_s] = [username, password] end",True,Ruby,login,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def command(command) session.context.command name, command end"
1269,"def login(database, username, password) auth[database.to_s] = [username, password] end",True,Ruby,login,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def command(command) session.context.command name, command end"
1270,def merge(server) previous = servers.find { |other| other == server } primary = server.primary? secondary = server.secondary? if previous previous.merge(server) else servers << server end end,True,Ruby,merge,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def drop session.with(consistency: :strong) do |session| session.context.command name, dropDatabase: 1 end end"
1271,def merge(server) previous = servers.find { |other| other == server } primary = server.primary? secondary = server.secondary? if previous previous.merge(server) else servers << server end end,True,Ruby,merge,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def drop session.with(consistency: :strong) do |session| session.context.command name, dropDatabase: 1 end end"
1272,def known_addresses [].tap do |addresses| addresses.concat seeds addresses.concat dynamic_seeds addresses.concat servers.map { |server| server.address } end.uniq end,True,Ruby,known_addresses,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def drop session.with(consistency: :strong) do |session| session.context.command name, dropDatabase: 1 end end"
1273,def known_addresses [].tap do |addresses| addresses.concat seeds addresses.concat dynamic_seeds addresses.concat servers.map { |server| server.address } end.uniq end,True,Ruby,known_addresses,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def drop session.with(consistency: :strong) do |session| session.context.command name, dropDatabase: 1 end end"
1274,"def sync_server(server) [].tap do |hosts| socket = server.socket if socket.connect info = socket.simple_query Protocol::Command.new(:admin, ismaster: 1) if info[""ismaster""] server.primary = true end if info[""secondary""] server.secondary = true end if info[""primary""] hosts.push info[""primary""] end if info[""hosts""] hosts.concat info[""hosts""] end if info[""passives""] hosts.concat info[""passives""] end merge(server) end end.uniq end",True,Ruby,sync_server,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(string) super(""'#{string}' is not a valid object id."") end"
1275,"def sync_server(server) [].tap do |hosts| socket = server.socket if socket.connect info = socket.simple_query Protocol::Command.new(:admin, ismaster: 1) if info[""ismaster""] server.primary = true end if info[""secondary""] server.secondary = true end if info[""primary""] hosts.push info[""primary""] end if info[""hosts""] hosts.concat info[""hosts""] end if info[""passives""] hosts.concat info[""passives""] end merge(server) end end.uniq end",True,Ruby,sync_server,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(string) super(""'#{string}' is not a valid object id."") end"
1280,def reconnect @servers = servers.map { |server| Server.new(server.address) } end,True,Ruby,reconnect,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(string) super(""'#{string}' is not a valid object id."") end"
1281,def reconnect @servers = servers.map { |server| Server.new(server.address) } end,True,Ruby,reconnect,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(string) super(""'#{string}' is not a valid object id."") end"
1284,def secondaries servers.select(&:secondary?) end,True,Ruby,secondaries,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(database, command, options = {}) super database, :$cmd, command, options.merge(limit: -1) end"
1285,def secondaries servers.select(&:secondary?) end,True,Ruby,secondaries,cluster.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(database, command, options = {}) super database, :$cmd, command, options.merge(limit: -1) end"
1290,"def insert(documents) documents = [documents] unless documents.is_a? Array insert = Protocol::Insert.new(database.name, name, documents) database.session.with(consistency: :strong) do |session| session.execute insert end end",True,Ruby,insert,collection.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(database, command, options = {}) super database, :$cmd, command, options.merge(limit: -1) end"
1291,"def insert(documents) documents = [documents] unless documents.is_a? Array insert = Protocol::Insert.new(database.name, name, documents) database.session.with(consistency: :strong) do |session| session.execute insert end end",True,Ruby,insert,collection.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(database, command, options = {}) super database, :$cmd, command, options.merge(limit: -1) end"
1314,def each documents = query @query_op documents.each { |doc| yield doc } while more? return kill if limited? && @get_more_op.limit <= 0 documents = query @get_more_op documents.each { |doc| yield doc } end end,True,Ruby,each,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector, flags: [:remove_first] end end"
1315,def each documents = query @query_op documents.each { |doc| yield doc } while more? return kill if limited? && @get_more_op.limit <= 0 documents = query @get_more_op documents.each { |doc| yield doc } end end,True,Ruby,each,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector, flags: [:remove_first] end end"
1316,"def initialize(session, query_operation) @session = session @query_op = query_operation.dup @get_more_op = Protocol::GetMore.new( @query_op.database, @query_op.collection, 0, @query_op.limit ) @kill_cursor_op = Protocol::KillCursors.new([0]) end",True,Ruby,initialize,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector, flags: [:remove_first] end end"
1317,"def initialize(session, query_operation) @session = session @query_op = query_operation.dup @get_more_op = Protocol::GetMore.new( @query_op.database, @query_op.collection, 0, @query_op.limit ) @kill_cursor_op = Protocol::KillCursors.new([0]) end",True,Ruby,initialize,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector, flags: [:remove_first] end end"
1322,def more? @get_more_op.cursor_id != 0 end,True,Ruby,more?,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove_all session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector end end"
1323,def more? @get_more_op.cursor_id != 0 end,True,Ruby,more?,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_all session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector end end"
1326,def limited? @query_op.limit > 0 end,True,Ruby,limited?,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove_all session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector end end"
1327,def limited? @query_op.limit > 0 end,True,Ruby,limited?,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_all session.with(consistency: :strong) do |session| session.context.remove operation.database, operation.collection, operation.selector end end"
1330,def query(operation) reply = session.query operation @get_more_op.limit -= reply.count if limited? @get_more_op.cursor_id = reply.cursor_id @kill_cursor_op.cursor_ids = [reply.cursor_id] reply.documents end,True,Ruby,query,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def update(change, flags = nil) session.with(consistency: :strong) do |session| session.context.update operation.database, operation.collection, operation.selector, change, flags: flags end end"
1331,def query(operation) reply = session.query operation @get_more_op.limit -= reply.count if limited? @get_more_op.cursor_id = reply.cursor_id @kill_cursor_op.cursor_ids = [reply.cursor_id] reply.documents end,True,Ruby,query,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def update(change, flags = nil) session.with(consistency: :strong) do |session| session.context.update operation.database, operation.collection, operation.selector, change, flags: flags end end"
1334,def kill session.execute kill_cursor_op end,True,Ruby,kill,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def update(change, flags = nil) session.with(consistency: :strong) do |session| session.context.update operation.database, operation.collection, operation.selector, change, flags: flags end end"
1335,def kill session.execute kill_cursor_op end,True,Ruby,kill,cursor.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def update(change, flags = nil) session.with(consistency: :strong) do |session| session.context.update operation.database, operation.collection, operation.selector, change, flags: flags end end"
1342,def logout session.cluster.logout(name) end,True,Ruby,logout,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def each cursor = Cursor.new(session, operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end"
1343,def logout session.cluster.logout(name) end,True,Ruby,logout,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def each cursor = Cursor.new(session, operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end"
1348,"def login(username, password) session.cluster.login(name, username, password) end",True,Ruby,login,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def each cursor = Cursor.new(session, operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end"
1349,"def login(username, password) session.cluster.login(name, username, password) end",True,Ruby,login,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def each cursor = Cursor.new(session, operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end"
1350,"def command(command) operation = Protocol::Command.new(name, command) result = session.with(consistency: :strong) do |session| session.simple_query(operation) end raise Errors::OperationFailure.new( operation, result ) unless result[""ok""] == 1.0 result end",True,Ruby,command,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def first limit(-1).each.first end
1351,"def command(command) operation = Protocol::Command.new(name, command) result = session.with(consistency: :strong) do |session| session.simple_query(operation) end raise Errors::OperationFailure.new( operation, result ) unless result[""ok""] == 1.0 result end",True,Ruby,command,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def first limit(-1).each.first end
1354,def drop command dropDatabase: 1 end,True,Ruby,drop,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def first limit(-1).each.first end
1355,def drop command dropDatabase: 1 end,True,Ruby,drop,database.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def first limit(-1).each.first end
1356,"def initialize(string) super(""'#{string}' is not a valid object id."") end",True,Ruby,initialize,errors.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds, {}) @context = Context.new(self) @options = options @options[:consistency] ||= :eventual end"
1357,"def initialize(string) super(""'#{string}' is not a valid object id."") end",True,Ruby,initialize,errors.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds, {}) @context = Context.new(self) @options = options @options[:consistency] ||= :eventual end"
1426,"def initialize(database, command) super database, :$cmd, command, limit: -1 end",True,Ruby,initialize,command.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds, {}) @context = Context.new(self) @options = options @options[:consistency] ||= :eventual end"
1427,"def initialize(database, command) super database, :$cmd, command, limit: -1 end",True,Ruby,initialize,command.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds, {}) @context = Context.new(self) @options = options @options[:consistency] ||= :eventual end"
1436,"def remove delete = Protocol::Delete.new( operation.database, operation.collection, operation.selector, flags: [:remove_first] ) session.with(consistency: :strong) do |session| session.execute delete end end",True,Ruby,remove,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end"
1437,"def remove delete = Protocol::Delete.new( operation.database, operation.collection, operation.selector, flags: [:remove_first] ) session.with(consistency: :strong) do |session| session.execute delete end end",True,Ruby,remove,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end"
1440,"def remove_all delete = Protocol::Delete.new( operation.database, operation.collection, operation.selector ) session.with(consistency: :strong) do |session| session.execute delete end end",True,Ruby,remove_all,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end"
1441,"def remove_all delete = Protocol::Delete.new( operation.database, operation.collection, operation.selector ) session.with(consistency: :strong) do |session| session.execute delete end end",True,Ruby,remove_all,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end"
1444,"def update(change, flags = nil) update = Protocol::Update.new( operation.database, operation.collection, operation.selector, change, flags: flags ) session.with(consistency: :strong) do |session| session.execute update end end",True,Ruby,update,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def new(options = {}) session = with(options) session.instance_variable_set(:@cluster, cluster.dup) if block_given? yield session else session end end"
1445,"def update(change, flags = nil) update = Protocol::Update.new( operation.database, operation.collection, operation.selector, change, flags: flags ) session.with(consistency: :strong) do |session| session.execute update end end",True,Ruby,update,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def new(options = {}) session = with(options) session.instance_variable_set(:@cluster, cluster.dup) if block_given? yield session else session end end"
1448,"def each cursor = Cursor.new(session.with(retain_socket: true), operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end",True,Ruby,each,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def new(options = {}) session = with(options) session.instance_variable_set(:@cluster, cluster.dup) if block_given? yield session else session end end"
1449,"def each cursor = Cursor.new(session.with(retain_socket: true), operation) cursor.to_enum.tap do |enum| enum.each do |document| yield document end if block_given? end end",True,Ruby,each,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def new(options = {}) session = with(options) session.instance_variable_set(:@cluster, cluster.dup) if block_given? yield session else session end end"
1450,def first session.simple_query(operation) end,True,Ruby,first,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns the same hash"" do Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash end"
1451,def first session.simple_query(operation) end,True,Ruby,first,query.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns the same hash"" do Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash end"
1452,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds) @options = options @options[:consistency] ||= :eventual end",True,Ruby,initialize,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns the same hash"" do Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash end"
1453,"def initialize(seeds, options = {}) @cluster = Cluster.new(seeds) @options = options @options[:consistency] ||= :eventual end",True,Ruby,initialize,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns the same hash"" do Moped::BSON::ObjectId.from_data(bytes).hash.should eq Moped::BSON::ObjectId.from_data(bytes).hash end"
1456,"def dup session = super session.instance_variable_set :@options, options.dup if defined? @current_database session.send(:remove_instance_variable, :@current_database) end session end",True,Ruby,dup,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns true"" do Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes) end"
1457,"def dup session = super session.instance_variable_set :@options, options.dup if defined? @current_database session.send(:remove_instance_variable, :@current_database) end session end",True,Ruby,dup,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns true"" do Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes) end"
1460,"def query(query) if options[:consistency] == :eventual query.flags |= [:slave_ok] if query.respond_to? :flags mode = :read else mode = :write end reply = socket_for(mode).execute(query) reply.tap do |reply| if reply.flags.include?(:query_failure) raise Errors::QueryFailure.new(query, reply.documents.first) end end end",True,Ruby,query,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns true"" do Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes) end"
1461,"def query(query) if options[:consistency] == :eventual query.flags |= [:slave_ok] if query.respond_to? :flags mode = :read else mode = :write end reply = socket_for(mode).execute(query) reply.tap do |reply| if reply.flags.include?(:query_failure) raise Errors::QueryFailure.new(query, reply.documents.first) end end end",True,Ruby,query,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns true"" do Moped::BSON::ObjectId.from_data(bytes).should == Moped::BSON::ObjectId.from_data(bytes) end"
1462,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end",True,Ruby,current_database,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.from_data(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end"
1463,"def current_database return @current_database if defined? @current_database if database = options[:database] set_current_database(database) else raise ""No database set for session. Call #use or #with before accessing the database"" end end",True,Ruby,current_database,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.from_data(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end"
1464,def simple_query(query) query.limit = -1 query(query).documents.first end,True,Ruby,simple_query,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.from_data(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end"
1465,def simple_query(query) query.limit = -1 query(query).documents.first end,True,Ruby,simple_query,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.from_data(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end"
1466,def new(options = {}) session = with(options) session.cluster.reconnect if block_given? yield session else session end end,True,Ruby,new,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.from_time(time).generation_time.should == time end"
1467,def new(options = {}) session = with(options) session.cluster.reconnect if block_given? yield session else session end end,True,Ruby,new,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.from_time(time).generation_time.should == time end"
1472,"def execute(op) mode = options[:consistency] == :eventual ? :read : :write socket = socket_for(mode) if safe? last_error = Protocol::Command.new( ""admin"", { getlasterror: 1 }.merge(safety) ) socket.execute(op, last_error).documents.first.tap do |result| raise Errors::OperationFailure.new( op, result ) if result[""err""] || result[""errmsg""] end else socket.execute(op) end end",True,Ruby,execute,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.from_time(time).generation_time.should == time end"
1473,"def execute(op) mode = options[:consistency] == :eventual ? :read : :write socket = socket_for(mode) if safe? last_error = Protocol::Command.new( ""admin"", { getlasterror: 1 }.merge(safety) ) socket.execute(op, last_error).documents.first.tap do |result| raise Errors::OperationFailure.new( op, result ) if result[""err""] || result[""errmsg""] end else socket.execute(op) end end",True,Ruby,execute,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.from_time(time).generation_time.should == time end"
1476,def socket_for(mode) if options[:retain_socket] @socket ||= cluster.socket_for(mode) else cluster.socket_for(mode) end end,True,Ruby,socket_for,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""drops the collection"" do result = session[:users].drop result[""ns""].should eq ""moped_test.users"" end"
1477,def socket_for(mode) if options[:retain_socket] @socket ||= cluster.socket_for(mode) else cluster.socket_for(mode) end end,True,Ruby,socket_for,session.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""drops the collection"" do result = session[:users].drop result[""ns""].should eq ""moped_test.users"" end"
1512,"it ""returns the same hash"" do Moped::BSON::ObjectId.new(bytes).hash.should eq Moped::BSON::ObjectId.new(bytes).hash end",True,Ruby,"""returns the same hash""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""drops the collection"" do result = session[:users].drop result[""ns""].should eq ""moped_test.users"" end"
1513,"it ""returns the same hash"" do Moped::BSON::ObjectId.new(bytes).hash.should eq Moped::BSON::ObjectId.new(bytes).hash end",True,Ruby,"""returns the same hash""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""drops the collection"" do result = session[:users].drop result[""ns""].should eq ""moped_test.users"" end"
1514,"it ""sets the object id's data"" do Moped::BSON::ObjectId.new(bytes).data.should == bytes end",True,Ruby,"""sets the object id's data""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""removes the first matching document"" do users.insert(documents) users.find(scope: scope).remove users.find(scope: scope).count.should eq 1 end"
1515,"it ""sets the object id's data"" do Moped::BSON::ObjectId.new(bytes).data.should == bytes end",True,Ruby,"""sets the object id's data""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""removes the first matching document"" do users.insert(documents) users.find(scope: scope).remove users.find(scope: scope).count.should eq 1 end"
1516,"it ""returns true"" do Moped::BSON::ObjectId.new(bytes).should == Moped::BSON::ObjectId.new(bytes) end",True,Ruby,"""returns true""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""removes the first matching document"" do users.insert(documents) users.find(scope: scope).remove users.find(scope: scope).count.should eq 1 end"
1517,"it ""returns true"" do Moped::BSON::ObjectId.new(bytes).should == Moped::BSON::ObjectId.new(bytes) end",True,Ruby,"""returns true""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""removes the first matching document"" do users.insert(documents) users.find(scope: scope).remove users.find(scope: scope).count.should eq 1 end"
1518,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.new(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end",True,Ruby,"""returns a hex string representation of the id""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""updates to a mongo advanced selector"" do stats = Support::Stats.collect do users.find(scope: scope).sort(_id: 1).explain end operation = stats[node_for_reads].grep(Moped::Protocol::Query).last operation.selector.should eq( ""$query"" => { scope: scope }, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end"
1519,"it ""returns a hex string representation of the id"" do Moped::BSON::ObjectId.new(bytes).to_s.should eq ""4e4d66343b39b68407000001"" end",True,Ruby,"""returns a hex string representation of the id""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""updates to a mongo advanced selector"" do stats = Support::Stats.collect do users.find(scope: scope).sort(_id: 1).explain end operation = stats[node_for_reads].grep(Moped::Protocol::Query).last operation.selector.should eq( ""$query"" => { scope: scope }, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end"
1522,"it ""initializes with the strings bytes"" do Moped::BSON::ObjectId.should_receive(:new).with(bytes) Moped::BSON::ObjectId.from_string ""4e4d66343b39b68407000001"" end",True,Ruby,"""initializes with the strings bytes""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""updates to a mongo advanced selector"" do stats = Support::Stats.collect do users.find(scope: scope).sort(_id: 1).explain end operation = stats[node_for_reads].grep(Moped::Protocol::Query).last operation.selector.should eq( ""$query"" => { scope: scope }, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end"
1523,"it ""initializes with the strings bytes"" do Moped::BSON::ObjectId.should_receive(:new).with(bytes) Moped::BSON::ObjectId.from_string ""4e4d66343b39b68407000001"" end",True,Ruby,"""initializes with the strings bytes""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""updates to a mongo advanced selector"" do stats = Support::Stats.collect do users.find(scope: scope).sort(_id: 1).explain end operation = stats[node_for_reads].grep(Moped::Protocol::Query).last operation.selector.should eq( ""$query"" => { scope: scope }, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end"
1526,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.new(nil, time).generation_time.should == time end",True,Ruby,"""sets the generation time""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""removes all matching documents"" do users.insert(documents) users.find(scope: scope).remove_all users.find(scope: scope).count.should eq 0 end"
1527,"it ""sets the generation time"" do time = Time.at((Time.now.utc - 64800).to_i).utc Moped::BSON::ObjectId.new(nil, time).generation_time.should == time end",True,Ruby,"""sets the generation time""",object_id_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""removes all matching documents"" do users.insert(documents) users.find(scope: scope).remove_all users.find(scope: scope).count.should eq 0 end"
1530,"it ""returns the socket"" do cluster.stub(:sync) { cluster.servers << server } cluster.socket_for(:write).should eq socket end",True,Ruby,"""returns the socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""removes all matching documents"" do users.insert(documents) users.find(scope: scope).remove_all users.find(scope: scope).count.should eq 0 end"
1531,"it ""returns the socket"" do cluster.stub(:sync) { cluster.servers << server } cluster.socket_for(:write).should eq socket end",True,Ruby,"""returns the socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""removes all matching documents"" do users.insert(documents) users.find(scope: scope).remove_all users.find(scope: scope).count.should eq 0 end"
1532,"it ""raises no exception"" do lambda do cluster.sync_server server end.should_not raise_exception end",True,Ruby,"""raises no exception""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def legal?(string) string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false end
1533,"it ""raises no exception"" do lambda do cluster.sync_server server end.should_not raise_exception end",True,Ruby,"""raises no exception""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def legal?(string) string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false end
1534,"it ""returns all other known hosts"" do cluster.sync_server(server).should =~ [""localhost:61085"", ""localhost:61086"", ""localhost:61084""] end",True,Ruby,"""returns all other known hosts""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def legal?(string) string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false end
1535,"it ""returns all other known hosts"" do cluster.sync_server(server).should =~ [""localhost:61085"", ""localhost:61086"", ""localhost:61084""] end",True,Ruby,"""returns all other known hosts""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def legal?(string) string.to_s =~ /\A[0-9a-f]{24}\z/i ? true : false end
1538,"it ""returns nothing"" do socket.stub(connect: false) cluster.sync_server(server).should be_empty end",True,Ruby,"""returns nothing""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(image_path, colors=16, depth=8) output = `convert #{image_path.shellescape} -resize 400x400 -format %c -dither None -quantize YIQ -colors #{colors.to_i} -depth #{depth.to_i} histogram:info:-` @lines = output.lines.sort.reverse.map(&:strip).reject(&:empty?) end"
1539,"it ""returns nothing"" do socket.stub(connect: false) cluster.sync_server(server).should be_empty end",True,Ruby,"""returns nothing""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_should_sanitize_with_trailing_space raw = ""display:block; "" expected = ""display:block;"" assert_equal expected, sanitize_css(raw) end"
1542,"it ""returns the living socket"" do cluster.socket_for(:write).should eq socket end",True,Ruby,"""returns the living socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def test_should_sanitize_illegal_style_properties raw = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;) expected = %(display:block;width:100%;height:100%;background-color:black;background-x:center;background-y:center;) assert_equal expected, sanitize_css(raw) end"
1543,"it ""returns the living socket"" do cluster.socket_for(:write).should eq socket end",True,Ruby,"""returns the living socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_sanitize_script assert_sanitized ""a b c<script language=\""Javascript\"">blah blah blah</script>d e f"", ""a b cblah blah blahd e f"" end"
1544,"it ""adds the server to the list"" do cluster.sync_server server cluster.servers.should include server end",True,Ruby,"""adds the server to the list""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def scope_allowed_attributes(attributes) old_attributes = Rails::Html::WhiteListSanitizer.allowed_attributes Rails::Html::WhiteListSanitizer.allowed_attributes = attributes yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_attributes = old_attributes end
1545,"it ""adds the server to the list"" do cluster.sync_server server cluster.servers.should include server end",True,Ruby,"""adds the server to the list""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_should_sanitize_img_dynsrc_lowsrc assert_sanitized(%(<img lowsrc=""javascript:alert('XSS')"" />), ""<img />"") end def test_should_sanitize_div_background_image_unicode_encoded raw = %(background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029) assert_equal '', sanitize_css(raw) end def test_should_sanitize_div_style_expression raw = %(width: expression(alert('XSS'));) assert_equal '', sanitize_css(raw) end def test_should_sanitize_across_newlines raw = %(\nwidth:\nexpression(alert('XSS'));\n) assert_equal '', sanitize_css(raw) end def test_should_sanitize_img_vbscript assert_sanitized %(<img src='vbscript:msgbox(""XSS"")' />), '<img />' end def test_should_sanitize_cdata_section assert_sanitized ""<![CDATA[<span>section</span>]]>"", ""section]]&gt;"" end def test_should_sanitize_unterminated_cdata_section assert_sanitized ""<![CDATA[<span>neverending..."", ""neverending..."" end def test_should_not_mangle_urls_with_ampersand assert_sanitized %{<a href=\""http://www.domain.com?var1=1&amp;var2=2\"">my link</a>} end def test_should_sanitize_neverending_attribute assert_sanitized ""<span class=\""\\"", ""<span class=\""\\\"">"" end [ %(<a href=""javascript&#x3a;alert('XSS');"">), %(<a href=""javascript&#x003a;alert('XSS');"">), %(<a href=""javascript&#x3A;alert('XSS');"">), %(<a href=""javascript&#x003A;alert('XSS');"">) ].each_with_index do |enc_hack, i| define_method ""test_x03a_handling_#{i+1}"" do assert_sanitized enc_hack, ""<a>"" end end def test_x03a_legitimate assert_sanitized %(<a href=""http&#x3a;//legit"">), %(<a href=""http://legit"">) assert_sanitized %(<a href=""http&#x3A;//legit"">), %(<a href=""http://legit"">) end def test_sanitize_ascii_8bit_string white_list_sanitize('<a>hello</a>'.encode('ASCII-8BIT')).tap do |sanitized| assert_equal '<a>hello</a>', sanitized assert_equal Encoding::UTF_8, sanitized.encoding end end def test_sanitize_data_attributes assert_sanitized %(<a href=""/blah"" data-method=""post"">foo</a>), %(<a href=""/blah"">foo</a>) assert_sanitized %(<a data-remote=""true"" data-type=""script"" data-method=""get"" data-cross-domain=""true"" href=""attack.js"">Launch the missiles</a>), %(<a href=""attack.js"">Launch the missiles</a>) end def test_allow_data_attribute_if_requested text = %(<a data-foo=""foo"">foo</a>) assert_equal %(<a data-foo=""foo"">foo</a>), white_list_sanitize(text, attributes: ['data-foo']) end protected def xpath_sanitize(input, options = {}) XpathRemovalTestSanitizer.new.sanitize(input, options) end def full_sanitize(input, options = {}) Rails::Html::FullSanitizer.new.sanitize(input, options) end def link_sanitize(input, options = {}) Rails::Html::LinkSanitizer.new.sanitize(input, options) end def white_list_sanitize(input, options = {}) Rails::Html::WhiteListSanitizer.new.sanitize(input, options) end def assert_sanitized(input, expected = nil) if input assert_dom_equal expected || input, white_list_sanitize(input) else assert_nil white_list_sanitize(input) end end def sanitize_css(input) Rails::Html::WhiteListSanitizer.new.sanitize_css(input) end def scope_allowed_tags(tags) old_tags = Rails::Html::WhiteListSanitizer.allowed_tags Rails::Html::WhiteListSanitizer.allowed_tags = tags yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_tags = old_tags end def scope_allowed_attributes(attributes) old_attributes = Rails::Html::WhiteListSanitizer.allowed_attributes Rails::Html::WhiteListSanitizer.allowed_attributes = attributes yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_attributes = old_attributes end end"
1546,"it ""applies the cached authentication"" do cluster.stub(:sync) { cluster.servers << server } socket.should_receive(:apply_auth).with(cluster.auth) cluster.socket_for(:write) end",True,Ruby,"""applies the cached authentication""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def scope_allowed_tags(tags) old_tags = Rails::Html::WhiteListSanitizer.allowed_tags Rails::Html::WhiteListSanitizer.allowed_tags = tags yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_tags = old_tags end
1547,"it ""applies the cached authentication"" do cluster.stub(:sync) { cluster.servers << server } socket.should_receive(:apply_auth).with(cluster.auth) cluster.socket_for(:write) end",True,Ruby,"""applies the cached authentication""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_should_allow_anchors assert_sanitized %(<a href=""foo"" onclick=""bar""><script>baz</script></a>), %(<a href=\""foo\"">baz</a>) end def test_video_poster_sanitization scope_allowed_tags(%w(video)) do scope_allowed_attributes %w(src poster) do assert_sanitized %(<video src=""videofile.ogg"" autoplay poster=""posterimage.jpg""></video>), %(<video src=""videofile.ogg"" poster=""posterimage.jpg""></video>) assert_sanitized %(<video src=""videofile.ogg"" poster=javascript:alert(1)></video>), %(<video src=""videofile.ogg""></video>) end end end # RFC 3986, sec 4.2 def test_allow_colons_in_path_component assert_sanitized ""<a href=\""./this:that\"">foo</a>"" end"
1548,"it ""has an empty list of dynamic seeds"" do cluster.dynamic_seeds.should be_empty end",True,Ruby,"""has an empty list of dynamic seeds""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def properly_encode(fragment, options) fragment.xml? ? fragment.to_xml(options) : fragment.to_html(options) end"
1549,"it ""has an empty list of dynamic seeds"" do cluster.dynamic_seeds.should be_empty end",True,Ruby,"""has an empty list of dynamic seeds""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def sanitize(html, options = {}) return unless html return html if html.empty? loofah_fragment = Loofah.fragment(html) remove_xpaths(loofah_fragment, XPATHS_TO_REMOVE) loofah_fragment.scrub!(TextOnlyScrubber.new) properly_encode(loofah_fragment, encoding: 'UTF-8') end"
1550,"it ""raises a connection failure exception"" do cluster.sync_server(server).should be_empty end",True,Ruby,"""raises a connection failure exception""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,def skip_node?(node) node.text? end
1551,"it ""raises a connection failure exception"" do cluster.sync_server(server).should be_empty end",True,Ruby,"""raises a connection failure exception""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def protected! gui_request = ( # these are URLs for web pages request.path == '/' or request.path == '/manage' or request.path == '/permissions' or request.path.match('/managec/.+/main') ) if request.path.start_with?('/remote/') or request.path == '/run_pcs' unless PCSAuth.loginByToken(session, cookies) halt [401, '{""notauthorized"":""true""}'] end else #/managec/* /manage/* /permissions if !gui_request and request.env['HTTP_X_REQUESTED_WITH'] != 'XMLHttpRequest' then # Accept non GUI requests only with header # ""X_REQUESTED_WITH: XMLHttpRequest"". (check if they are send via AJAX). # This prevents CSRF attack. halt [401, '{""notauthorized"":""true""}'] elsif not PCSAuth.isLoggedIn(session) if gui_request session[:pre_login_path] = request.path redirect '/login' else halt [401, '{""notauthorized"":""true""}'] end end end end"
1552,"it ""removes the stored credentials"" do cluster.logout :admin cluster.auth.should be_empty end",True,Ruby,"""removes the stored credentials""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def self.loginByToken(cookies) auth_user = {} if username = validToken(cookies[""token""]) if SUPERUSER == username if cookies['CIB_user'] and cookies['CIB_user'].strip != '' auth_user[:username] = cookies['CIB_user'] if cookies['CIB_user_groups'] and cookies['CIB_user_groups'].strip != '' auth_user[:usergroups] = cookieUserDecode( cookies['CIB_user_groups'] ).split(nil) else auth_user[:usergroups] = [] end else auth_user[:username] = SUPERUSER auth_user[:usergroups] = [] end return auth_user else auth_user[:username] = username success, groups = getUsersGroups(username) auth_user[:usergroups] = success ? groups : [] return auth_user end end return nil end"
1553,"it ""removes the stored credentials"" do cluster.logout :admin cluster.auth.should be_empty end",True,Ruby,"""removes the stored credentials""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def self.getUsersGroups(username) stdout, stderr, retval = run_cmd( getSuperuserAuth(), ""id"", ""-Gn"", username ) if retval != 0 $logger.info( ""Unable to determine groups of user '#{username}': #{stderr.join(' ').strip}"" ) return [false, []] end return [true, stdout.join(' ').split(nil)] end"
1558,"it ""does not re-sync the cluster"" do cluster.should_receive(:sync).never cluster.socket_for :write end",True,Ruby,"""does not re-sync the cluster""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def self.loginByPassword(username, password) if validUser(username, password) auth_user = {} auth_user[:username] = username success, groups = getUsersGroups(username) auth_user[:usergroups] = success ? groups : [] return auth_user end return nil end"
1559,"it ""does not re-sync the cluster"" do cluster.should_receive(:sync).never cluster.socket_for :write end",True,Ruby,"""does not re-sync the cluster""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(auth_user, configs, nodes, cluster_name, tokens={}) @configs = configs @nodes = nodes @cluster_name = cluster_name @published_configs_names = @configs.collect { |cfg| cfg.class.name } @additional_tokens = tokens @auth_user = auth_user end"
1560,"it ""adds the credentials to the auth cache"" do cluster.login(""admin"", ""username"", ""password"") cluster.auth.should eq(""admin"" => [""username"", ""password""]) end",True,Ruby,"""adds the credentials to the auth cache""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(auth_user, config_classes, nodes, cluster_name) @config_classes = config_classes @nodes = nodes @cluster_name = cluster_name @auth_user = auth_user end"
1561,"it ""adds the credentials to the auth cache"" do cluster.login(""admin"", ""username"", ""password"") cluster.auth.should eq(""admin"" => [""username"", ""password""]) end",True,Ruby,"""adds the credentials to the auth cache""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def self.save_sync_new_version(config, nodes, cluster_name, fetch_on_conflict, tokens={}) if not cluster_name or cluster_name.empty? # we run on a standalone host, no config syncing config.version += 1 config.save() return true, {} else # we run in a cluster so we need to sync the config publisher = ConfigPublisher.new( PCSAuth.getSuperuserAuth(), [config], nodes, cluster_name, tokens ) old_configs, node_responses = publisher.publish() if old_configs.include?(config.class.name) if fetch_on_conflict fetcher = ConfigFetcher.new( PCSAuth.getSuperuserAuth(), [config.class], nodes, cluster_name ) cfgs_to_save, _ = fetcher.fetch() cfgs_to_save.each { |cfg_to_save| cfg_to_save.save() if cfg_to_save.class == config.class } end return false, node_responses end return true, node_responses end end"
1564,"it ""has an empty list of secondaries"" do cluster.secondaries.should be_empty end",True,Ruby,"""has an empty list of secondaries""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def send(force=false) nodes_txt = @nodes.join(', ') @configs.each { |cfg| $logger.info( ""Sending config '#{cfg.class.name}' version #{cfg.version} #{cfg.hash}""\ + "" to nodes: #{nodes_txt}"" ) } data = self.prepare_request_data(@configs, @cluster_name, force) node_response = {} threads = [] @nodes.each { |node| threads << Thread.new { code, out = send_request_with_token( @auth_user, node, 'set_configs', true, data, true, nil, 30, @additional_tokens ) if 200 == code begin node_response[node] = JSON.parse(out) rescue JSON::ParserError end elsif 404 == code node_response[node] = {'status' => 'not_supported'} else begin response = JSON.parse(out) if true == response['notauthorized'] or true == response['notoken'] node_response[node] = {'status' => 'notauthorized'} end rescue JSON::ParserError end end if not node_response.key?(node) node_response[node] = {'status' => 'error'} end # old pcsd returns this instead of 404 if pacemaker isn't running there if node_response[node]['pacemaker_not_running'] node_response[node] = {'status' => 'not_supported'} end } } threads.each { |t| t.join } node_response.each { |node, response| $logger.info(""Sending config response from #{node}: #{response}"") } return node_response end"
1565,"it ""has an empty list of secondaries"" do cluster.secondaries.should be_empty end",True,Ruby,"""has an empty list of secondaries""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def self.save_sync_new_tokens(config, new_tokens, nodes, cluster_name) with_new_tokens = PCSTokens.new(config.text) with_new_tokens.tokens.update(new_tokens) config_new = PcsdTokens.from_text(with_new_tokens.text) if not cluster_name or cluster_name.empty? # we run on a standalone host, no config syncing config_new.version += 1 config_new.save() return true, {} end # we run in a cluster so we need to sync the config publisher = ConfigPublisher.new( PCSAuth.getSuperuserAuth(), [config_new], nodes, cluster_name, new_tokens ) old_configs, node_responses = publisher.publish() if not old_configs.include?(config_new.class.name) # no node had newer tokens file, we are ok, everything done return true, node_responses end # get tokens from all nodes and merge them fetcher = ConfigFetcher.new( PCSAuth.getSuperuserAuth(), [config_new.class], nodes, cluster_name ) fetched_tokens = fetcher.fetch_all()[config_new.class.name] config_new = Cfgsync::merge_tokens_files(config, fetched_tokens, new_tokens) # and try to publish again return Cfgsync::save_sync_new_version( config_new, nodes, cluster_name, true, new_tokens ) end"
1566,"it ""syncs each seed node"" do server = Moped::Server.allocate Moped::Server.should_receive(:new).with(""127.0.0.1:27017"").and_return(server) cluster.should_receive(:sync_server).with(server).and_return([]) cluster.sync end",True,Ruby,"""syncs each seed node""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def initialize(auth_user, configs, nodes, cluster_name, tokens={}) @configs = configs @nodes = nodes @cluster_name = cluster_name @published_configs_names = @configs.collect { |cfg| cfg.class.name } @additional_tokens = tokens @auth_user = auth_user end"
1567,"it ""syncs each seed node"" do server = Moped::Server.allocate Moped::Server.should_receive(:new).with(""127.0.0.1:27017"").and_return(server) cluster.should_receive(:sync_server).with(server).and_return([]) cluster.sync end",True,Ruby,"""syncs each seed node""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(auth_user, config_classes, nodes, cluster_name) @config_classes = config_classes @nodes = nodes @cluster_name = cluster_name @auth_user = auth_user end"
1568,"it ""adds the node to the master set"" do cluster.sync_server server cluster.primaries.should include server end",True,Ruby,"""adds the node to the master set""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_configs_cluster(nodes, cluster_name) data = { 'cluster_name' => cluster_name, } $logger.debug 'Fetching configs from the cluster' threads = [] node_configs = {} nodes.each { |node| threads << Thread.new { code, out = send_request_with_token( @auth_user, node, 'get_configs', false, data ) if 200 == code begin parsed = JSON::parse(out) if 'ok' == parsed['status'] and cluster_name == parsed['cluster_name'] node_configs[node], _ = Cfgsync::sync_msg_to_configs(parsed) end rescue JSON::ParserError end end } } threads.each { |t| t.join } return node_configs end"
1569,"it ""adds the node to the master set"" do cluster.sync_server server cluster.primaries.should include server end",True,Ruby,"""adds the node to the master set""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def self.load_current_node(crm_dom=nil) node = ClusterEntity::Node.new node.corosync = corosync_running? node.corosync_enabled = corosync_enabled? node.pacemaker = pacemaker_running? node.pacemaker_enabled = pacemaker_enabled? node.cman = cman_running? node.pcsd_enabled = pcsd_enabled? node_online = (node.corosync and node.pacemaker) node.status = node_online ? 'online' : 'offline' node.uptime = get_node_uptime node.id = get_local_node_id if node_online and crm_dom node_el = crm_dom.elements[""//node[@id='#{node.id}']""] if node_el and node_el.attributes['standby'] == 'true' node.status = 'standby' else node.status = 'online' end node.quorum = !!crm_dom.elements['//current_dc[@with_quorum=""true""]'] else node.status = 'offline' end return node end"
1570,"it ""has an empty list of servers"" do cluster.servers.should be_empty end",True,Ruby,"""has an empty list of servers""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def getFenceAgentMetadata(auth_user, fenceagentname) options_required = {} options_optional = {} options_advanced = { ""priority"" => """", ""pcmk_host_argument"" => """", ""pcmk_host_map"" => """", ""pcmk_host_list"" => """", ""pcmk_host_check"" => """" } for a in [""reboot"", ""list"", ""status"", ""monitor"", ""off""] options_advanced[""pcmk_"" + a + ""_action""] = """" options_advanced[""pcmk_"" + a + ""_timeout""] = """" options_advanced[""pcmk_"" + a + ""_retries""] = """" end # There are bugs in stonith_admin & the new fence_agents interaction # eventually we'll want to switch back to this, but for now we directly # call the agent to get metadata #metadata = `stonith_admin --metadata -a #{fenceagentname}` if not fenceagentname.start_with?('fence_') or fenceagentname.include?('/') $logger.error ""Invalid fence agent '#{fenceagentname}'"" return [options_required, options_optional, options_advanced] end stdout, stderr, retval = run_cmd( auth_user, ""/usr/sbin/#{fenceagentname}"", '-o', 'metadata' ) metadata = stdout.join begin doc = REXML::Document.new(metadata) rescue REXML::ParseException => e $logger.error( ""Unable to parse metadata of fence agent '#{resourcepath}': #{e}"" ) return [options_required, options_optional, options_advanced] end short_desc = """" long_desc = """" if doc.root short_desc = doc.root.attributes[""shortdesc""] end if short_desc == """" doc.elements.each('resource-agent/shortdesc') {|sd| short_desc = sd.text ? sd.text.strip : sd.text } end doc.elements.each('resource-agent/longdesc') {|ld| long_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/parameters/parameter') { |param| temp_array = [] if param.elements[""shortdesc""] temp_array << param.elements[""shortdesc""].text else temp_array << """" end if param.elements[""longdesc""] temp_array << param.elements[""longdesc""].text else temp_array << """" end if param.attributes[""required""] == ""1"" and param.attributes[""name""] != ""action"" options_required[param.attributes[""name""]] = temp_array else options_optional[param.attributes[""name""]] = temp_array end } [options_required, options_optional, options_advanced, [short_desc, long_desc]] end"
1571,"it ""has an empty list of servers"" do cluster.servers.should be_empty end",True,Ruby,"""has an empty list of servers""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def getFenceAgents(auth_user, fence_agent = nil) fence_agent_list = {} agents = Dir.glob('/usr/sbin/fence_' + '*') agents.each { |a| fa = FenceAgent.new fa.name = a.sub(/.*\//,"""") next if fa.name == ""fence_ack_manual"" if fence_agent and a.sub(/.*\//,"""") == fence_agent.sub(/.*:/,"""") required_options, optional_options, advanced_options, info = getFenceAgentMetadata(auth_user, fa.name) fa.required_options = required_options fa.optional_options = optional_options fa.advanced_options = advanced_options fa.info = info end fence_agent_list[fa.name] = fa } fence_agent_list end"
1572,"it ""stores the list of seeds"" do cluster.seeds.should eq [""127.0.0.1:27017"", ""127.0.0.1:27018""] end",True,Ruby,"""stores the list of seeds""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def run_cmd(auth_user, *args) options = {} return run_cmd_options(auth_user, options, *args) end"
1573,"it ""stores the list of seeds"" do cluster.seeds.should eq [""127.0.0.1:27017"", ""127.0.0.1:27018""] end",True,Ruby,"""stores the list of seeds""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def allowed_for_superuser(auth_user) $logger.debug( ""permission check superuser username=#{auth_user[:username]} groups=#{auth_user[:usergroups]}"" ) if SUPERUSER != auth_user[:username] $logger.debug('permission denied') return false end $logger.debug('permission granted for superuser') return true end"
1574,"it ""stores whether the connection is direct"" do cluster.direct.should be_true end",True,Ruby,"""stores whether the connection is direct""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_corosync_nodes() stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), PCS, ""status"", ""nodes"", ""corosync"" ) if retval != 0 return [] end stdout.each {|x| x.strip!} corosync_online = stdout[1].sub(/^.*Online:/,"""").strip corosync_offline = stdout[2].sub(/^.*Offline:/,"""").strip corosync_nodes = (corosync_online.split(/ /)) + (corosync_offline.split(/ /)) return corosync_nodes end"
1575,"it ""stores whether the connection is direct"" do cluster.direct.should be_true end",True,Ruby,"""stores whether the connection is direct""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_acl_role(auth_user, name, description) cmd = [PCS, ""acl"", ""role"", ""create"", name.to_s] if description.to_s != """" cmd << ""description=#{description.to_s}"" end stdout, stderror, retval = run_cmd(auth_user, *cmd) if retval != 0 return stderror.join(""\n"").strip end return """" end"
1576,"it ""returns a random slave connection"" do secondaries = [server] cluster.stub(secondaries: secondaries) secondaries.should_receive(:sample).and_return(server) cluster.socket_for(:read).should eq socket end",True,Ruby,"""returns a random slave connection""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_fence_level(auth_user, level, devices, node, remove = false) if not remove stdout, stderr, retval = run_cmd( auth_user, PCS, ""stonith"", ""level"", ""add"", level, node, devices ) return retval,stdout, stderr else stdout, stderr, retval = run_cmd( auth_user, PCS, ""stonith"", ""level"", ""remove"", level, node, devices ) return retval,stdout, stderr end end"
1577,"it ""returns a random slave connection"" do secondaries = [server] cluster.stub(secondaries: secondaries) secondaries.should_receive(:sample).and_return(server) cluster.socket_for(:read).should eq socket end",True,Ruby,"""returns a random slave connection""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_node(auth_user, new_nodename, all=false) if all # we check for a quorum loss warning in remote_remove_nodes out, stderror, retval = run_cmd( auth_user, PCS, ""cluster"", ""node"", ""remove"", new_nodename, ""--force"" ) else out, stderror, retval = run_cmd( auth_user, PCS, ""cluster"", ""localnode"", ""remove"", new_nodename ) end $logger.info(""Removing #{new_nodename} from pcs_settings.conf"") corosync_nodes = get_corosync_nodes() pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.update_cluster($cluster_name, corosync_nodes) sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, corosync_nodes, $cluster_name, true ) return retval, out + stderror end"
1578,"it ""removes the socket"" do cluster.should_receive(:remove).with(dead_server) cluster.socket_for :write end",True,Ruby,"""removes the socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_node_attributes(auth_user, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(auth_user) return {} unless cib_dom end node_attrs = {} cib_dom.elements.each( '/cib/configuration/nodes/node/instance_attributes/nvpair' ) { |e| node = e.parent.parent.attributes['uname'] node_attrs[node] ||= [] node_attrs[node] << { :id => e.attributes['id'], :key => e.attributes['name'], :value => e.attributes['value'] } } node_attrs.each { |_, val| val.sort_by! { |obj| obj[:key] }} return node_attrs end"
1579,"it ""removes the socket"" do cluster.should_receive(:remove).with(dead_server) cluster.socket_for :write end",True,Ruby,"""removes the socket""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def send_request_with_token(auth_user, node, request, post=false, data={}, remote=true, raw_data=nil, timeout=30, additional_tokens={}) token = additional_tokens[node] || get_node_token(node) $logger.info ""SRWT Node: #{node} Request: #{request}"" if not token $logger.error ""Unable to connect to node #{node}, no token available"" return 400,'{""notoken"":true}' end cookies_data = { 'token' => token, } return send_request( auth_user, node, request, post, data, remote, raw_data, timeout, cookies_data ) end"
1580,"it ""syncs the cluster"" do cluster.should_receive(:sync) do cluster.servers << server end cluster.socket_for :write end",True,Ruby,"""syncs the cluster""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_pacemaker_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), PACEMAKERD, ""-$"" ) rescue stdout = [] end if retval == 0 match = /(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end"
1581,"it ""syncs the cluster"" do cluster.should_receive(:sync) do cluster.servers << server end cluster.socket_for :write end",True,Ruby,"""syncs the cluster""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_cman_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), CMAN_TOOL, ""-V"" ) rescue stdout = [] end if retval == 0 match = /(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end"
1582,"it ""returns the master connection"" do cluster.socket_for(:read).should eq socket end",True,Ruby,"""returns the master connection""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def send_cluster_request_with_token(auth_user, cluster_name, request, post=false, data={}, remote=true, raw_data=nil) $logger.info(""SCRWT: "" + request) nodes = get_cluster_nodes(cluster_name) return send_nodes_request_with_token( auth_user, nodes, request, post, data, remote, raw_data ) end"
1583,"it ""returns the master connection"" do cluster.socket_for(:read).should eq socket end",True,Ruby,"""returns the master connection""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def send_local_certs_to_nodes(auth_user, nodes) begin data = { 'ssl_cert' => File.read(CRT_FILE), 'ssl_key' => File.read(KEY_FILE), 'cookie_secret' => File.read(COOKIE_FILE), } rescue => e return { 'status' => 'error', 'text' => ""Unable to read certificates: #{e}"", 'node_status' => {}, } end crt_errors = verify_cert_key_pair(data['ssl_cert'], data['ssl_key']) if crt_errors and not crt_errors.empty? return { 'status' => 'error', 'text' => ""Invalid certificate and/or key: #{crt_errors.join}"", 'node_status' => {}, } end secret_errors = verify_cookie_secret(data['cookie_secret']) if secret_errors and not secret_errors.empty? return { 'status' => 'error', 'text' => ""Invalid cookie secret: #{secret_errors.join}"", 'node_status' => {}, } end node_response = {} threads = [] nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( auth_user, node, '/set_certs', true, data ) node_response[node] = [code, response] } } threads.each { |t| t.join } node_error = [] node_status = {} node_response.each { |node, response| if response[0] == 200 node_status[node] = { 'status' => 'ok', 'text' => 'Success', } else text = response[1] if response[0] == 401 text = ""Unable to authenticate, try running 'pcs cluster auth'"" elsif response[0] == 400 begin parsed_response = JSON.parse(response[1], {:symbolize_names => true}) if parsed_response[:noresponse] text = ""Unable to connect"" elsif parsed_response[:notoken] or parsed_response[:notauthorized] text = ""Unable to authenticate, try running 'pcs cluster auth'"" end rescue JSON::ParserError end end node_status[node] = { 'status' => 'error', 'text' => text } node_error << node end } return { 'status' => node_error.empty?() ? 'ok' : 'error', 'text' => node_error.empty?() ? 'Success' : \ ""Unable to save pcsd certificates to nodes: #{node_error.join(', ')}"", 'node_status' => node_status, } end"
1586,"it ""has an empty list of primaries"" do cluster.primaries.should be_empty end",True,Ruby,"""has an empty list of primaries""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_cib_dom(auth_user) begin stdout, _, retval = run_cmd(auth_user, 'cibadmin', '-Q', '-l') if retval == 0 return REXML::Document.new(stdout.join(""\n"")) end rescue $logger.error 'Failed to parse cib.' end return nil end"
1587,"it ""has an empty list of primaries"" do cluster.primaries.should be_empty end",True,Ruby,"""has an empty list of primaries""",cluster_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def run_cmd_options(auth_user, options, *args) $logger.info(""Running: "" + args.join("" "")) start = Time.now out = """" errout = """" proc_block = proc { |pid, stdin, stdout, stderr| if options and options.key?('stdin') stdin.puts(options['stdin']) stdin.close() end out = stdout.readlines() errout = stderr.readlines() duration = Time.now - start $logger.debug(out) $logger.debug(errout) $logger.debug(""Duration: "" + duration.to_s + ""s"") } cib_user = auth_user[:username] # when running 'id -Gn' to get the groups they are not defined yet cib_groups = (auth_user[:usergroups] || []).join(' ') $logger.info(""CIB USER: #{cib_user}, groups: #{cib_groups}"") # Open4.popen4 reimplementation which sets ENV in a child process prior # to running an external process by exec status = Open4::do_popen(proc_block, :init) { |ps_read, ps_write| ps_read.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC) ps_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC) ENV['CIB_user'] = cib_user ENV['CIB_user_groups'] = cib_groups exec(*args) } retval = status.exitstatus $logger.info(""Return Value: "" + retval.to_s) return out, errout, retval end"
1590,"it ""inserts the documents"" do session.should_receive(:execute).with do |insert| insert.documents.should eq [{a: 1}, {b: 2}] end collection.insert([{a: 1}, {b: 2}]) end",True,Ruby,"""inserts the documents""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_colocation_constraint( auth_user, resourceA, resourceB, score, force=false, autocorrect=true ) if score == """" or score == nil score = ""INFINITY"" end command = [ PCS, ""constraint"", ""colocation"", ""add"", resourceA, resourceB, score ] command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(auth_user, *command) return retval, stderr.join(' ') end"
1591,"it ""inserts the documents"" do session.should_receive(:execute).with do |insert| insert.documents.should eq [{a: 1}, {b: 2}] end collection.insert([{a: 1}, {b: 2}]) end",True,Ruby,"""inserts the documents""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def disable_cluster(auth_user) stdout, stderror, retval = run_cmd(auth_user, PCS, ""cluster"", ""disable"") return false if retval != 0 return true end"
1594,"it ""stores the collection name"" do collection.name.should eq :users end",True,Ruby,"""stores the collection name""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_node_attr(auth_user, node, key, value) stdout, stderr, retval = run_cmd( auth_user, PCS, ""property"", ""set"", ""--node"", node, key.to_s + '=' + value.to_s ) return retval end"
1595,"it ""stores the collection name"" do collection.name.should eq :users end",True,Ruby,"""stores the collection name""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_acl_permission(auth_user, acl_perm_id) stdout, stderror, retval = run_cmd( auth_user, PCS, ""acl"", ""permission"", ""delete"", acl_perm_id.to_s ) if retval != 0 if stderror.empty? return ""Error removing permission"" else return stderror.join(""\n"").strip end end return """" end"
1596,"it ""inserts the document"" do session.should_receive(:execute).with do |insert| insert.documents.should eq [{a: 1}] end collection.insert(a: 1) end",True,Ruby,"""inserts the document""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove_constraint_rule(auth_user, rule_id) stdout, stderror, retval = run_cmd( auth_user, PCS, ""constraint"", ""rule"", ""remove"", rule_id ) $logger.info stdout return retval end"
1597,"it ""inserts the document"" do session.should_receive(:execute).with do |insert| insert.documents.should eq [{a: 1}] end collection.insert(a: 1) end",True,Ruby,"""inserts the document""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_stonith_agents_avail(auth_user, params) code, result = send_cluster_request_with_token( auth_user, params[:cluster], 'get_avail_fence_agents' ) return {} if 200 != code begin sa = JSON.parse(result) if (sa[""noresponse""] == true) or (sa[""notauthorized""] == ""true"") or (sa[""notoken""] == true) or (sa[""pacemaker_not_running""] == true) return {} else return sa end rescue JSON::ParserError return {} end end"
1598,"it ""drops the collection"" do database.should_receive(:command).with(drop: :users) collection.drop end",True,Ruby,"""drops the collection""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def run_auth_requests(auth_user, nodes_to_send, nodes_to_auth, username, password, force=false, local=true) data = {} nodes_to_auth.each_with_index { |node, index| data[""node-#{index}""] = node } data['username'] = username data['password'] = password data['bidirectional'] = 1 if not local data['force'] = 1 if force auth_responses = {} threads = [] nodes_to_send.each { |node| threads << Thread.new { code, response = send_request(auth_user, node, 'auth', true, data) if 200 == code token = response.strip if '' == token auth_responses[node] = {'status' => 'bad_password'} else auth_responses[node] = {'status' => 'ok', 'token' => token} end else auth_responses[node] = {'status' => 'noresponse'} end } } threads.each { |t| t.join } return auth_responses end"
1599,"it ""drops the collection"" do database.should_receive(:command).with(drop: :users) collection.drop end",True,Ruby,"""drops the collection""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_acls(auth_user, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(auth_user) return {} unless cib_dom end acls = { 'role' => {}, 'group' => {}, 'user' => {}, 'target' => {} } cib_dom.elements.each('/cib/configuration/acls/*') { |e| type = e.name[4..-1] if e.name == 'acl_role' role_id = e.attributes['id'] desc = e.attributes['description'] acls[type][role_id] = {} acls[type][role_id]['description'] = desc ? desc : '' acls[type][role_id]['permissions'] = [] e.elements.each('acl_permission') { |p| p_id = p.attributes['id'] p_kind = p.attributes['kind'] val = '' if p.attributes['xpath'] val = ""xpath #{p.attributes['xpath']}"" elsif p.attributes['reference'] val = ""id #{p.attributes['reference']}"" else next end acls[type][role_id]['permissions'] << ""#{p_kind} #{val} (#{p_id})"" } elsif ['acl_target', 'acl_group'].include?(e.name) id = e.attributes['id'] acls[type][id] = [] e.elements.each('role') { |r| acls[type][id] << r.attributes['id'] } end } acls['user'] = acls['target'] return acls end"
1600,"it ""defaults to an empty selector"" do Moped::Query.should_receive(:new). with(collection, {}).and_return(query) collection.find.should eq query end",True,Ruby,"""defaults to an empty selector""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_cluster_name() if ISRHEL6 stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC_CMAPCTL, ""cluster"" ) if retval == 0 stdout.each { |line| match = /^cluster\.name=(.*)$/.match(line) return match[1] if match } end begin cluster_conf = Cfgsync::ClusterConf.from_file().text() rescue return '' end conf_dom = REXML::Document.new(cluster_conf) if conf_dom.root and conf_dom.root.name == 'cluster' return conf_dom.root.attributes['name'] end return '' end stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC_CMAPCTL, ""totem.cluster_name"" ) if retval != 0 and not ISRHEL6 # Cluster probably isn't running, try to get cluster name from # corosync.conf begin corosync_conf = CorosyncConf::parse_string( Cfgsync::CorosyncConf.from_file().text() ) # mimic corosync behavior - the last cluster_name found is used cluster_name = nil corosync_conf.sections('totem').each { |totem| totem.attributes('cluster_name').each { |attrib| cluster_name = attrib[1] } } return cluster_name if cluster_name rescue return '' end return """" else return stdout.join().gsub(/.*= /,"""").strip end end"
1601,"it ""defaults to an empty selector"" do Moped::Query.should_receive(:new). with(collection, {}).and_return(query) collection.find.should eq query end",True,Ruby,"""defaults to an empty selector""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_acl_usergroup(auth_user, role_id, usergroup_id) stdout, stderror, retval = run_cmd( auth_user, PCS, ""acl"", ""role"", ""unassign"", role_id.to_s, usergroup_id.to_s, ""--autodelete"" ) if retval != 0 if stderror.empty? return ""Error removing user / group"" else return stderror.join(""\n"").strip end end return """" end"
1602,"it ""stores the database"" do collection.database.should eq database end",True,Ruby,"""stores the database""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_location_constraint( auth_user, resource, node, score, force=false, autocorrect=true ) if node == """" return ""Bad node"" end if score == """" nodescore = node else nodescore = node + ""="" + score end cmd = [PCS, ""constraint"", ""location"", resource, ""prefers"", nodescore] cmd << '--force' if force cmd << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(auth_user, *cmd) return retval, stderr.join(' ') end"
1603,"it ""stores the database"" do collection.database.should eq database end",True,Ruby,"""stores the database""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def check_gui_status_of_nodes(auth_user, nodes, check_mutuality=false, timeout=10) options = {} options[:check_auth_only] = '' if not check_mutuality threads = [] not_authorized_nodes = [] online_nodes = [] offline_nodes = [] nodes = nodes.uniq.sort nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( auth_user, node, 'check_auth', false, options, true, nil, timeout ) if code == 200 if check_mutuality begin parsed_response = JSON.parse(response) if parsed_response['node_list'] and parsed_response['node_list'].uniq.sort == nodes online_nodes << node else not_authorized_nodes << node end rescue not_authorized_nodes << node end else online_nodes << node end else begin parsed_response = JSON.parse(response) if parsed_response['notauthorized'] or parsed_response['notoken'] not_authorized_nodes << node else offline_nodes << node end rescue JSON::ParserError end end } } threads.each { |t| t.join } return online_nodes, offline_nodes, not_authorized_nodes end"
1604,"it ""returns a new indexes instance"" do collection.indexes.should be_an_instance_of Moped::Indexes end",True,Ruby,"""returns a new indexes instance""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_fence_levels(auth_user, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(auth_user) return {} unless cib_dom end fence_levels = {} cib_dom.elements.each( '/cib/configuration/fencing-topology/fencing-level' ) { |e| target = e.attributes['target'] fence_levels[target] ||= [] fence_levels[target] << { 'level' => e.attributes['index'], 'devices' => e.attributes['devices'] } } fence_levels.each { |_, val| val.sort_by! { |obj| obj['level'].to_i }} return fence_levels end"
1605,"it ""returns a new indexes instance"" do collection.indexes.should be_an_instance_of Moped::Indexes end",True,Ruby,"""returns a new indexes instance""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def getAllSettings(auth_user, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(auth_user) end ret = {} if cib_dom cib_dom.elements.each('/cib/configuration/crm_config//nvpair') { |e| ret[e.attributes['name']] = e.attributes['value'] } end return ret end"
1610,"it ""returns a new Query"" do Moped::Query.should_receive(:new). with(collection, selector).and_return(query) collection.find(selector).should eq query end",True,Ruby,"""returns a new Query""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_order_constraint( auth_user, resourceA, resourceB, actionA, actionB, score, symmetrical=true, force=false, autocorrect=true ) sym = symmetrical ? ""symmetrical"" : ""nonsymmetrical"" if score != """" score = ""score="" + score end command = [ PCS, ""constraint"", ""order"", actionA, resourceA, ""then"", actionB, resourceB, score, sym ] command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(auth_user, *command) return retval, stderr.join(' ') end"
1611,"it ""returns a new Query"" do Moped::Query.should_receive(:new). with(collection, selector).and_return(query) collection.find(selector).should eq query end",True,Ruby,"""returns a new Query""",collection_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_resource_agents_avail(auth_user, params) code, result = send_cluster_request_with_token( auth_user, params[:cluster], 'get_avail_resource_agents' ) return {} if 200 != code begin ra = JSON.parse(result) if (ra[""noresponse""] == true) or (ra[""notauthorized""] == ""true"") or (ra[""notoken""] == true) or (ra[""pacemaker_not_running""] == true) return {} else return ra end rescue JSON::ParserError return {} end end"
1612,"it ""does not drop other indexes"" do indexes[age: -1].should_not be_nil end",True,Ruby,"""does not drop other indexes""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_location_constraint_rule( auth_user, resource, rule, score, force=false, autocorrect=true ) cmd = [PCS, ""constraint"", ""location"", resource, ""rule""] if score != '' if is_score(score.upcase) cmd << ""score=#{score.upcase}"" else cmd << ""score-attribute=#{score}"" end end cmd.concat(rule.shellsplit()) cmd << '--force' if force cmd << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(auth_user, *cmd) return retval, stderr.join(' ') end"
1613,"it ""does not drop other indexes"" do indexes[age: -1].should_not be_nil end",True,Ruby,"""does not drop other indexes""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_crm_mon_dom(auth_user) begin stdout, _, retval = run_cmd( auth_user, CRM_MON, '--one-shot', '-r', '--as-xml' ) if retval == 0 return REXML::Document.new(stdout.join(""\n"")) end rescue $logger.error 'Failed to parse crm_mon.' end return nil end"
1614,"it ""creates an index"" do indexes.create(key, background: true) indexes[key][""background""].should eq true end",True,Ruby,"""creates an index""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_acl_permission(auth_user, acl_role_id, perm_type, xpath_id, query_id) stdout, stderror, retval = run_cmd( auth_user, PCS, ""acl"", ""permission"", ""add"", acl_role_id.to_s, perm_type.to_s, xpath_id.to_s, query_id.to_s ) if retval != 0 if stderror.empty? return ""Error adding permission"" else return stderror.join(""\n"").strip end end return """" end"
1615,"it ""creates an index"" do indexes.create(key, background: true) indexes[key][""background""].should eq true end",True,Ruby,"""creates an index""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_local_node_id() if ISRHEL6 out, errout, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC_CMAPCTL, ""cluster.cman"" ) if retval != 0 return """" end match = /cluster\.nodename=(.*)/.match(out.join(""\n"")) if not match return """" end local_node_name = match[1] out, errout, retval = run_cmd( PCSAuth.getSuperuserAuth(), CMAN_TOOL, ""nodes"", ""-F"", ""id"", ""-n"", local_node_name ) if retval != 0 return """" end return out[0].strip() end out, errout, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC_CMAPCTL, ""-g"", ""runtime.votequorum.this_node_id"" ) if retval != 0 return """" else return out[0].split(/ = /)[1].strip() end end"
1616,"it ""returns the index with the provided key"" do indexes[name: 1][""name""].should eq ""name_1"" end",True,Ruby,"""returns the index with the provided key""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_meta_attr(auth_user, resource, key, value) stdout, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""meta"", resource, key.to_s + ""="" + value.to_s ) return retval end"
1617,"it ""returns the index with the provided key"" do indexes[name: 1][""name""].should eq ""name_1"" end",True,Ruby,"""returns the index with the provided key""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_node_status(auth_user, cib_dom) node_status = { :cluster_name => $cluster_name, :groups => [], :constraints => { # :rsc_location => [], # :rcs_colocation => [], # :rcs_order => [] }, :cluster_settings => {}, :need_ring1_address => need_ring1_address?, :is_cman_with_udpu_transport => is_cman_with_udpu_transport?, :acls => get_acls(auth_user, cib_dom), :username => auth_user[:username], :fence_levels => get_fence_levels(auth_user, cib_dom), :node_attr => node_attrs_to_v2(get_node_attributes(auth_user, cib_dom)), :nodes_utilization => get_nodes_utilization(cib_dom), :known_nodes => [] } nodes = get_nodes_status() known_nodes = [] nodes.each { |_, node_list| known_nodes.concat node_list } node_status[:known_nodes] = known_nodes.uniq nodes.each do |k,v| node_status[k.to_sym] = v end if cib_dom node_status[:groups] = get_resource_groups(cib_dom) node_status[:constraints] = getAllConstraints(cib_dom.elements['/cib/configuration/constraints']) end node_status[:cluster_settings] = getAllSettings(auth_user, cib_dom) return node_status end"
1620,"it ""returns false"" do indexes.drop(other: 1).should be_false end",True,Ruby,"""returns false""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_acl_usergroup(auth_user, acl_role_id, user_group, name) if (user_group == ""user"") or (user_group == ""group"") stdout, stderr, retval = run_cmd( auth_user, PCS, ""acl"", user_group, ""create"", name.to_s, acl_role_id.to_s ) if retval == 0 return """" end if not /^error: (user|group) #{name.to_s} already exists$/i.match(stderr.join(""\n"").strip) return stderr.join(""\n"").strip end end stdout, stderror, retval = run_cmd( auth_user, PCS, ""acl"", ""role"", ""assign"", acl_role_id.to_s, name.to_s ) if retval != 0 if stderror.empty? return ""Error adding #{user_group}"" else return stderror.join(""\n"").strip end end return """" end"
1621,"it ""returns false"" do indexes.drop(other: 1).should be_false end",True,Ruby,"""returns false""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def allowed_for_local_cluster(auth_user, action) pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) return pcs_config.permissions_local.allows?( auth_user[:username], auth_user[:usergroups], action ) end"
1623,"it ""creates an index with the provided name"" do indexes.create(key, name: ""custom_index_name"") indexes[key][""name""].should eq ""custom_index_name"" end",True,Ruby,"""creates an index with the provided name""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def enable_cluster(auth_user) stdout, stderror, retval = run_cmd(auth_user, PCS, ""cluster"", ""enable"") return false if retval != 0 return true end"
1624,"it ""drops all indexes for the collection"" do indexes[name: 1].should be_nil indexes[age: -1].should be_nil end",True,Ruby,"""drops all indexes for the collection""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def need_ring1_address?() out, errout, retval = run_cmd(PCSAuth.getSuperuserAuth(), COROSYNC_CMAPCTL) if retval != 0 return false else udpu_transport = false rrp = false out.each { |line| # support both corosync-objctl and corosync-cmapctl format if /^\s*totem\.transport(\s+.*)?=\s*udpu$/.match(line) udpu_transport = true elsif /^\s*totem\.rrp_mode(\s+.*)?=\s*(passive|active)$/.match(line) rrp = true end } # on rhel6 ring1 address is required regardless of transport # it has to be added to cluster.conf in order to set up ring1 # in corosync by cman return ((ISRHEL6 and rrp) or (rrp and udpu_transport)) end end"
1625,"it ""drops all indexes for the collection"" do indexes[name: 1].should be_nil indexes[age: -1].should be_nil end",True,Ruby,"""drops all indexes for the collection""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_constraint(auth_user, constraint_id) stdout, stderror, retval = run_cmd( auth_user, PCS, ""constraint"", ""remove"", constraint_id ) $logger.info stdout return retval end"
1630,"it ""drops the index that matches the key"" do indexes[name: 1].should be_nil end",True,Ruby,"""drops the index that matches the key""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def send_local_configs_to_nodes( auth_user, nodes, force=false, clear_local_permissions=false ) configs = Cfgsync::get_configs_local(true) if clear_local_permissions pcs_config = PCSConfig.new(configs[Cfgsync::PcsdSettings.name].text()) pcs_config.permissions_local = Permissions::PermissionsSet.new([]) configs[Cfgsync::PcsdSettings.name].text = pcs_config.text() end publisher = Cfgsync::ConfigPublisher.new( auth_user, configs.values(), nodes, $cluster_name ) return publisher.send(force) end"
1631,"it ""drops the index that matches the key"" do indexes[name: 1].should be_nil end",True,Ruby,"""drops the index that matches the key""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def verify_cert_key_pair(cert, key) errors = [] cert_modulus = nil key_modulus = nil stdout, stderr, retval = run_cmd_options( PCSAuth.getSuperuserAuth(), { 'stdin' => cert, }, '/usr/bin/openssl', 'x509', '-modulus', '-noout' ) if retval != 0 errors << ""Invalid certificate: #{stderr.join}"" else cert_modulus = stdout.join.strip end stdout, stderr, retval = run_cmd_options( PCSAuth.getSuperuserAuth(), { 'stdin' => key, }, '/usr/bin/openssl', 'rsa', '-modulus', '-noout' ) if retval != 0 errors << ""Invalid key: #{stderr.join}"" else key_modulus = stdout.join.strip end if errors.empty? and cert_modulus and key_modulus if cert_modulus != key_modulus errors << 'Certificate does not match the key' end end return errors end"
1632,"it ""creates an index with a generated name"" do indexes.create(key) indexes[key][""name""].should eq ""location.latlong_2d_name_1_age_-1"" end",True,Ruby,"""creates an index with a generated name""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def pcs_auth(auth_user, nodes, username, password, force=false, local=true) # if no sync is needed, do not report a sync error sync_successful = true sync_failed_nodes = [] sync_responses = {} # check for already authorized nodes if not force online, offline, not_authenticated = check_gui_status_of_nodes( auth_user, nodes, true ) if not_authenticated.length < 1 result = {} online.each { |node| result[node] = {'status' => 'already_authorized'} } offline.each { |node| result[node] = {'status' => 'noresponse'} } return result, sync_successful, sync_failed_nodes, sync_responses end end # authorize the nodes locally (i.e. not bidirectionally) auth_responses = run_auth_requests( auth_user, nodes, nodes, username, password, force, true ) # get the tokens and sync them within the local cluster new_tokens = {} auth_responses.each { |node, response| new_tokens[node] = response['token'] if 'ok' == response['status'] } if not new_tokens.empty? cluster_nodes = get_corosync_nodes() tokens_cfg = Cfgsync::PcsdTokens.from_file('') # only tokens used in pcsd-to-pcsd communication can and need to be synced # those are accessible only when running under root account if Process.uid != 0 # other tokens just need to be stored localy for the user sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, [], nil ) return auth_responses, sync_successful, sync_failed_nodes, sync_responses end sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, cluster_nodes, $cluster_name ) sync_failed_nodes = [] sync_not_supported_nodes = [] sync_responses.each { |node, response| if 'not_supported' == response['status'] sync_not_supported_nodes << node elsif response['status'] != 'ok' sync_failed_nodes << node else node_result = response['result'][Cfgsync::PcsdTokens.name] if 'not_supported' == node_result sync_not_supported_nodes << node elsif not ['accepted', 'rejected'].include?(node_result) sync_failed_nodes << node end end } if not local # authorize nodes outside of the local cluster and nodes not supporting # the tokens file synchronization in the other direction nodes_to_auth = [] nodes.each { |node| nodes_to_auth << node if sync_not_supported_nodes.include?(node) nodes_to_auth << node if not cluster_nodes.include?(node) } auth_responses2 = run_auth_requests( auth_user, nodes_to_auth, nodes, username, password, force, false ) auth_responses.update(auth_responses2) end end return auth_responses, sync_successful, sync_failed_nodes, sync_responses end"
1633,"it ""creates an index with a generated name"" do indexes.create(key) indexes[key][""name""].should eq ""location.latlong_2d_name_1_age_-1"" end",True,Ruby,"""creates an index with a generated name""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_nodes_status() corosync_online = [] corosync_offline = [] pacemaker_online = [] pacemaker_offline = [] pacemaker_standby = [] in_pacemaker = false stdout, stderr, retval = run_cmd( PCSAuth.getSuperuserAuth(), PCS, ""status"", ""nodes"", ""both"" ) stdout.each {|l| l = l.chomp if l.start_with?(""Pacemaker Nodes:"") in_pacemaker = true end if l.start_with?(""Pacemaker Remote Nodes:"") break end if l.end_with?("":"") next end title,nodes = l.split(/: /,2) if nodes == nil next end if title == "" Online"" in_pacemaker ? pacemaker_online.concat(nodes.split(/ /)) : corosync_online.concat(nodes.split(/ /)) elsif title == "" Standby"" if in_pacemaker pacemaker_standby.concat(nodes.split(/ /)) end elsif title == "" Maintenance"" if in_pacemaker pacemaker_online.concat(nodes.split(/ /)) end else in_pacemaker ? pacemaker_offline.concat(nodes.split(/ /)) : corosync_offline.concat(nodes.split(/ /)) end } return { 'corosync_online' => corosync_online, 'corosync_offline' => corosync_offline, 'pacemaker_online' => pacemaker_online, 'pacemaker_offline' => pacemaker_offline, 'pacemaker_standby' => pacemaker_standby, } end"
1634,"it ""yields all indexes on the collection"" do indexes.to_a.should eq \ session[:""system.indexes""].find(ns: ""moped_test.users"").to_a end",True,Ruby,"""yields all indexes on the collection""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_corosync_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC, ""-v"" ) rescue stdout = [] end if retval == 0 match = /version\D+(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end"
1635,"it ""yields all indexes on the collection"" do indexes.to_a.should eq \ session[:""system.indexes""].find(ns: ""moped_test.users"").to_a end",True,Ruby,"""yields all indexes on the collection""",indexes_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def send_nodes_request_with_token(auth_user, nodes, request, post=false, data={}, remote=true, raw_data=nil) out = """" code = 0 $logger.info(""SNRWT: "" + request) # If we're removing nodes, we don't send this to one of the nodes we're # removing, unless we're removing all nodes if request == ""/remove_nodes"" new_nodes = nodes.dup data.each {|k,v| if new_nodes.include? v new_nodes.delete v end } if new_nodes.length > 0 nodes = new_nodes end end for node in nodes $logger.info ""SNRWT Node: #{node} Request: #{request}"" code, out = send_request_with_token( auth_user, node, request, post, data, remote, raw_data ) # try next node if: # - current node does not support the request (old version of pcsd?) (404) # - an exception or other error occurred (5xx) # - we don't have a token for the node (401, notoken) # - we didn't get a response form the node (e.g. an exception occurred) # - pacemaker is not running on the node # do not try next node if # - node returned 400 - it means the request cannot be processed because of # invalid arguments or another known issue, no node would be able to # process the request (e.g. removing a non-existing resource) # - node returned 403 - permission denied, no node should allow to process # the request log = ""SNRWT Node #{node} Request #{request}"" if (404 == code) or (code >= 500 and code <= 599) $logger.info(""#{log}: HTTP code #{code}"") next end if (401 == code) or ('{""notoken"":true}' == out) $logger.info(""#{log}: Bad or missing token"") next end if '{""pacemaker_not_running"":true}' == out $logger.info(""#{log}: Pacemaker not running"") next end if '{""noresponse"":true}' == out $logger.info(""#{log}: No response"") next end $logger.info(""#{log}: HTTP code #{code}"") break end return code, out end"
1650,"it ""removes the first matching document"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |delete| delete.flags.should eq [:remove_first] delete.selector.should eq query.operation.selector end query.remove end",True,Ruby,"""removes the first matching document""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def pcsd_restart_nodes(auth_user, nodes) node_response = {} threads = [] nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( auth_user, node, '/pcsd_restart', true ) node_response[node] = [code, response] } } threads.each { |t| t.join } node_error = [] node_status = {} node_response.each { |node, response| if response[0] == 200 node_status[node] = { 'status' => 'ok', 'text' => 'Success', } else text = response[1] if response[0] == 401 text = ""Unable to authenticate, try running 'pcs cluster auth'"" elsif response[0] == 400 begin parsed_response = JSON.parse(response[1], {:symbolize_names => true}) if parsed_response[:noresponse] text = ""Unable to connect"" elsif parsed_response[:notoken] or parsed_response[:notauthorized] text = ""Unable to authenticate, try running 'pcs cluster auth'"" end rescue JSON::ParserError end end node_status[node] = { 'status' => 'error', 'text' => text } node_error << node end } return { 'status' => node_error.empty?() ? 'ok' : 'error', 'text' => node_error.empty?() ? 'Success' : \ ""Unable to restart pcsd on nodes: #{node_error.join(', ')}"", 'node_status' => node_status, } end"
1651,"it ""removes the first matching document"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |delete| delete.flags.should eq [:remove_first] delete.selector.should eq query.operation.selector end query.remove end",True,Ruby,"""removes the first matching document""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_node(auth_user, new_nodename, all=false, auto_start=true) if all command = [PCS, ""cluster"", ""node"", ""add"", new_nodename] if auto_start command << '--start' command << '--enable' end out, stderror, retval = run_cmd(auth_user, *command) else out, stderror, retval = run_cmd( auth_user, PCS, ""cluster"", ""localnode"", ""add"", new_nodename ) end $logger.info(""Adding #{new_nodename} to pcs_settings.conf"") corosync_nodes = get_corosync_nodes() pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.update_cluster($cluster_name, corosync_nodes) sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, corosync_nodes, $cluster_name, true ) return retval, out.join(""\n"") + stderror.join(""\n"") end"
1652,"it ""executes a simple query"" do session.should_receive(:simple_query).with(query.operation) query.one end",True,Ruby,"""executes a simple query""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_order_set_constraint( auth_user, resource_set_list, force=false, autocorrect=true ) command = [PCS, ""constraint"", ""order""] resource_set_list.each { |resource_set| command << ""set"" command.concat(resource_set) } command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(auth_user, *command) return retval, stderr.join(' ') end"
1653,"it ""executes a simple query"" do session.should_receive(:simple_query).with(query.operation) query.one end",True,Ruby,"""executes a simple query""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_current_node_name() stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserAuth(), CRM_NODE, ""-n"" ) if retval == 0 and stdout.length > 0 return stdout[0].chomp() end return """" end"
1654,"it ""executes a count command"" do database.should_receive(:command).with( count: collection.name, query: selector ).and_return(""n"" => 4) query.count end",True,Ruby,"""executes a count command""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def send_request(auth_user, node, request, post=false, data={}, remote=true, raw_data=nil, timeout=30, cookies_data=nil) cookies_data = {} if not cookies_data begin request = ""/#{request}"" if not request.start_with?(""/"") # fix ipv6 address for URI.parse node6 = node if (node.include?("":"") and ! node.start_with?(""["")) node6 = ""[#{node}]"" end if remote uri = URI.parse(""https://#{node6}:2224/remote"" + request) else uri = URI.parse(""https://#{node6}:2224"" + request) end if post req = Net::HTTP::Post.new(uri.path) raw_data ? req.body = raw_data : req.set_form_data(data) else req = Net::HTTP::Get.new(uri.path) req.set_form_data(data) end cookies_to_send = [] cookies_data_default = {} # Let's be safe about characters in cookie variables and do base64. # We cannot do it for CIB_user however to be backward compatible # so we at least remove disallowed characters. cookies_data_default['CIB_user'] = PCSAuth.cookieUserSafe( auth_user[:username].to_s ) cookies_data_default['CIB_user_groups'] = PCSAuth.cookieUserEncode( (auth_user[:usergroups] || []).join(' ') ) cookies_data_default.update(cookies_data) cookies_data_default.each { |name, value| cookies_to_send << CGI::Cookie.new('name' => name, 'value' => value).to_s } req.add_field('Cookie', cookies_to_send.join(';')) # uri.host returns ""[addr]"" for ipv6 addresses, which is wrong # uri.hostname returns ""addr"" for ipv6 addresses, which is correct, but it # is not available in older ruby versions # There is a bug in Net::HTTP.new in some versions of ruby which prevents # ipv6 addresses being used here at all. myhttp = Net::HTTP.new(node, uri.port) myhttp.use_ssl = true myhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE res = myhttp.start do |http| http.read_timeout = timeout http.request(req) end return res.code.to_i, res.body rescue Exception => e $logger.info ""No response from: #{node} request: #{request}, exception: #{e}"" return 400,'{""noresponse"":true}' end end"
1655,"it ""executes a count command"" do database.should_receive(:command).with( count: collection.name, query: selector ).and_return(""n"" => 4) query.count end",True,Ruby,"""executes a count command""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def protected! gui_request = ( # these are URLs for web pages request.path == '/' or request.path == '/manage' or request.path == '/permissions' or request.path.match('/managec/.+/main') ) if request.path.start_with?('/remote/') or request.path == '/run_pcs' @auth_user = PCSAuth.loginByToken(cookies) unless @auth_user halt [401, '{""notauthorized"":""true""}'] end else #/managec/* /manage/* /permissions if !gui_request and request.env['HTTP_X_REQUESTED_WITH'] != 'XMLHttpRequest' then # Accept non GUI requests only with header # ""X_REQUESTED_WITH: XMLHttpRequest"". (check if they are send via AJAX). # This prevents CSRF attack. halt [401, '{""notauthorized"":""true""}'] elsif not PCSAuth.isLoggedIn(session) if gui_request session[:pre_login_path] = request.path redirect '/login' else halt [401, '{""notauthorized"":""true""}'] end end end end"
1658,"it ""updates the record matching selector with change"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |update| update.flags.should eq [] update.selector.should eq query.operation.selector update.update.should eq change end query.update change end",True,Ruby,"""updates the record matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def update_fence_device(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Updating fence device"" $logger.info params param_line = getParamList(params) $logger.info param_line if not params[:resource_id] out, stderr, retval = run_cmd( auth_user, PCS, ""stonith"", ""create"", params[:name], params[:resource_type], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end return ""{}"" end if param_line.length != 0 out, stderr, retval = run_cmd( auth_user, PCS, ""stonith"", ""update"", params[:resource_id], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end end return ""{}"" end"
1659,"it ""updates the record matching selector with change"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |update| update.flags.should eq [] update.selector.should eq query.operation.selector update.update.should eq change end query.update change end",True,Ruby,"""updates the record matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def resource_unclone(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'unclone', params[:resource_id] ) if retval != 0 return [400, 'Unable to unclone ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end"
1660,"it ""stores the collection"" do query.collection.should eq collection end",True,Ruby,"""stores the collection""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_form(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end cib_dom = get_cib_dom(auth_user) @cur_resource = get_resource_by_id(params[:resource], cib_dom) @groups = get_resource_groups(cib_dom) @version = params[:version] if @cur_resource.instance_of?(ClusterEntity::Primitive) and !@cur_resource.stonith @cur_resource_group = @cur_resource.get_group @cur_resource_clone = @cur_resource.get_clone @cur_resource_ms = @cur_resource.get_master @resource = ResourceAgent.new(@cur_resource.agentname) if @cur_resource.provider == 'heartbeat' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, HEARTBEAT_AGENTS_DIR + @cur_resource.type) elsif @cur_resource.provider == 'pacemaker' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, PACEMAKER_AGENTS_DIR + @cur_resource.type) elsif @cur_resource._class == 'nagios' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, NAGIOS_METADATA_DIR + @cur_resource.type + '.xml') end @existing_resource = true if @resource erb :resourceagentform else ""Can't find resource"" end else ""Resource #{params[:resource]} doesn't exist"" end end"
1661,"it ""stores the collection"" do query.collection.should eq collection end",True,Ruby,"""stores the collection""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def clusters_overview(params, request, auth_user) cluster_map = {} forbidden_clusters = {} threads = [] config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) config.clusters.each { |cluster| threads << Thread.new { cluster_map[cluster.name] = { 'cluster_name' => cluster.name, 'error_list' => [ {'message' => 'Unable to connect to the cluster. Request timeout.'} ], 'warning_list' => [], 'status' => 'unknown', 'node_list' => get_default_overview_node_list(cluster.name), 'resource_list' => [] } overview_cluster = nil online, offline, not_authorized_nodes = check_gui_status_of_nodes( auth_user, get_cluster_nodes(cluster.name), false, 3 ) not_supported = false forbidden = false cluster_nodes_auth = (online + offline).uniq cluster_nodes_all = (cluster_nodes_auth + not_authorized_nodes).uniq nodes_not_in_cluster = [] for node in cluster_nodes_auth code, response = send_request_with_token( auth_user, node, 'cluster_status', true, {}, true, nil, 8 ) if code == 404 not_supported = true next end if 403 == code forbidden = true forbidden_clusters[cluster.name] = true break end begin parsed_response = JSON.parse(response) if parsed_response['noresponse'] or parsed_response['pacemaker_not_running'] next elsif parsed_response['notoken'] or parsed_response['notauthorized'] next elsif parsed_response['cluster_name'] != cluster.name # queried node is not in the cluster (any more) nodes_not_in_cluster << node next else overview_cluster = parsed_response break end rescue JSON::ParserError end end if cluster_nodes_all.sort == nodes_not_in_cluster.sort overview_cluster = { 'cluster_name' => cluster.name, 'error_list' => [], 'warning_list' => [], 'status' => 'unknown', 'node_list' => [], 'resource_list' => [] } end if not overview_cluster overview_cluster = { 'cluster_name' => cluster.name, 'error_list' => [], 'warning_list' => [], 'status' => 'unknown', 'node_list' => get_default_overview_node_list(cluster.name), 'resource_list' => [] } if not_supported overview_cluster['warning_list'] = [ { 'message' => 'Cluster is running an old version of pcs/pcsd which does not provide data for the dashboard.', }, ] else if forbidden overview_cluster['error_list'] = [ { 'message' => 'You do not have permissions to view the cluster.', 'type' => 'forbidden', }, ] overview_cluster['node_list'] = [] else overview_cluster['error_list'] = [ { 'message' => 'Unable to connect to the cluster.', }, ] end end end if not_authorized_nodes.length > 0 overview_cluster['warning_list'] << { 'message' => 'GUI is not authorized against node(s) '\ + not_authorized_nodes.join(', '), 'type' => 'nodes_not_authorized', 'node_list' => not_authorized_nodes, } end overview_cluster['node_list'].each { |node| if node['status_version'] == '1' overview_cluster['warning_list'] << { :message => 'Some nodes are running old version of pcs/pcsd.' } break end } cluster_map[cluster.name] = overview_cluster } } begin Timeout::timeout(18) { threads.each { |t| t.join } } rescue Timeout::Error threads.each { |t| t.exit } end # update clusters in PCSConfig not_current_data = false config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) cluster_map.each { |cluster, values| next if forbidden_clusters[cluster] nodes = [] values['node_list'].each { |node| nodes << node['name'] } if !config.cluster_nodes_equal?(cluster, nodes) $logger.info(""Updating node list for: #{cluster} #{config.get_nodes(cluster)}->#{nodes}"") config.update_cluster(cluster, nodes) not_current_data = true end } if not_current_data sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) end overview = { 'not_current_data' => not_current_data, 'cluster_list' => cluster_map.values.sort { |a, b| a['clustername'] <=> b['clustername'] } } return JSON.generate(overview) end"
1668,"it ""updates to a mongo advanced selector"" do query.explain query.operation.selector.should eq( ""$query"" => selector, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end",True,Ruby,"""updates to a mongo advanced selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def wizard_submit(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end wizard = PCSDWizard.getWizard(params[""wizard""]) if wizard != nil return erb wizard.process_responses(params) else return ""Error finding Wizard - #{params[""wizard""]}"" end end"
1669,"it ""updates to a mongo advanced selector"" do query.explain query.operation.selector.should eq( ""$query"" => selector, ""$explain"" => true, ""$orderby"" => { _id: 1 } ) end",True,Ruby,"""updates to a mongo advanced selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def auth(params, request, auth_user) token = PCSAuth.validUser(params['username'],params['password'], true) # If we authorized to this machine, attempt to authorize everywhere node_list = [] if token and params[""bidirectional""] params.each { |k,v| if k.start_with?(""node-"") node_list.push(v) end } if node_list.length > 0 pcs_auth( auth_user, node_list, params['username'], params['password'], params[""force""] == ""1"" ) end end return token end"
1672,"it ""upserts the record matching selector with change"" do query.should_receive(:update).with(change, [:upsert]) query.upsert change end",True,Ruby,"""upserts the record matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def set_cluster_conf(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end if params[:cluster_conf] != nil and params[:cluster_conf].strip != """" Cfgsync::ClusterConf.backup() Cfgsync::ClusterConf.from_text(params[:cluster_conf]).save() return 200, 'Updated cluster.conf...' else $logger.info ""Invalid cluster.conf file"" return 400, 'Failed to update cluster.conf...' end end"
1673,"it ""upserts the record matching selector with change"" do query.should_receive(:update).with(change, [:upsert]) query.upsert change end",True,Ruby,"""upserts the record matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_resource(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end force = params['force'] no_error_if_not_exists = params.include?('no_error_if_not_exists') errors = """" params.each { |k,v| if k.index(""resid-"") == 0 resid = k.gsub('resid-', '') command = [PCS, 'resource', 'delete', resid] command << '--force' if force out, errout, retval = run_cmd(auth_user, *command) if retval != 0 unless out.index("" does not exist."") != -1 and no_error_if_not_exists errors += errout.join(' ').strip + ""\n"" end end end } errors.strip! if errors == """" return 200 else $logger.info(""Remove resource errors:\n""+errors) return [400, errors] end end"
1674,"it ""updates the selector to mongo's advanced selector"" do query.sort(a: 1) query.operation.selector.should eq( ""$query"" => selector, ""$orderby"" => { a: 1 } ) end",True,Ruby,"""updates the selector to mongo's advanced selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remote_add_node(params, request, auth_user, all=false) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end auto_start = false if params[:auto_start] and params[:auto_start] == ""1"" auto_start = true end if params[:new_nodename] != nil node = params[:new_nodename] if params[:new_ring1addr] != nil node += ',' + params[:new_ring1addr] end retval, output = add_node(auth_user, node, all, auto_start) end if retval == 0 return [200, JSON.generate([retval, get_corosync_conf()])] end return [400,output] end"
1675,"it ""updates the selector to mongo's advanced selector"" do query.sort(a: 1) query.operation.selector.should eq( ""$query"" => selector, ""$orderby"" => { a: 1 } ) end",True,Ruby,"""updates the selector to mongo's advanced selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remote_pcsd_restart(params, request, auth_user) pcsd_restart() return [200, 'success'] end"
1676,"it ""executes a distinct command"" do database.should_receive(:command).with( distinct: collection.name, key: ""name"", query: selector ).and_return(""values"" => [ ""durran"", ""bernerd"" ]) query.distinct(:name) end",True,Ruby,"""executes a distinct command""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_clone(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'clone', params[:resource_id] ) if retval != 0 return [400, 'Unable to create clone resource from ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end"
1677,"it ""executes a distinct command"" do database.should_receive(:command).with( distinct: collection.name, key: ""name"", query: selector ).and_return(""values"" => [ ""durran"", ""bernerd"" ]) query.distinct(:name) end",True,Ruby,"""executes a distinct command""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_constraint_rule_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end if params[""c_type""] == ""loc"" retval, error = add_location_constraint_rule( auth_user, params[""res_id""], params[""rule""], params[""score""], params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params[""c_type""]}""] end if retval == 0 return [200, ""Successfully added constraint""] else return [400, ""Error adding constraint: #{error}""] end end"
1684,"it ""sets the query operation's skip field"" do query.skip(5) query.operation.skip.should eq 5 end",True,Ruby,"""sets the query operation's skip field""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def node_standby(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'node_standby', true, {""node""=>params[:name]} ) # data={""node""=>params[:name]} for backward compatibility with older versions of pcs/pcsd else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Standby Node"" stdout, stderr, retval = run_cmd(auth_user, PCS, ""cluster"", ""standby"") return stdout end end"
1685,"it ""sets the query operation's skip field"" do query.skip(5) query.operation.skip.should eq 5 end",True,Ruby,"""sets the query operation's skip field""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def update_resource (params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end param_line = getParamList(params) if not params[:resource_id] out, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""create"", params[:name], params[:resource_type], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end if params[:resource_group] and params[:resource_group] != """" run_cmd( auth_user, PCS, ""resource"",""group"", ""add"", params[:resource_group], params[:name] ) resource_group = params[:resource_group] end if params[:resource_clone] and params[:resource_clone] != """" name = resource_group ? resource_group : params[:name] run_cmd(auth_user, PCS, ""resource"", ""clone"", name) elsif params[:resource_ms] and params[:resource_ms] != """" name = resource_group ? resource_group : params[:name] run_cmd(auth_user, PCS, ""resource"", ""master"", name) end return JSON.generate({}) end if param_line.length != 0 # If it's a clone resource we strip off everything after the last ':' if params[:resource_clone] params[:resource_id].sub!(/(.*):.*/,'\1') end run_cmd( auth_user, PCS, ""resource"", ""update"", params[:resource_id], *param_line ) end if params[:resource_group] if params[:resource_group] == """" if params[:_orig_resource_group] != """" run_cmd( auth_user, PCS, ""resource"", ""group"", ""remove"", params[:_orig_resource_group], params[:resource_id] ) end else run_cmd( auth_user, PCS, ""resource"", ""group"", ""add"", params[:resource_group], params[:resource_id] ) end end if params[:resource_clone] and params[:_orig_resource_clone] == ""false"" run_cmd(auth_user, PCS, ""resource"", ""clone"", params[:resource_id]) end if params[:resource_ms] and params[:_orig_resource_ms] == ""false"" run_cmd(auth_user, PCS, ""resource"", ""master"", params[:resource_id]) end if params[:_orig_resource_clone] == ""true"" and not params[:resource_clone] run_cmd( auth_user, PCS, ""resource"", ""unclone"", params[:resource_id].sub(/:.*/,'') ) end if params[:_orig_resource_ms] == ""true"" and not params[:resource_ms] run_cmd( auth_user, PCS, ""resource"", ""unclone"", params[:resource_id].sub(/:.*/,'') ) end return JSON.generate({}) end"
1686,"it ""stores the selector"" do query.selector.should eq selector end",True,Ruby,"""stores the selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_metadata(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end return 200 if not params[:resourcename] or params[:resourcename] == """" resource_name = params[:resourcename][params[:resourcename].rindex(':')+1..-1] class_provider = params[:resourcename][0,params[:resourcename].rindex(':')] @resource = ResourceAgent.new(params[:resourcename]) if class_provider == ""ocf:heartbeat"" @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, HEARTBEAT_AGENTS_DIR + resource_name) elsif class_provider == ""ocf:pacemaker"" @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, PACEMAKER_AGENTS_DIR + resource_name) elsif class_provider == 'nagios' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(auth_user, NAGIOS_METADATA_DIR + resource_name + '.xml') end @new_resource = params[:new] @resources, @groups = getResourcesGroups(auth_user) erb :resourceagentform end"
1687,"it ""stores the selector"" do query.selector.should eq selector end",True,Ruby,"""stores the selector""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def cluster_start(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'cluster_start', true ) else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Starting Daemons"" output = `#{PCS} cluster start` $logger.debug output return output end end"
1688,"it ""sets the query operation's fields"" do query.select(a: 1) query.operation.fields.should eq(a: 1) end",True,Ruby,"""sets the query operation's fields""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_sw_versions(params, request, auth_user) versions = { ""rhel"" => get_rhel_version(), ""pcs"" => get_pcsd_version(), ""pacemaker"" => get_pacemaker_version(), ""corosync"" => get_corosync_version(), ""cman"" => get_cman_version(), } return JSON.generate(versions) end"
1689,"it ""sets the query operation's fields"" do query.select(a: 1) query.operation.fields.should eq(a: 1) end",True,Ruby,"""sets the query operation's fields""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def save_tokens(params, request, auth_user) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, ""Permission denied"" end new_tokens = {} params.each{|nodes| if nodes[0].start_with?""node:"" and nodes[0].length > 5 node = nodes[0][5..-1] token = nodes[1] new_tokens[node] = token end } tokens_cfg = Cfgsync::PcsdTokens.from_file('') sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, get_corosync_nodes(), $cluster_name ) if sync_successful return [200, JSON.generate(read_tokens())] else return [400, ""Cannot update tokenfile.""] end end"
1692,"it ""returns an enumerator"" do cursor = mock(Moped::Cursor) Moped::Cursor.stub(new: cursor) query.each.should be_a Enumerator end",True,Ruby,"""returns an enumerator""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def cluster_disable(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'cluster_disable', true ) else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end success = disable_cluster(auth_user) if not success return JSON.generate({""error"" => ""true""}) end return ""Cluster Disabled"" end end"
1693,"it ""returns an enumerator"" do cursor = mock(Moped::Cursor) Moped::Cursor.stub(new: cursor) query.each.should be_a Enumerator end",True,Ruby,"""returns an enumerator""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_permissions_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) data = { 'user_types' => Permissions::get_user_types(), 'permission_types' => Permissions::get_permission_types(), 'permissions_dependencies' => Permissions::permissions_dependencies(), 'users_permissions' => pcs_config.permissions_local.to_hash(), } return [200, JSON.generate(data)] end"
1696,"it ""returns the query"" do query.limit(5).should eql query end",True,Ruby,"""returns the query""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def fence_device_form(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end @cur_resource = get_resource_by_id(params[:resource], get_cib_dom(auth_user)) if @cur_resource.instance_of?(ClusterEntity::Primitive) and @cur_resource.stonith @resource_agents = getFenceAgents(auth_user, @cur_resource.agentname) @existing_resource = true @fenceagent = @resource_agents[@cur_resource.type] erb :fenceagentform else ""Can't find fence device"" end end"
1697,"it ""returns the query"" do query.limit(5).should eql query end",True,Ruby,"""returns the query""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_fence_level_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end retval, stdout, stderr = add_fence_level( auth_user, params[""level""], params[""devices""], params[""node""], params[""remove""] ) if retval == 0 return [200, ""Successfully added fence level""] else return [400, stderr] end end"
1700,"it ""yields all documents in the cursor"" do cursor = Moped::Cursor.allocate cursor.stub(:to_enum).and_return([1, 2].to_enum) Moped::Cursor.stub(new: cursor) query.to_a.should eq [1, 2] end",True,Ruby,"""yields all documents in the cursor""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_acl_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end if params[""item""] == ""permission"" retval = add_acl_permission( auth_user, params[""role_id""], params[""type""], params[""xpath_id""], params[""query_id""] ) elsif (params[""item""] == ""user"") or (params[""item""] == ""group"") retval = add_acl_usergroup( auth_user, params[""role_id""], params[""item""], params[""usergroup""] ) else retval = ""Error: Unknown adding request"" end if retval == """" return [200, ""Successfully added permission to role""] else return [ 400, retval.include?(""cib_replace failed"") ? ""Error adding permission"" : retval ] end end"
1701,"it ""yields all documents in the cursor"" do cursor = Moped::Cursor.allocate cursor.stub(:to_enum).and_return([1, 2].to_enum) Moped::Cursor.stub(new: cursor) query.to_a.should eq [1, 2] end",True,Ruby,"""yields all documents in the cursor""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remote_remove_nodes(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end count = 0 out = """" node_list = [] options = [] while params[""nodename-"" + count.to_s] node_list << params[""nodename-"" + count.to_s] count = count + 1 end options << ""--force"" if params[""force""] cur_node = get_current_node_name() if i = node_list.index(cur_node) node_list.push(node_list.delete_at(i)) end # stop the nodes at once in order to: # - prevent resources from moving pointlessly # - get possible quorum loss warning stop_params = node_list + options stdout, stderr, retval = run_cmd( auth_user, PCS, ""cluster"", ""stop"", *stop_params ) if retval != 0 return [400, stderr.join] end node_list.each {|node| retval, output = remove_node(auth_user, node, true) out = out + output.join(""\n"") } config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) if config.get_nodes($cluster_name) == nil or config.get_nodes($cluster_name).length == 0 return [200,""No More Nodes""] end return out end"
1706,"it ""removes all matching documents"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |delete| delete.flags.should eq [] delete.selector.should eq query.operation.selector end query.remove_all end",True,Ruby,"""removes all matching documents""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remote_remove_node(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end if params[:remove_nodename] != nil retval, output = remove_node(auth_user, params[:remove_nodename]) else return 400, ""No nodename specified"" end if retval == 0 return JSON.generate([retval, get_corosync_conf()]) end return JSON.generate([retval,output]) end"
1707,"it ""removes all matching documents"" do session.should_receive(:with, :consistency => :strong). and_yield(session) session.should_receive(:execute).with do |delete| delete.flags.should eq [] delete.selector.should eq query.operation.selector end query.remove_all end",True,Ruby,"""removes all matching documents""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_avail_resource_agents(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end agents = getResourceAgents(auth_user) return JSON.generate(agents) end"
1716,"it ""changes the $orderby"" do query.sort(a: 1) query.sort(a: 2) query.operation.selector.should eq( ""$query"" => selector, ""$orderby"" => { a: 2 } ) end",True,Ruby,"""changes the $orderby""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_cluster_properties_definition(params, request, auth_user) unless allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end stdout, _, retval = run_cmd( auth_user, PCS, 'property', 'get_cluster_properties_definition' ) if retval == 0 return [200, stdout] end return [400, '{}'] end"
1717,"it ""changes the $orderby"" do query.sort(a: 1) query.sort(a: 2) query.operation.selector.should eq( ""$query"" => selector, ""$orderby"" => { a: 2 } ) end",True,Ruby,"""changes the $orderby""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def set_sync_options(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end options = [ 'sync_thread_pause', 'sync_thread_resume', 'sync_thread_disable', 'sync_thread_enable', ] if params.keys.count { |key| options.include?(key) } != 1 return [400, 'Exactly one option has to be specified'] end if params['sync_thread_disable'] if Cfgsync::ConfigSyncControl.sync_thread_disable($semaphore_cfgsync) return 'sync thread disabled' else return [400, 'sync thread disable error'] end end if params['sync_thread_enable'] if Cfgsync::ConfigSyncControl.sync_thread_enable() return 'sync thread enabled' else return [400, 'sync thread enable error'] end end if params['sync_thread_resume'] if Cfgsync::ConfigSyncControl.sync_thread_resume() return 'sync thread resumed' else return [400, 'sync thread resume error'] end end if params['sync_thread_pause'] if Cfgsync::ConfigSyncControl.sync_thread_pause( $semaphore_cfgsync, params['sync_thread_pause'] ) return 'sync thread paused' else return [400, 'sync thread pause error'] end end return [400, 'Exactly one option has to be specified'] end"
1720,"it ""returns the count"" do database.stub(command: { ""n"" => 4 }) query.count.should eq 4 end",True,Ruby,"""returns the count""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remove_constraint_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end if params[:constraint_id] retval = remove_constraint(auth_user, params[:constraint_id]) if retval == 0 return ""Constraint #{params[:constraint_id]} removed"" else return [400, ""Error removing constraint: #{params[:constraint_id]}""] end else return [400,""Bad Constraint Options""] end end"
1721,"it ""returns the count"" do database.stub(command: { ""n"" => 4 }) query.count.should eq 4 end",True,Ruby,"""returns the count""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def set_certs(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end ssl_cert = (params['ssl_cert'] || '').strip ssl_key = (params['ssl_key'] || '').strip if ssl_cert.empty? and !ssl_key.empty? return [400, 'cannot save ssl certificate without ssl key'] end if !ssl_cert.empty? and ssl_key.empty? return [400, 'cannot save ssl key without ssl certificate'] end if !ssl_cert.empty? and !ssl_key.empty? ssl_errors = verify_cert_key_pair(ssl_cert, ssl_key) if ssl_errors and !ssl_errors.empty? return [400, ssl_errors.join] end begin write_file_lock(CRT_FILE, 0700, ssl_cert) write_file_lock(KEY_FILE, 0700, ssl_key) rescue => e # clean the files if we ended in the middle # the files will be regenerated on next pcsd start FileUtils.rm(CRT_FILE, {:force => true}) FileUtils.rm(KEY_FILE, {:force => true}) return [400, ""cannot save ssl files: #{e}""] end end if params['cookie_secret'] cookie_secret = params['cookie_secret'].strip if !cookie_secret.empty? begin write_file_lock(COOKIE_FILE, 0700, cookie_secret) rescue => e return [400, ""cannot save cookie secret: #{e}""] end end end return [200, 'success'] end"
1724,"it ""creates a new cursor"" do cursor = mock(Moped::Cursor, next: nil) Moped::Cursor.should_receive(:new). with(session, query.operation).and_return(cursor) query.each end",True,Ruby,"""creates a new cursor""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_group(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end rg = params[""resource_group""] resources = params[""resources""] output, errout, retval = run_cmd( auth_user, PCS, ""resource"", ""group"", ""add"", rg, *(resources.split("" "")) ) if retval == 0 return 200 else return 400, errout end end"
1725,"it ""creates a new cursor"" do cursor = mock(Moped::Cursor, next: nil) Moped::Cursor.should_receive(:new). with(session, query.operation).and_return(cursor) query.each end",True,Ruby,"""creates a new cursor""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def fence_device_metadata(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end return 200 if not params[:resourcename] or params[:resourcename] == """" @fenceagent = FenceAgent.new(params[:resourcename]) @fenceagent.required_options, @fenceagent.optional_options, @fenceagent.advanced_options, @fenceagent.info = getFenceAgentMetadata(auth_user, params[:resourcename]) @new_fenceagent = params[:new] erb :fenceagentform end"
1730,"it ""sets the query operation's limit field"" do query.limit(5) query.operation.limit.should eq 5 end",True,Ruby,"""sets the query operation's limit field""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def status_all(params, request, auth_user, nodes=[], dont_update_config=false) if nodes == nil return JSON.generate({""error"" => ""true""}) end final_response = {} threads = [] forbidden_nodes = {} nodes.each {|node| threads << Thread.new { code, response = send_request_with_token(auth_user, node, 'status') if 403 == code forbidden_nodes[node] = true end begin final_response[node] = JSON.parse(response) rescue JSON::ParserError => e final_response[node] = {""bad_json"" => true} $logger.info(""ERROR: Parse Error when parsing status JSON from #{node}"") end if final_response[node] and final_response[node][""notoken""] == true $logger.error(""ERROR: bad token for #{node}"") end } } threads.each { |t| t.join } if forbidden_nodes.length > 0 return 403, 'Permission denied' end # Get full list of nodes and see if we need to update the configuration node_list = [] final_response.each { |fr,n| node_list += n[""corosync_offline""] if n[""corosync_offline""] node_list += n[""corosync_online""] if n[""corosync_online""] node_list += n[""pacemaker_offline""] if n[""pacemaker_offline""] node_list += n[""pacemaker_online""] if n[""pacemaker_online""] } node_list.uniq! if node_list.length > 0 config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) old_node_list = config.get_nodes(params[:cluster]) if !(dont_update_config or config.cluster_nodes_equal?(params[:cluster], node_list)) $logger.info(""Updating node list for: #{params[:cluster]} #{old_node_list}->#{node_list}"") config.update_cluster(params[:cluster], node_list) sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return status_all(params, request, auth_user, node_list, true) end end $logger.debug(""NODE LIST: "" + node_list.inspect) return JSON.generate(final_response) end"
1731,"it ""sets the query operation's limit field"" do query.limit(5) query.operation.limit.should eq 5 end",True,Ruby,"""sets the query operation's limit field""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_cluster_tokens(params, request, auth_user) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, ""Permission denied"" end on, off = get_nodes nodes = on + off nodes.uniq! return [200, JSON.generate(get_tokens_of_nodes(nodes))] end"
1732,"it ""updates all records matching selector with change"" do query.should_receive(:update).with(change, [:multi]) query.update_all change end",True,Ruby,"""updates all records matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_wizard(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end wizard = PCSDWizard.getWizard(params[""wizard""]) if wizard != nil return erb wizard.collection_page else return ""Error finding Wizard - #{params[""wizard""]}"" end end"
1733,"it ""updates all records matching selector with change"" do query.should_receive(:update).with(change, [:multi]) query.update_all change end",True,Ruby,"""updates all records matching selector with change""",query_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def config_backup(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'config_backup', true ) else if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end $logger.info ""Backup node configuration"" stdout, stderr, retval = run_cmd(auth_user, PCS, ""config"", ""backup"") if retval == 0 $logger.info ""Backup successful"" return [200, stdout] end $logger.info ""Error during backup: #{stderr.join(' ').strip()}"" return [400, ""Unable to backup node: #{stderr.join(' ')}""] end end"
1740,"it ""sets slave_ok on the query flags"" do session.stub(socket_for: socket) socket.should_receive(:execute) do |query| query.flags.should include :slave_ok end session.query(query) end",True,Ruby,"""sets slave_ok on the query flags""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def cluster_status_gui(auth_user, cluster_name, dont_update_config=false) cluster_nodes = get_cluster_nodes(cluster_name) status = cluster_status_from_nodes(auth_user, cluster_nodes, cluster_name) unless status return 403, 'Permission denied' end new_cluster_nodes = [] new_cluster_nodes += status[:corosync_offline] if status[:corosync_offline] new_cluster_nodes += status[:corosync_online] if status[:corosync_online] new_cluster_nodes += status[:pacemaker_offline] if status[:pacemaker_offline] new_cluster_nodes += status[:pacemaker_online] if status[:pacemaker_online] new_cluster_nodes.uniq! if new_cluster_nodes.length > 0 config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) if !(dont_update_config or config.cluster_nodes_equal?(cluster_name, new_cluster_nodes)) old_cluster_nodes = config.get_nodes(cluster_name) $logger.info(""Updating node list for: #{cluster_name} #{old_cluster_nodes}->#{new_cluster_nodes}"") config.update_cluster(cluster_name, new_cluster_nodes) sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return cluster_status_gui(auth_user, cluster_name, true) end end return JSON.generate(status) end"
1741,"it ""sets slave_ok on the query flags"" do session.stub(socket_for: socket) socket.should_receive(:execute) do |query| query.flags.should include :slave_ok end session.query(query) end",True,Ruby,"""sets slave_ok on the query flags""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_constraint_rule_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end if params[:rule_id] retval = remove_constraint_rule(auth_user, params[:rule_id]) if retval == 0 return ""Constraint rule #{params[:rule_id]} removed"" else return [400, ""Error removing constraint rule: #{params[:rule_id]}""] end else return [400, ""Bad Constraint Rule Options""] end end"
1742,"it ""executes the operation on the master node"" do session.should_receive(:socket_for).with(:write). and_return(socket) socket.should_receive(:execute).with(operation) session.execute(operation) end",True,Ruby,"""executes the operation on the master node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def cluster_enable(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'cluster_enable', true ) else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end success = enable_cluster(auth_user) if not success return JSON.generate({""error"" => ""true""}) end return ""Cluster Enabled"" end end"
1743,"it ""executes the operation on the master node"" do session.should_receive(:socket_for).with(:write). and_return(socket) socket.should_receive(:execute).with(operation) session.execute(operation) end",True,Ruby,"""executes the operation on the master node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def cluster_stop(params, request, auth_user) if params[:name] params_without_name = params.reject {|key, value| key == ""name"" or key == :name } code, response = send_request_with_token( auth_user, params[:name], 'cluster_stop', true, params_without_name ) else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end options = [] if params.has_key?(""component"") if params[""component""].downcase == ""pacemaker"" options << ""--pacemaker"" elsif params[""component""].downcase == ""corosync"" options << ""--corosync"" end end options << ""--force"" if params[""force""] $logger.info ""Stopping Daemons"" stdout, stderr, retval = run_cmd( auth_user, PCS, ""cluster"", ""stop"", *options ) if retval != 0 return [400, stderr.join] else return stdout.join end end end"
1746,"it ""returns a new session"" do session.with(new_options).should_not eql session end",True,Ruby,"""returns a new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_ungroup(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:group_id] return [400, 'group_id has to be specified.'] end _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'ungroup', params[:group_id] ) if retval != 0 return [400, 'Unable to ungroup group ' + ""'#{params[:group_id]}': #{stderr.join('')}"" ] end return 200 end"
1747,"it ""returns a new session"" do session.with(new_options).should_not eql session end",True,Ruby,"""returns a new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_corosync_conf_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end return get_corosync_conf() end"
1752,"it ""returns the document"" do session.simple_query(query).should eq(a: 1) end",True,Ruby,"""returns the document""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_node_attr_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end retval = add_node_attr( auth_user, params[""node""], params[""key""], params[""value""] ) # retval = 2 if removing attr which doesn't exist if retval == 0 or retval == 2 return [200, ""Successfully added attribute to node""] else return [400, ""Error adding attribute to node""] end end"
1753,"it ""returns the document"" do session.simple_query(query).should eq(a: 1) end",True,Ruby,"""returns the document""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_acl_roles_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end errors = """" params.each { |name, value| if name.index(""role-"") == 0 out, errout, retval = run_cmd( auth_user, PCS, ""acl"", ""role"", ""delete"", value.to_s, ""--autodelete"" ) if retval != 0 errors += ""Unable to remove role #{value}"" unless errout.include?(""cib_replace failure"") errors += "": #{errout.join("" "").strip()}"" end errors += ""\n"" $logger.info errors end end } if errors == """" return [200, ""Successfully removed ACL roles""] else return [400, errors] end end"
1754,"it ""stores the options provided"" do session.options.should eq(options) end",True,Ruby,"""stores the options provided""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_start(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""enable"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end"
1755,"it ""stores the options provided"" do session.options.should eq(options) end",True,Ruby,"""stores the options provided""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def set_resource_utilization(params, reqest, auth_user) unless allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] and params[:name] return 400, 'resource_id and name are required' end res_id = params[:resource_id] name = params[:name] value = params[:value] || '' _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'utilization', res_id, ""#{name}=#{value}"" ) if retval != 0 return [400, ""Unable to set utilization '#{name}=#{value}' for "" + ""resource '#{res_id}': #{stderr.join('')}"" ] end return 200 end"
1756,"it ""delegates to the current database"" do database = mock(Moped::Database) session.should_receive(:current_database).and_return(database) database.should_receive(:drop) session.drop end",True,Ruby,"""delegates to the current database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remote_node_available(params, request, auth_user) if (not ISRHEL6 and File.exist?(Cfgsync::CorosyncConf.file_path)) or (ISRHEL6 and File.exist?(Cfgsync::ClusterConf.file_path)) or File.exist?(""/var/lib/pacemaker/cib/cib.xml"") return JSON.generate({:node_available => false}) end return JSON.generate({:node_available => true}) end"
1757,"it ""delegates to the current database"" do database = mock(Moped::Database) session.should_receive(:current_database).and_return(database) database.should_receive(:drop) session.drop end",True,Ruby,"""delegates to the current database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_constraint_set_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end case params[""c_type""] when ""ord"" retval, error = add_order_set_constraint( auth_user, params[""resources""].values, params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params[""c_type""]}""] end"
1758,"it ""executes the operation on a slave node"" do session.should_receive(:socket_for).with(:read). and_return(socket) socket.should_receive(:execute).with(operation) session.execute(operation) end",True,Ruby,"""executes the operation on a slave node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_tokens(params, request, auth_user) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end return [200, JSON.generate(read_tokens)] end"
1759,"it ""executes the operation on a slave node"" do session.should_receive(:socket_for).with(:read). and_return(socket) socket.should_receive(:execute).with(operation) session.execute(operation) end",True,Ruby,"""executes the operation on a slave node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def node_restart(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'node_restart', true ) else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Restarting Node"" output = `/sbin/reboot` $logger.debug output return output end end"
1760,"it ""merges the old and new session's options"" do session.with(new_options) do |new_session| new_session.options.should eq options.merge(new_options) end end",True,Ruby,"""merges the old and new session's options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_cib(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end cib, stderr, retval = run_cmd(auth_user, CIBADMIN, ""-Ql"") if retval != 0 if not pacemaker_running? return [400, '{""pacemaker_not_running"":true}'] end return [500, ""Unable to get CIB: "" + cib.to_s + stderr.to_s] else return [200, cib] end end"
1761,"it ""merges the old and new session's options"" do session.with(new_options) do |new_session| new_session.options.should eq options.merge(new_options) end end",True,Ruby,"""merges the old and new session's options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_constraint_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end case params[""c_type""] when ""loc"" retval, error = add_location_constraint( auth_user, params[""res_id""], params[""node_id""], params[""score""], params[""force""], !params['disable_autocorrect'] ) when ""ord"" resA = params[""res_id""] resB = params[""target_res_id""] actionA = params['res_action'] actionB = params['target_action'] if params[""order""] == ""before"" resA, resB = resB, resA actionA, actionB = actionB, actionA end retval, error = add_order_constraint( auth_user, resA, resB, actionA, actionB, params[""score""], true, params[""force""], !params['disable_autocorrect'] ) when ""col"" resA = params[""res_id""] resB = params[""target_res_id""] score = params[""score""] if params[""colocation_type""] == ""apart"" if score.length > 0 and score[0] != ""-"" score = ""-"" + score elsif score == """" score = ""-INFINITY"" end end retval, error = add_colocation_constraint( auth_user, resA, resB, score, params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params['c_type']}""] end"
1764,"it ""queries a slave node"" do session.should_receive(:socket_for).with(:read). and_return(socket) session.query(query) end",True,Ruby,"""queries a slave node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_change_group(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end if params[:resource_id].nil? or params[:group_id].nil? return [400, 'resource_id and group_id have to be specified.'] end if params[:group_id].empty? if params[:old_group_id] _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'group', 'remove', params[:old_group_id], params[:resource_id] ) if retval != 0 return [400, ""Unable to remove resource '#{params[:resource_id]}' "" + ""from group '#{params[:old_group_id]}': #{stderr.join('')}"" ] end end return 200 end _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'group', 'add', params[:group_id], params[:resource_id] ) if retval != 0 return [400, ""Unable to add resource '#{params[:resource_id]}' to "" + ""group '#{params[:group_id]}': #{stderr.join('')}"" ] end return 200 end"
1765,"it ""queries a slave node"" do session.should_receive(:socket_for).with(:read). and_return(socket) session.query(query) end",True,Ruby,"""queries a slave node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_configs(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end if not $cluster_name or $cluster_name.empty? return JSON.generate({'status' => 'not_in_cluster'}) end if params[:cluster_name] != $cluster_name return JSON.generate({'status' => 'wrong_cluster_name'}) end out = { 'status' => 'ok', 'cluster_name' => $cluster_name, 'configs' => {}, } Cfgsync::get_configs_local.each { |name, cfg| out['configs'][cfg.class.name] = { 'type' => 'file', 'text' => cfg.text, } } return JSON.generate(out) end"
1766,"it ""limits the query"" do session.should_receive(:query) do |query| query.limit.should eq(-1) reply end session.simple_query(query) end",True,Ruby,"""limits the query""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_sync_capabilities(params, request, auth_user) return JSON.generate({ 'syncable_configs' => Cfgsync::get_cfg_classes_by_name().keys, }) end"
1767,"it ""limits the query"" do session.should_receive(:query) do |query| query.limit.should eq(-1) reply end session.simple_query(query) end",True,Ruby,"""limits the query""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def remove_acl_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end if params[""item""] == ""permission"" retval = remove_acl_permission(auth_user, params[""acl_perm_id""]) elsif params[""item""] == ""usergroup"" retval = remove_acl_usergroup( auth_user, params[""role_id""],params[""usergroup_id""] ) else retval = ""Error: Unknown removal request"" end if retval == """" return [200, ""Successfully removed permission from role""] else return [400, retval] end end"
1768,"it ""returns true"" do session.should be_safe end",True,Ruby,"""returns true""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def remote(params, request, auth_user) remote_cmd_without_pacemaker = { :status => method(:node_status), :status_all => method(:status_all), :cluster_status => method(:cluster_status_remote), :auth => method(:auth), :check_auth => method(:check_auth), :setup_cluster => method(:setup_cluster), :create_cluster => method(:create_cluster), :get_quorum_info => method(:get_quorum_info), :get_cib => method(:get_cib), :get_corosync_conf => method(:get_corosync_conf_remote), :set_cluster_conf => method(:set_cluster_conf), :set_corosync_conf => method(:set_corosync_conf), :get_sync_capabilities => method(:get_sync_capabilities), :set_sync_options => method(:set_sync_options), :get_configs => method(:get_configs), :set_configs => method(:set_configs), :set_certs => method(:set_certs), :pcsd_restart => method(:remote_pcsd_restart), :get_permissions => method(:get_permissions_remote), :set_permissions => method(:set_permissions_remote), :cluster_start => method(:cluster_start), :cluster_stop => method(:cluster_stop), :config_backup => method(:config_backup), :config_restore => method(:config_restore), :node_restart => method(:node_restart), :node_standby => method(:node_standby), :node_unstandby => method(:node_unstandby), :cluster_enable => method(:cluster_enable), :cluster_disable => method(:cluster_disable), :resource_status => method(:resource_status), :get_sw_versions => method(:get_sw_versions), :node_available => method(:remote_node_available), :add_node_all => lambda { |params_, request_, auth_user_| remote_add_node(params_, request_, auth_user_, true) }, :add_node => lambda { |params_, request_, auth_user_| remote_add_node(params_, request_, auth_user_, false) }, :remove_nodes => method(:remote_remove_nodes), :remove_node => method(:remote_remove_node), :cluster_destroy => method(:cluster_destroy), :get_wizard => method(:get_wizard), :wizard_submit => method(:wizard_submit), :get_tokens => method(:get_tokens), :get_cluster_tokens => method(:get_cluster_tokens), :save_tokens => method(:save_tokens), :get_cluster_properties_definition => method(:get_cluster_properties_definition) } remote_cmd_with_pacemaker = { :resource_start => method(:resource_start), :resource_stop => method(:resource_stop), :resource_cleanup => method(:resource_cleanup), :resource_form => method(:resource_form), :fence_device_form => method(:fence_device_form), :update_resource => method(:update_resource), :update_fence_device => method(:update_fence_device), :resource_metadata => method(:resource_metadata), :fence_device_metadata => method(:fence_device_metadata), :get_avail_resource_agents => method(:get_avail_resource_agents), :get_avail_fence_agents => method(:get_avail_fence_agents), :remove_resource => method(:remove_resource), :add_constraint_remote => method(:add_constraint_remote), :add_constraint_rule_remote => method(:add_constraint_rule_remote), :add_constraint_set_remote => method(:add_constraint_set_remote), :remove_constraint_remote => method(:remove_constraint_remote), :remove_constraint_rule_remote => method(:remove_constraint_rule_remote), :add_meta_attr_remote => method(:add_meta_attr_remote), :add_group => method(:add_group), :update_cluster_settings => method(:update_cluster_settings), :add_fence_level_remote => method(:add_fence_level_remote), :add_node_attr_remote => method(:add_node_attr_remote), :add_acl_role => method(:add_acl_role_remote), :remove_acl_roles => method(:remove_acl_roles_remote), :add_acl => method(:add_acl_remote), :remove_acl => method(:remove_acl_remote), :resource_change_group => method(:resource_change_group), :resource_master => method(:resource_master), :resource_clone => method(:resource_clone), :resource_unclone => method(:resource_unclone), :resource_ungroup => method(:resource_ungroup), :set_resource_utilization => method(:set_resource_utilization), :set_node_utilization => method(:set_node_utilization) } command = params[:command].to_sym if remote_cmd_without_pacemaker.include? command return remote_cmd_without_pacemaker[command].call( params, request, auth_user ) elsif remote_cmd_with_pacemaker.include? command if pacemaker_running? return remote_cmd_with_pacemaker[command].call(params, request, auth_user) else return [200,'{""pacemaker_not_running"":true}'] end else return [404, ""Unknown Request""] end end"
1769,"it ""returns true"" do session.should be_safe end",True,Ruby,"""returns true""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def config_restore(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'config_restore', true, {:tarball => params[:tarball]} ) else if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end $logger.info ""Restore node configuration"" if params[:tarball] != nil and params[:tarball] != """" out = """" errout = """" status = Open4::popen4(PCS, ""config"", ""restore"", ""--local"") { |pid, stdin, stdout, stderr| stdin.print(params[:tarball]) stdin.close() out = stdout.readlines() errout = stderr.readlines() } retval = status.exitstatus if retval == 0 $logger.info ""Restore successful"" return ""Succeeded"" else $logger.info ""Error during restore: #{errout.join(' ').strip()}"" return errout.length > 0 ? errout.join(' ').strip() : ""Error"" end else $logger.info ""Error: Invalid tarball"" return ""Error: Invalid tarball"" end end end"
1770,"it ""doesn't try to set flags"" do session.stub(socket_for: socket) expect { session.query(query) }.not_to raise_exception end",True,Ruby,"""doesn't try to set flags""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def add_meta_attr_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end retval = add_meta_attr( auth_user, params[""res_id""], params[""key""],params[""value""] ) if retval == 0 return [200, ""Successfully added meta attribute""] else return [400, ""Error adding meta attribute""] end end"
1771,"it ""doesn't try to set flags"" do session.stub(socket_for: socket) expect { session.query(query) }.not_to raise_exception end",True,Ruby,"""doesn't try to set flags""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def resource_master(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( auth_user, PCS, 'resource', 'master', params[:resource_id] ) if retval != 0 return [400, 'Unable to create master/slave resource from ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end"
1772,"it ""yields a new session"" do session.with(new_options) do |new_session| new_session.should_not eql session end end",True,Ruby,"""yields a new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def set_configs(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end return JSON.generate({'status' => 'bad_json'}) if not params['configs'] begin configs_json = JSON.parse(params['configs']) rescue JSON::ParserError return JSON.generate({'status' => 'bad_json'}) end has_cluster = !($cluster_name == nil or $cluster_name.empty?) if has_cluster and $cluster_name != configs_json['cluster_name'] return JSON.generate({'status' => 'wrong_cluster_name'}) end $semaphore_cfgsync.synchronize { force = configs_json['force'] remote_configs, unknown_cfg_names = Cfgsync::sync_msg_to_configs(configs_json) local_configs = Cfgsync::get_configs_local result = {} unknown_cfg_names.each { |name| result[name] = 'not_supported' } remote_configs.each { |name, remote_cfg| begin # Save a remote config if it is a newer version than local. If the config # is not present on a local node, the node is beeing added to a cluster, # so we need to save the config as well. if force or not local_configs.key?(name) or remote_cfg > local_configs[name] local_configs[name].class.backup() if local_configs.key?(name) remote_cfg.save() result[name] = 'accepted' elsif remote_cfg == local_configs[name] # Someone wants this node to have a config that it already has. # So the desired state is met and the result is a success then. result[name] = 'accepted' else result[name] = 'rejected' end rescue => e $logger.error(""Error saving config '#{name}': #{e}"") result[name] = 'error' end } return JSON.generate({'status' => 'ok', 'result' => result}) } end"
1773,"it ""yields a new session"" do session.with(new_options) do |new_session| new_session.should_not eql session end end",True,Ruby,"""yields a new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def cluster_status_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end cluster_name = $cluster_name # If node is not in a cluster, return empty data if not cluster_name or cluster_name.empty? overview = { :cluster_name => nil, :error_list => [], :warning_list => [], :quorate => nil, :status => 'unknown', :node_list => [], :resource_list => [], } return JSON.generate(overview) end cluster_nodes = get_nodes().flatten status = cluster_status_from_nodes(auth_user, cluster_nodes, cluster_name) unless status return 403, 'Permission denied' end return JSON.generate(status) end"
1776,"it ""instructs the cluster to reconnect"" do session.stub(with: new_session) new_session.cluster.should_receive(:reconnect) session.new(new_options) end",True,Ruby,"""instructs the cluster to reconnect""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_status(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end resource_id = params[:resource] @resources,@groups = getResourcesGroups(auth_user) location = """" res_status = """" @resources.each {|r| if r.id == resource_id if r.failed res_status = ""Failed"" elsif !r.active res_status = ""Inactive"" else res_status = ""Running"" end if r.nodes.length != 0 location = r.nodes[0].name break end end } status = {""location"" => location, ""status"" => res_status} return JSON.generate(status) end"
1777,"it ""instructs the cluster to reconnect"" do session.stub(with: new_session) new_session.cluster.should_receive(:reconnect) session.new(new_options) end",True,Ruby,"""instructs the cluster to reconnect""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def setup_cluster(params, request, auth_user) if not allowed_for_superuser(auth_user) return 403, 'Permission denied' end $logger.info(""Setting up cluster: "" + params.inspect) nodes_rrp = params[:nodes].split(';') options = [] myoptions = JSON.parse(params[:options]) transport_udp = false options_udp = [] myoptions.each { |o,v| if [""wait_for_all"", ""last_man_standing"", ""auto_tie_breaker""].include?(o) options << ""--"" + o + ""=1"" end options << ""--"" + o + ""="" + v if [ ""token"", ""token_coefficient"", ""join"", ""consensus"", ""miss_count_const"", ""fail_recv_const"", ""last_man_standing_window"", ].include?(o) if o == ""transport"" and v == ""udp"" options << ""--transport=udp"" transport_udp = true end if o == ""transport"" and v == ""udpu"" options << ""--transport=udpu"" transport_udp = false end if [""addr0"", ""addr1"", ""mcast0"", ""mcast1"", ""mcastport0"", ""mcastport1"", ""ttl0"", ""ttl1""].include?(o) options_udp << ""--"" + o + ""="" + v end if [""broadcast0"", ""broadcast1""].include?(o) options_udp << ""--"" + o end if o == ""ipv6"" options << ""--ipv6"" end } if transport_udp nodes = [] nodes_rrp.each { |node| nodes << node.split(',')[0] } else nodes = nodes_rrp end nodes_options = nodes + options nodes_options += options_udp if transport_udp stdout, stderr, retval = run_cmd( auth_user, PCS, ""cluster"", ""setup"", ""--enable"", ""--start"", ""--name"", params[:clustername], *nodes_options ) if retval != 0 return [ 400, (stdout + [''] + stderr).collect { |line| line.rstrip() }.join(""\n"") ] end return 200 end"
1778,"it ""sets the current database"" do session.should_receive(:set_current_database).with(:admin) session.use :admin end",True,Ruby,"""sets the current database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def node_unstandby(params, request, auth_user) if params[:name] code, response = send_request_with_token( auth_user, params[:name], 'node_unstandby', true, {""node""=>params[:name]} ) # data={""node""=>params[:name]} for backward compatibility with older versions of pcs/pcsd else if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Unstandby Node"" stdout, stderr, retval = run_cmd(auth_user, PCS, ""cluster"", ""unstandby"") return stdout end end"
1779,"it ""sets the current database"" do session.should_receive(:set_current_database).with(:admin) session.use :admin end",True,Ruby,"""sets the current database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def get_avail_fence_agents(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end agents = getFenceAgents(auth_user) return JSON.generate(agents) end"
1780,"it ""raises an exception"" do expect { session.current_database }.to raise_exception end",True,Ruby,"""raises an exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def set_node_utilization(params, reqest, auth_user) unless allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end unless params[:node] and params[:name] return 400, 'node and name are required' end node = params[:node] name = params[:name] value = params[:value] || '' _, stderr, retval = run_cmd( auth_user, PCS, 'node', 'utilization', node, ""#{name}=#{value}"" ) if retval != 0 return [400, ""Unable to set utilization '#{name}=#{value}' for node "" + ""'#{res_id}': #{stderr.join('')}"" ] end return 200 end"
1781,"it ""raises an exception"" do expect { session.current_database }.to raise_exception end",True,Ruby,"""raises an exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def check_auth(params, request, auth_user) if params.include?(""check_auth_only"") return [200, ""{\""success\"":true}""] end return JSON.generate({ 'success' => true, 'node_list' => get_token_node_list, }) end"
1782,"it ""stores the cluster"" do session.cluster.should be_a(Moped::Cluster) end",True,Ruby,"""stores the cluster""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def get_quorum_info(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end if ISRHEL6 stdout_status, stderr_status, retval = run_cmd( PCSAuth.getSuperuserAuth(), CMAN_TOOL, ""status"" ) stdout_nodes, stderr_nodes, retval = run_cmd( PCSAuth.getSuperuserAuth(), CMAN_TOOL, ""nodes"", ""-F"", ""id,type,votes,name"" ) if stderr_status.length > 0 return stderr_status.join elsif stderr_nodes.length > 0 return stderr_nodes.join else return stdout_status.join + ""\n---Votes---\n"" + stdout_nodes.join end else stdout, stderr, retval = run_cmd( PCSAuth.getSuperuserAuth(), COROSYNC_QUORUMTOOL, ""-p"", ""-s"" ) # retval is 0 on success if node is not in partition with quorum # retval is 1 on error OR on success if node has quorum if stderr.length > 0 return stderr.join else return stdout.join end end end"
1783,"it ""stores the cluster"" do session.cluster.should be_a(Moped::Cluster) end",True,Ruby,"""stores the cluster""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def update_cluster_settings(params, request, auth_user) properties = params['config'] to_update = [] current = getAllSettings(auth_user) # We need to be able to set cluster properties also from older version GUI. # This code handles proper processing of checkboxes. # === backward compatibility layer start === params['hidden'].each { |prop, val| next if prop == 'hidden_input' unless properties.include?(prop) properties[prop] = val to_update << prop end } # === backward compatibility layer end === properties.each { |prop, val| val.strip! if not current.include?(prop) and val != '' # add to_update << prop elsif current.include?(prop) and val == '' # remove to_update << prop elsif current.include?(prop) and current[prop] != val # update to_update << prop end } if to_update.count { |x| x.downcase == 'enable-acl' } > 0 if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end end if to_update.count { |x| x.downcase != 'enable-acl' } > 0 if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end end if to_update.empty? $logger.info('No properties to update') else cmd_args = [] to_update.each { |prop| cmd_args << ""#{prop.downcase}=#{properties[prop]}"" } stdout, stderr, retval = run_cmd( auth_user, PCS, 'property', 'set', *cmd_args ) if retval != 0 return [400, stderr.join('').gsub(', (use --force to override)', '')] end end return [200, ""Update Successful""] end"
1784,"it ""returns the result of the block"" do session.with(new_options) { false }.should eq false end",True,Ruby,"""returns the result of the block""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def cluster_destroy(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end out, errout, retval = run_cmd(auth_user, PCS, ""cluster"", ""destroy"") if retval == 0 return [200, ""Successfully destroyed cluster""] else return [400, ""Error destroying cluster:\n#{out}\n#{errout}\n#{retval}\n""] end end"
1785,"it ""returns the result of the block"" do session.with(new_options) { false }.should eq false end",True,Ruby,"""returns the result of the block""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def node_status(params, request, auth_user) if params[:node] and params[:node] != '' and params[:node] != $cur_node_name and !params[:redirected] return send_request_with_token( auth_user, params[:node], 'status?redirected=1', false, params.select { |k,_| [:version, :operations].include?(k) } ) end if not allowed_for_local_cluster(auth_user, Permissions::READ) return 403, 'Permission denied' end cib_dom = get_cib_dom(auth_user) crm_dom = get_crm_mon_dom(auth_user) status = get_node_status(auth_user, cib_dom) resources = get_resources( cib_dom, crm_dom, (params[:operations] and params[:operations] == '1') ) node = ClusterEntity::Node.load_current_node(crm_dom) _,_,not_authorized_nodes = check_gui_status_of_nodes( auth_user, status[:known_nodes], false, 3 ) if not_authorized_nodes.length > 0 node.warning_list << { :message => 'Not authorized against node(s) ' + not_authorized_nodes.join(', '), :type => 'nodes_not_authorized', :node_list => not_authorized_nodes, } end version = params[:version] || '1' if version == '2' status[:node] = node.to_status(version) resource_list = nil if resources resource_list = [] resources.each do |r| resource_list << r.to_status(version) end end status[:resource_list] = resource_list return JSON.generate(status) end resource_list = [] resources.each do |r| resource_list.concat(r.to_status('1')) end cluster_settings = (status[:cluster_settings].empty?) ? {'error' => 'Unable to get configuration settings'} : status[:cluster_settings] node_attr = {} status[:node_attr].each { |node, attrs| node_attr[node] = [] attrs.each { |attr| node_attr[node] << { :key => attr[:name], :value => attr[:value] } } } old_status = { :uptime => node.uptime, :corosync => node.corosync, :pacemaker => node.pacemaker, :cman => node.cman, :corosync_enabled => node.corosync_enabled, :pacemaker_enabled => node.pacemaker_enabled, :pcsd_enabled => node.pcsd_enabled, :corosync_online => status[:corosync_online], :corosync_offline => status[:corosync_offline], :pacemaker_online => status[:pacemaker_online], :pacemaker_offline => status[:pacemaker_offline], :pacemaker_standby => status[:pacemaker_standby], :cluster_name => status[:cluster_name], :resources => resource_list, :groups => status[:groups], :constraints => status[:constraints], :cluster_settings => cluster_settings, :node_id => node.id, :node_attr => node_attr, :fence_levels => status[:fence_levels], :need_ring1_address => status[:need_ring1_address], :is_cman_with_udpu_transport => status[:is_cman_with_udpu_transport], :acls => status[:acls], :username => status[:username] } return JSON.generate(old_status) end"
1786,"it ""queries the master node"" do session.should_receive(:socket_for).with(:write). and_return(socket) session.query(query) end",True,Ruby,"""queries the master node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_cleanup(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""cleanup"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end"
1787,"it ""queries the master node"" do session.should_receive(:socket_for).with(:write). and_return(socket) session.query(query) end",True,Ruby,"""queries the master node""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def add_acl_role_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end retval = add_acl_role(auth_user, params[""name""], params[""description""]) if retval == """" return [200, ""Successfully added ACL role""] else return [ 400, retval.include?(""cib_replace failed"") ? ""Error adding ACL role"" : retval ] end end"
1788,"it ""returns the database from the options"" do session.current_database.should eq(database) end",True,Ruby,"""returns the database from the options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def set_corosync_conf(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::FULL) return 403, 'Permission denied' end if params[:corosync_conf] != nil and params[:corosync_conf].strip != """" Cfgsync::CorosyncConf.backup() Cfgsync::CorosyncConf.from_text(params[:corosync_conf]).save() return 200, ""Succeeded"" else $logger.info ""Invalid corosync.conf file"" return 400, ""Failed"" end end"
1789,"it ""returns the database from the options"" do session.current_database.should eq(database) end",True,Ruby,"""returns the database from the options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def set_permissions_remote(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::GRANT) return 403, 'Permission denied' end begin data = JSON.parse(params['json_data']) rescue JSON::ParserError return 400, JSON.generate({'status' => 'bad_json'}) end user_set = {} perm_list = [] full_users_new = Set.new perm_deps = Permissions.permissions_dependencies if data['permissions'] data['permissions'].each { |key, perm| name = (perm['name'] || '').strip type = (perm['type'] || '').strip return [400, 'Missing user name'] if '' == name return [400, 'Missing user type'] if '' == type if not Permissions::is_user_type(type) return [400, ""Unknown user type '#{type}'""] end if user_set.key?([name, type]) return [400, ""Duplicate permissions for #{type} #{name}""] end user_set[[name, type]] = true allow = [] if perm['allow'] perm['allow'].each { |perm_allow, enabled| next if ""1"" != enabled if not Permissions::is_permission_type(perm_allow) return [400, ""Unknown permission '#{perm_allow}'""] end if Permissions::FULL == perm_allow full_users_new << [type, name] end allow << perm_allow # Explicitly save dependant permissions. That way if the dependency is # changed in the future it won't revoke permissions which were once # granted. if perm_deps['also_allows'] and perm_deps['also_allows'][perm_allow] allow += perm_deps['also_allows'][perm_allow] end } end perm_list << Permissions::EntityPermissions.new(type, name, allow.uniq()) } end perm_set = Permissions::PermissionsSet.new(perm_list) full_users_old = Set.new pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.permissions_local.entity_permissions_list.each{ |entity_perm| if entity_perm.allow_list.include?(Permissions::FULL) full_users_old << [entity_perm.type, entity_perm.name] end } if full_users_new != full_users_old label = 'Full' Permissions.get_permission_types.each { |perm_type| if Permissions::FULL == perm_type['code'] label = perm_type['label'] break end } if not allowed_for_local_cluster(auth_user, Permissions::FULL) return [ 403, ""Permission denied\nOnly #{SUPERUSER} and users with #{label} ""\ + ""permission can grant or revoke #{label} permission."" ] end end 2.times { pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.permissions_local = perm_set sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) pushed, _ = Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return [200, 'Permissions saved'] if pushed } return 400, 'Unable to save permissions' end"
1790,"it ""memoizes the database"" do database = session.current_database session.current_database.should equal(database) end",True,Ruby,"""memoizes the database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def resource_stop(params, request, auth_user) if not allowed_for_local_cluster(auth_user, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""disable"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end"
1791,"it ""memoizes the database"" do database = session.current_database session.current_database.should equal(database) end",True,Ruby,"""memoizes the database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def create_cluster(params, request, auth_user) if not allowed_for_superuser(auth_user) return 403, 'Permission denied' end if set_corosync_conf(params, request, auth_user) cluster_start(params, request, auth_user) else return ""Failed"" end end"
1792,"it ""raises an OperationFailure exception"" do session.stub(socket_for: socket) socket.stub(execute: reply) expect { session.execute(operation) }.to raise_exception(Moped::Errors::OperationFailure) end",True,Ruby,"""raises an OperationFailure exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def getResourcesGroups(auth_user, get_fence_devices = false, get_all_options = false, get_operations=false ) stdout, stderror, retval = run_cmd( auth_user, CRM_MON, ""--one-shot"", ""-r"", ""--as-xml"" ) if retval != 0 return [],[], retval end crm_output = stdout doc = REXML::Document.new(crm_output.join(""\n"")) resource_list = [] group_list = [] doc.elements.each('crm_mon/resources/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e)) else !get_fence_devices && resource_list.push(Resource.new(e)) end end doc.elements.each('crm_mon/resources/group/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e,e.parent.attributes[""id""])) else !get_fence_devices && resource_list.push(Resource.new(e,e.parent.attributes[""id""])) end end doc.elements.each('crm_mon/resources/clone/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e)) else ms = false if e.parent.attributes[""multi_state""] == ""true"" ms = true end !get_fence_devices && resource_list.push(Resource.new(e, nil, !ms, ms)) end end doc.elements.each('crm_mon/resources/clone/group/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e,e.parent.parent.attributes[""id""] + ""/"" + e.parent.attributes[""id""])) else ms = false if e.parent.parent.attributes[""multi_state""] == ""true"" ms = true end !get_fence_devices && resource_list.push(Resource.new(e,e.parent.parent.attributes[""id""] + ""/"" + e.parent.attributes[""id""],!ms, ms)) end end doc.elements.each('crm_mon/resources/group') do |e| group_list.push(e.attributes[""id""]) end resource_list = resource_list.select { |x| not x.orphaned } resource_list = resource_list.sort_by{|a| (a.group ? ""1"" : ""0"").to_s + a.group.to_s + ""-"" + a.id} if get_all_options or get_operations stdout, stderror, retval = run_cmd(auth_user, ""cibadmin"", ""-Q"", ""-l"") cib_output = stdout resources_inst_attr_map = {} resources_meta_attr_map = {} resources_operation_map = {} begin doc = REXML::Document.new(cib_output.join(""\n"")) if get_all_options doc.elements.each('//primitive') do |r| resources_inst_attr_map[r.attributes[""id""]] = {} resources_meta_attr_map[r.attributes[""id""]] = {} r.each_recursive do |ia| if ia.node_type == :element and ia.name == ""nvpair"" if ia.parent.name == ""instance_attributes"" resources_inst_attr_map[r.attributes[""id""]][ia.attributes[""name""]] = ia.attributes[""value""] elsif ia.parent.name == ""meta_attributes"" resources_meta_attr_map[r.attributes[""id""]][ia.attributes[""name""]] = [ia.attributes[""id""],ia.attributes[""value""],ia.parent.parent.attributes[""id""]] end end if [""group"",""clone"",""master""].include?(r.parent.name) r.parent.elements.each('./meta_attributes/nvpair') do |ma| resources_meta_attr_map[r.attributes[""id""]][ma.attributes[""name""]] ||= [] resources_meta_attr_map[r.attributes[""id""]][ma.attributes[""name""]] = [ma.attributes[""id""],ma.attributes[""value""],ma.parent.parent.attributes[""id""]] end end end end resource_list.each {|r| r.options = resources_inst_attr_map[r.id] r.instance_attr = resources_inst_attr_map[r.id] r.meta_attr = resources_meta_attr_map[r.id] } end if get_operations doc.elements.each('//lrm_rsc_op') { |rsc_op| resources_operation_map[rsc_op.parent.attributes['id']] ||= [] resources_operation_map[rsc_op.parent.attributes['id']] << ( ResourceOperation.new(rsc_op) ) } resource_list.each {|r| if resources_operation_map[r.id] r.operations = resources_operation_map[r.id].sort { |a, b| a.call_id <=> b.call_id } end } end rescue REXML::ParseException $logger.info(""ERROR: Parse Exception parsing cibadmin -Q"") end end [resource_list, group_list, 0] end"
1793,"it ""raises an OperationFailure exception"" do session.stub(socket_for: socket) socket.stub(execute: reply) expect { session.execute(operation) }.to raise_exception(Moped::Errors::OperationFailure) end",True,Ruby,"""raises an OperationFailure exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def getResourceMetadata(auth_user, resourcepath) options_required = {} options_optional = {} long_desc = """" short_desc = """" resourcepath = Pathname.new(resourcepath).cleanpath.to_s resource_dirs = [ HEARTBEAT_AGENTS_DIR, PACEMAKER_AGENTS_DIR, NAGIOS_METADATA_DIR, ] if not resource_dirs.any? { |allowed| resourcepath.start_with?(allowed) } $logger.error( ""Unable to get metadata of resource agent '#{resourcepath}': "" + 'path not allowed' ) return [options_required, options_optional, [short_desc, long_desc]] end if resourcepath.end_with?('.xml') begin metadata = IO.read(resourcepath) rescue metadata = """" end else ENV['OCF_ROOT'] = OCF_ROOT stdout, stderr, retval = run_cmd(auth_user, resourcepath, 'meta-data') metadata = stdout.join end begin doc = REXML::Document.new(metadata) rescue REXML::ParseException => e $logger.error( ""Unable to parse metadata of resource agent '#{resourcepath}': #{e}"" ) return [options_required, options_optional, [short_desc, long_desc]] end doc.elements.each('resource-agent/longdesc') {|ld| long_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/shortdesc') {|ld| short_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/parameters/parameter') { |param| temp_array = [] if param.attributes[""required""] == ""1"" if param.elements[""shortdesc""] and param.elements[""shortdesc""].text temp_array << param.elements[""shortdesc""].text.strip else temp_array << """" end if param.elements[""longdesc""] and param.elements[""longdesc""].text temp_array << param.elements[""longdesc""].text.strip else temp_array << """" end options_required[param.attributes[""name""]] = temp_array else if param.elements[""shortdesc""] and param.elements[""shortdesc""].text temp_array << param.elements[""shortdesc""].text.strip else temp_array << """" end if param.elements[""longdesc""] and param.elements[""longdesc""].text temp_array << param.elements[""longdesc""].text.strip else temp_array << """" end options_optional[param.attributes[""name""]] = temp_array end } [options_required, options_optional, [short_desc, long_desc]] end"
1794,"it ""sets the :database option"" do session.use :admin session.options[:database].should eq(:admin) end",True,Ruby,"""sets the :database option""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def getResourceAgents(auth_user) resource_agent_list = {} stdout, stderr, retval = run_cmd( auth_user, PCS, ""resource"", ""list"", ""--nodesc"" ) if retval != 0 $logger.error(""Error running 'pcs resource list --nodesc"") $logger.error(stdout + stderr) return {} end agents = stdout agents.each { |a| ra = ResourceAgent.new ra.name = a.chomp resource_agent_list[ra.name] = ra } return resource_agent_list end"
1795,"it ""sets the :database option"" do session.use :admin session.options[:database].should eq(:admin) end",True,Ruby,"""sets the :database option""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def testLoginByToken users = [] users << {""username"" => ""user1"", ""token"" => ""token1""} users << {""username"" => ""user2"", ""token"" => ""token2""} users << {""username"" => SUPERUSER, ""token"" => ""tokenS""} password_file = File.open($user_pass_file, File::RDWR|File::CREAT) password_file.truncate(0) password_file.rewind password_file.write(JSON.pretty_generate(users)) password_file.close() cookies = {} result = PCSAuth.loginByToken(cookies) assert_equal(nil, result) cookies = {'token' => 'tokenX'} result = PCSAuth.loginByToken(cookies) assert_equal(nil, result) cookies = {'token' => 'token1'} result = PCSAuth.loginByToken(cookies) assert_equal( {:username => 'user1', :usergroups => ['group1', 'haclient']}, result ) cookies = { 'token' => 'token1', 'CIB_user' => 'userX', 'CIB_user_groups' => PCSAuth.cookieUserEncode('groupX') } result = PCSAuth.loginByToken(cookies) assert_equal( {:username => 'user1', :usergroups => ['group1', 'haclient']}, result ) cookies = {'token' => 'tokenS'} result = PCSAuth.loginByToken(cookies) assert_equal( {:username => SUPERUSER, :usergroups => []}, result ) cookies = { 'token' => 'tokenS', 'CIB_user' => 'userX', 'CIB_user_groups' => PCSAuth.cookieUserEncode('groupX') } result = PCSAuth.loginByToken(cookies) assert_equal( {:username => 'userX', :usergroups => ['groupX']}, result ) end"
1796,"it ""returns the new session"" do session.stub(with: new_session) session.new(new_options).should eql new_session end",True,Ruby,"""returns the new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def protected! gui_request = ( # these are URLs for web pages request.path == '/' or request.path == '/manage' or request.path == '/permissions' or request.path.match('/managec/.+/main') ) if request.path.start_with?('/remote/') or request.path == '/run_pcs' @auth_user = PCSAuth.loginByToken(cookies) unless @auth_user halt [401, '{""notauthorized"":""true""}'] end else #/managec/* /manage/* /permissions if !gui_request and !is_ajax? then # Accept non GUI requests only with header # ""X_REQUESTED_WITH: XMLHttpRequest"". (check if they are send via AJAX). # This prevents CSRF attack. halt [401, '{""notauthorized"":""true""}'] elsif not PCSAuth.isLoggedIn(session) if gui_request session[:pre_login_path] = request.path redirect '/login' else halt [401, '{""notauthorized"":""true""}'] end end end end"
1797,"it ""returns the new session"" do session.stub(with: new_session) session.new(new_options).should eql new_session end",True,Ruby,"""returns the new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def self.file_info(path) info = { body: ::File.read(path), time: ::File.mtime(path).httpdate } info end"
1798,"it ""does not change the original session's options"" do original_options = options.dup session.with(new_options) do |new_session| session.options.should eql original_options end end",True,Ruby,"""does not change the original session's options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def file_path @root = File.join Jekbox::DROPBOX_PATH, @request.host path = File.expand_path File.join @root, '_site', @request.path_info with_index = File.join path, 'index.html' if File.file? path path elsif File.file? with_index with_index end end"
1799,"it ""does not change the original session's options"" do original_options = options.dup session.with(new_options) do |new_session| session.options.should eql original_options end end",True,Ruby,"""does not change the original session's options""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def build_response @file = file_path if @file build_file_response else build_404 end build_head if @request.head? end
1800,"it ""raises a QueryFailure exception"" do expect { session.query(query) }.to raise_exception(Moped::Errors::QueryFailure) end",True,Ruby,"""raises a QueryFailure exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it 'should find a normal file' do get 'http://jekbox.example.com/assets/foo.css' expect(last_response.body).to eq ""body {}\n"" end"
1801,"it ""raises a QueryFailure exception"" do expect { session.query(query) }.to raise_exception(Moped::Errors::QueryFailure) end",True,Ruby,"""raises a QueryFailure exception""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end"
1802,"it ""returns false"" do session.should_not be_safe end",True,Ruby,"""returns false""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end"
1803,"it ""returns false"" do session.should_not be_safe end",True,Ruby,"""returns false""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end"
1804,"it ""only aquires the socket once"" do session.cluster.should_receive(:socket_for). with(:read).once.and_return(mock(Moped::Socket)) session.send(:socket_for, :read) session.send(:socket_for, :read) end",True,Ruby,"""only aquires the socket once""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end"
1805,"it ""only aquires the socket once"" do session.cluster.should_receive(:socket_for). with(:read).once.and_return(mock(Moped::Socket)) session.send(:socket_for, :read) session.send(:socket_for, :read) end",True,Ruby,"""only aquires the socket once""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end"
1806,"it ""yields a session"" do session.with(new_options) do |new_session| new_session.should be_a Moped::Session end end",True,Ruby,"""yields a session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end"
1807,"it ""yields a session"" do session.with(new_options) do |new_session| new_session.should be_a Moped::Session end end",True,Ruby,"""yields a session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end"
1808,"it ""returns a session"" do session.with(new_options).should be_a Moped::Session end",True,Ruby,"""returns a session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end"
1809,"it ""returns a session"" do session.with(new_options).should be_a Moped::Session end",True,Ruby,"""returns a session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def instantiate variant, mac=nil # Filenames must end in a hex representation of a mac address but only if mac is not empty log_halt 403, ""Invalid MAC address: #{mac}"" unless valid_mac?(mac) || mac.nil? log_halt 403, ""Unrecognized pxeboot config type: #{variant}"" unless VARIANTS.include?(variant.capitalize) Object.const_get(""Proxy"").const_get('TFTP').const_get(variant.capitalize).new end"
1810,"it ""delegates to #with"" do session.should_receive(:with).with(new_options).and_return(new_session) session.new(new_options) end",True,Ruby,"""delegates to #with""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def write!(headers) tokens_changed = false if MiniProfiler.request_authorized? && MiniProfiler.config.authorization_mode == :whitelist @allowed_tokens ||= @store.allowed_tokens tokens_changed = !@orig_auth_tokens || ((@allowed_tokens - @orig_auth_tokens).length > 0) end if @orig_disable_profiling != @disable_profiling || @orig_backtrace_level != @backtrace_level || @cookie.nil? || tokens_changed settings = {""p"" => ""t"" } settings[""dp""] = ""t"" if @disable_profiling settings[""bt""] = @backtrace_level if @backtrace_level settings[""a""] = @allowed_tokens.join(""|"") if @allowed_tokens && MiniProfiler.request_authorized? settings_string = settings.map{|k,v| ""#{k}=#{v}""}.join("","") Rack::Utils.set_cookie_header!(headers, COOKIE_NAME, :value => settings_string, :path => '/') end end"
1811,"it ""delegates to #with"" do session.should_receive(:with).with(new_options).and_return(new_session) session.new(new_options) end",True,Ruby,"""delegates to #with""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def initialize(env, store, start) request = ::Rack::Request.new(env) @cookie = request.cookies[COOKIE_NAME] @store = store @start = start @allowed_tokens, @orig_auth_tokens = nil if @cookie @cookie.split("","").map{|pair| pair.split(""="")}.each do |k,v| @orig_disable_profiling = @disable_profiling = (v=='t') if k == ""dp"" @backtrace_level = v.to_i if k == ""bt"" @orig_auth_tokens = v.to_s.split(""|"") if k == ""a"" end end if !@backtrace_level.nil? && (@backtrace_level == 0 || @backtrace_level > BACKTRACE_NONE) @backtrace_level = nil end @orig_backtrace_level = @backtrace_level end"
1812,"it ""unmemoizes the current database"" do db = session.current_database session.with(new_options) do |new_session| new_session.current_database.should_not eql db end end",True,Ruby,"""unmemoizes the current database""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"def discard_cookie!(headers) if @cookie Rack::Utils.delete_cookie_header!(headers, COOKIE_NAME, :path => '/') end end"
1816,"it ""yields the new session"" do session.stub(with: new_session) session.new(new_options) do |session| session.should eql new_session end end",True,Ruby,"""yields the new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it ""should allow requests that are whitelisted"" do get '/whitelisted' # second time will ensure cookie is set # first time around there is no cookie, so no profiling get '/whitelisted' last_response.headers['X-MiniProfiler-Ids'].should_not be_nil end"
1817,"it ""yields the new session"" do session.stub(with: new_session) session.new(new_options) do |session| session.should eql new_session end end",True,Ruby,"""yields the new session""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"it ""re-enabled functionality if whitelisted"" do Rack::MiniProfiler.config.authorization_mode = :whitelist get '/whitelisted-html?pp=enable' get '/whitelisted-html?pp=enable' last_response.body.should include('/mini-profiler-resources/includes.js') end"
1818,"it ""delegates to the cluster"" do session.cluster.should_receive(:socket_for).with(:read) session.send(:socket_for, :read) end",True,Ruby,"""delegates to the cluster""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2015-4410,"it 'avoids xss attacks' do h = last_response.headers['X-MiniProfiler-Ids'] _id = ::JSON.parse(h)[0] get ""/mini-profiler-resources/results?id=%22%3E%3Cqss%3E"" last_response.should_not be_ok last_response.body.should_not =~ /<qss>/ last_response.body.should =~ /&lt;qss&gt;/ end"
1819,"it ""delegates to the cluster"" do session.cluster.should_receive(:socket_for).with(:read) session.send(:socket_for, :read) end",True,Ruby,"""delegates to the cluster""",session_spec.rb,https://github.com/mongoid/moped,mongoid,Bernerd Schaefer,2012-04-17 17:46:34+02:00,"Merge Replica Set Refactor

* Removes Server, and Socket; replaced with Node, and Connection.

  Replica sets are now much more robustly supported, including failover
  and discovery.

* Refactors specs.

  Internal APIs are now tested with integration specs through the public
  APIs.

* More documentation.",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,def initialize(*args) initialize_without_private_address_check(*args) if Thread.current[:private_address_check] && PrivateAddressCheck.resolves_to_private_address?(remote_address.ip_address) raise PrivateAddressCheck::PrivateConnectionAttemptedError end end
1904,def legal?(string) string.to_s =~ /^[0-9a-f]{24}$/i ? true : false end,True,Ruby,legal?,object_id.rb,https://github.com/mongodb/bson-ruby,mongodb,Durran Jordan,2015-06-04 00:19:42-04:00,Use \A \z for checking regex on legal,CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4411,"def test_private_address server = TCPServer.new(63453) thread = Thread.start { server.accept } assert_raises PrivateAddressCheck::PrivateConnectionAttemptedError do PrivateAddressCheck.only_public_connections do TCPSocket.new(""localhost"", 63453) end end ensure thread.exit if thread end"
1905,def legal?(string) string.to_s =~ /^[0-9a-f]{24}$/i ? true : false end,True,Ruby,legal?,object_id.rb,https://github.com/mongodb/bson-ruby,mongodb,Durran Jordan,2015-06-04 00:19:42-04:00,Use \A \z for checking regex on legal,CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2015-4412,"def find(uuid, options = {}) if uuid.nil? || uuid.to_s.empty? raise NotFound, ""can't find a record with nil identifier"" end begin from_response API.get(member_path(uuid), {}, options) rescue API::NotFound => e raise NotFound, e.description end end"
1934,"def order_by order_option = '' if self.order_column direction = self.order_direction || 'ASC' order_option = ""#{self.order_column} #{direction}"" end order_option.present? ? order_option : @@default_order end",True,Ruby,order_by,search_form.rb,https://github.com/NaCl-Ltd/pref-shimane-cms,NaCl-Ltd,Yusuke Anno,2015-10-07 13:31:38+09:00,検索フォームクラスごとにソート順を作成するよう修正,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2015-5659,def _extend_marshalling(options) extend Serialization unless @serializer.nil? end
1935,"def initialize(image_path, colors=16, depth=8) output = `convert #{image_path} -resize 400x400 -format %c -dither None -quantize YIQ -colors #{colors} -depth #{depth} histogram:info:-` @lines = output.lines.sort.reverse.map(&:strip).reject(&:empty?) end",True,Ruby,initialize,histogram.rb,https://github.com/quadule/colorscore,quadule,Milo Winningham,2016-01-06 02:03:00-05:00,"Fix CVE-2015-7541

Avoid passsing possible user input directly into the shell. Instead
quote the `image_path` value before calling the `convert` command.

See here http://rubysec.com/advisories/CVE-2015-7541/ for more
information.",CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),"The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/77.html,CVE-2015-7541,def self.normalize_key_names(options) options = options.dup if options.key?(:key_prefix) && !options.key?(:namespace) options[:namespace] = options.delete(:key_prefix) # RailsSessionStore end options[:raw] = case when options.key?(:serializer) options[:serializer].nil? when options.key?(:marshalling) !options[:marshalling] else false end
1941,"def test_should_sanitize_with_trailing_space raw = ""display:block; "" expected = ""display: block;"" assert_equal expected, sanitize_css(raw) end",True,Ruby,test_should_sanitize_with_trailing_space,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Rafael Mendonça França,2018-03-22 14:54:31-04:00,"Make sure we address CVE-2018-8048

Even that the issue was fixed on loofah we have our own logic to scrub
attributes so when the whitelist serializer is used the issue was still
present.

Fix CVE-2018-3741.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3741,"def mget(*keys) options = (keys.pop if keys.last.is_a? Hash) || {} if keys.any? # Serialization gets extended before Namespace does, so we need to pass options further if singleton_class.ancestors.include? Serialization super(*keys.map {|key| interpolate(key) }, options) else super(*keys.map {|key| interpolate(key) }) end end end"
1942,"def test_should_sanitize_illegal_style_properties raw = %(display:block; position:absolute; left:0; top:0; width:100%; height:100%; z-index:1; background-color:black; background-image:url(http://www.ragingplatypus.com/i/cam-full.jpg); background-x:center; background-y:center; background-repeat:repeat;) expected = %(display: block; width: 100%; height: 100%; background-color: black; background-x: center; background-y: center;) assert_equal expected, sanitize_css(raw) end",True,Ruby,test_should_sanitize_illegal_style_properties,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Rafael Mendonça França,2018-03-22 14:54:31-04:00,"Make sure we address CVE-2018-8048

Even that the issue was fixed on loofah we have our own logic to scrub
attributes so when the whitelist serializer is used the issue was still
present.

Fix CVE-2018-3741.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3741,"def _unmarshal(val, options) unmarshal?(val, options) ? @serializer.load(val) : val end"
1950,"def test_sanitize_script assert_sanitized ""a b c<script language=\""Javascript\"">blah blah blah</script>d e f"", ""a b cd e f"" end",True,Ruby,test_sanitize_script,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:07:39-08:00,"Define a less permissive list of tags and attributes

And use it by default.

The new sanitizer were being a lot more permissive that we had in Rails
until the version 4.2.

This was also allowing arbritary data attributes by default what can
lead to CSRF and XSS attacks.

Now data attributes need to be explicitly allowed.

CVE-2015-7578",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7578,"def _marshal(val, options) yield marshal?(options) ? @serializer.dump(val) : val end"
1951,def scope_allowed_attributes(attributes) Rails::Html::WhiteListSanitizer.allowed_attributes = attributes yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_attributes = nil end,True,Ruby,scope_allowed_attributes,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:07:39-08:00,"Define a less permissive list of tags and attributes

And use it by default.

The new sanitizer were being a lot more permissive that we had in Rails
until the version 4.2.

This was also allowing arbritary data attributes by default what can
lead to CSRF and XSS attacks.

Now data attributes need to be explicitly allowed.

CVE-2015-7578",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7578,"def setup @namespace = ""theplaylist"" @store = Redis::Store.new :namespace => @namespace, :serializer => nil @client = @store.instance_variable_get(:@client) @rabbit = ""bunny"" @default_store = Redis::Store.new @other_namespace = 'other' @other_store = Redis::Store.new :namespace => @other_namespace end"
1953,"def test_should_sanitize_img_dynsrc_lowsrc assert_sanitized(%(<img lowsrc=""javascript:alert('XSS')"" />), ""<img />"") end def test_should_sanitize_div_background_image_unicode_encoded raw = %(background-image:\0075\0072\006C\0028'\006a\0061\0076\0061\0073\0063\0072\0069\0070\0074\003a\0061\006c\0065\0072\0074\0028.1027\0058.1053\0053\0027\0029'\0029) assert_equal '', sanitize_css(raw) end def test_should_sanitize_div_style_expression raw = %(width: expression(alert('XSS'));) assert_equal '', sanitize_css(raw) end def test_should_sanitize_across_newlines raw = %(\nwidth:\nexpression(alert('XSS'));\n) assert_equal '', sanitize_css(raw) end def test_should_sanitize_img_vbscript assert_sanitized %(<img src='vbscript:msgbox(""XSS"")' />), '<img />' end def test_should_sanitize_cdata_section assert_sanitized ""<![CDATA[<span>section</span>]]>"", ""section]]&gt;"" end def test_should_sanitize_unterminated_cdata_section assert_sanitized ""<![CDATA[<span>neverending..."", ""neverending..."" end def test_should_not_mangle_urls_with_ampersand assert_sanitized %{<a href=\""http://www.domain.com?var1=1&amp;var2=2\"">my link</a>} end def test_should_sanitize_neverending_attribute assert_sanitized ""<span class=\""\\"", ""<span class=\""\\\"">"" end [ %(<a href=""javascript&#x3a;alert('XSS');"">), %(<a href=""javascript&#x003a;alert('XSS');"">), %(<a href=""javascript&#x3A;alert('XSS');"">), %(<a href=""javascript&#x003A;alert('XSS');"">) ].each_with_index do |enc_hack, i| define_method ""test_x03a_handling_#{i+1}"" do assert_sanitized enc_hack, ""<a>"" end end def test_x03a_legitimate assert_sanitized %(<a href=""http&#x3a;//legit"">), %(<a href=""http://legit"">) assert_sanitized %(<a href=""http&#x3A;//legit"">), %(<a href=""http://legit"">) end def test_sanitize_ascii_8bit_string white_list_sanitize('<a>hello</a>'.encode('ASCII-8BIT')).tap do |sanitized| assert_equal '<a>hello</a>', sanitized assert_equal Encoding::UTF_8, sanitized.encoding end end protected def xpath_sanitize(input, options = {}) XpathRemovalTestSanitizer.new.sanitize(input, options) end def full_sanitize(input, options = {}) Rails::Html::FullSanitizer.new.sanitize(input, options) end def link_sanitize(input, options = {}) Rails::Html::LinkSanitizer.new.sanitize(input, options) end def white_list_sanitize(input, options = {}) Rails::Html::WhiteListSanitizer.new.sanitize(input, options) end def assert_sanitized(input, expected = nil) if input assert_dom_equal expected || input, white_list_sanitize(input) else assert_nil white_list_sanitize(input) end end def sanitize_css(input) Rails::Html::WhiteListSanitizer.new.sanitize_css(input) end def scope_allowed_tags(tags) Rails::Html::WhiteListSanitizer.allowed_tags = tags yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_tags = nil end def scope_allowed_attributes(attributes) Rails::Html::WhiteListSanitizer.allowed_attributes = attributes yield Rails::Html::WhiteListSanitizer.new ensure Rails::Html::WhiteListSanitizer.allowed_attributes = nil end end",True,Ruby,test_should_sanitize_img_dynsrc_lowsrc,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:07:39-08:00,"Define a less permissive list of tags and attributes

And use it by default.

The new sanitizer were being a lot more permissive that we had in Rails
until the version 4.2.

This was also allowing arbritary data attributes by default what can
lead to CSRF and XSS attacks.

Now data attributes need to be explicitly allowed.

CVE-2015-7578",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7578,"def setup @store = Redis::Store.new serializer: Marshal @rabbit = OpenStruct.new :name => ""bunny"" @white_rabbit = OpenStruct.new :color => ""white"" @store.set ""rabbit"", @rabbit @store.del ""rabbit2"" end"
1961,"def test_should_allow_anchors assert_sanitized %(<a href=""foo"" onclick=""bar""><script>baz</script></a>), %(<a href=\""foo\""></a>) end def test_video_poster_sanitization assert_sanitized %(<video src=""videofile.ogg"" autoplay poster=""posterimage.jpg""></video>), %(<video src=""videofile.ogg"" poster=""posterimage.jpg""></video>) assert_sanitized %(<video src=""videofile.ogg"" poster=javascript:alert(1)></video>), %(<video src=""videofile.ogg""></video>) end # RFC 3986, sec 4.2 def test_allow_colons_in_path_component assert_sanitized ""<a href=\""./this:that\"">foo</a>"" end",True,Ruby,test_should_allow_anchors,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:07:39-08:00,"Define a less permissive list of tags and attributes

And use it by default.

The new sanitizer were being a lot more permissive that we had in Rails
until the version 4.2.

This was also allowing arbritary data attributes by default what can
lead to CSRF and XSS attacks.

Now data attributes need to be explicitly allowed.

CVE-2015-7578",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7578,"def test_attr_wrapper assert_equal(""<p strange=*attrs*></p>\n"", render(""%p{ :strange => 'attrs'}"", :attr_wrapper => '*')) assert_equal(""<p escaped='quo\""te'></p>\n"", render(""%p{ :escaped => 'quo\""te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""quo&#039;te\""></p>\n"", render(""%p{ :escaped => 'quo\\'te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped='q&#039;uo\""te'></p>\n"", render(""%p{ :escaped => 'q\\'uo\""te'}"", :attr_wrapper => '""')) assert_equal(""<?xml version=\""1.0\"" encoding=\""utf-8\"" ?>\n"", render(""!!! XML"", :attr_wrapper => '""', :format => :xhtml)) end"
1970,"def test_full_sanitize_allows_turning_off_encoding_special_chars assert_equal '&amp;', full_sanitize('&') assert_equal '&', full_sanitize('&', encode_special_chars: false) end",True,Ruby,test_full_sanitize_allows_turning_off_encoding_special_chars,sanitizer_test.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:07:57-08:00,"Do not unescape already escaped HTML entities

The full sanitizer was using Loofah's #text method that automatically
escapes HTML entities. That behavior caused some problems where strings
that were not escaped in the older sanitizer started to be escaped. To
fix these problems we used the #text's `encode_special_chars` option as
`false` that not just skipped the HTML entities escaping but unescaped
already escaped entities.

This introduced a security bug because an attacker can pass escaped HTML
tags that will not be sanitized and will be returned as unescaped HTML
tags.

To fix it properly we introduced a new scrubber that will remove all
tags and keep just the text nodes of these tags without changing how
to escape the string.

CVE-2015-7579",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7579,"def test_html5_data_attributes_without_hyphenation assert_equal(""<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\n"", render(""%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-one_plus_one='2'></div>\n"", render(""%div{:data => {:one_plus_one => 1+1}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-foo='Here&#039;s a \""quoteful\"" string.'></div>\n"", render(%{%div{:data => {:foo => %{Here's a ""quoteful"" string.}}}},"
1974,def skip_node?(node) node.text? || node.cdata? end,True,Ruby,skip_node?,scrubbers.rb,https://github.com/rails/rails-html-sanitizer,rails,Aaron Patterson,2016-01-22 15:08:16-08:00,"convert CDATA nodes to TEXT nodes to avoid XSS issues

CDATA nodes will not be html escaped.  Users shouldn't be submitting
CDATA nodes in the first place, so we should convert them to text nodes
before escaping

CVE-2015-7580",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2015-7580,"def test_new_attribute_interpolation assert_equal(""<a href='12'>bar</a>\n"", render('%a(href=""1#{1 + 1}"") bar')) assert_equal(""<a href='2: 2, 3: 3'>bar</a>\n"", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3})) assert_equal(%Q{<a href='1\#{1 + 1}'>bar</a>\n}, render('%a(href=""1\#{1 + 1}"") bar')) end def test_truthy_new_attributes assert_equal(""<a href='href'>bar</a>\n"", render(""%a(href) bar"", :format => :xhtml)) assert_equal(""<a bar='baz' href>bar</a>\n"", render(""%a(href bar='baz') bar"", :format => :html5)) assert_equal(""<a href>bar</a>\n"", render(""%a(href=true) bar"")) assert_equal(""<a>bar</a>\n"", render(""%a(href=false) bar"")) end def test_new_attribute_parsing assert_equal(""<a a2='b2'>bar</a>\n"", render(""%a(a2=b2) bar"", :locals => {:b2 => 'b2'})) assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a=""#{'foo""bar'}"") bar})) #' assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a=""#{""foo'bar""}"") bar})) #' assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a='foo""bar') bar})) assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a=""foo'bar"") bar})) assert_equal(""<a a:b='foo'>bar</a>\n"", render(""%a(a:b='foo') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = 'foo' b = 'bar') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = foo b = bar) bar"", :locals => {:foo => 'foo', :bar => 'bar'})) assert_equal(""<a a='foo'>(b='bar')</a>\n"", render(""%a(a='foo')(b='bar')"")) assert_equal(""<a a='foo)bar'>baz</a>\n"", render(""%a(a='foo)bar') baz"")) assert_equal(""<a a='foo'>baz</a>\n"", render(""%a( a = 'foo' ) baz"")) end def test_new_attribute_escaping assert_equal(%Q{<a a='foo "" bar'>bar</a>\n}, render(%q{%a(a=""foo \"" bar"") bar}))"
1982,"def self.loginByToken(session, cookies) if username = validToken(cookies[""token""]) if SUPERUSER == username if cookies['CIB_user'] and cookies['CIB_user'].strip != '' session[:username] = cookies['CIB_user'] if cookies['CIB_user_groups'] and cookies['CIB_user_groups'].strip != '' session[:usergroups] = cookieUserDecode( cookies['CIB_user_groups'] ).split(nil) else session[:usergroups] = [] end else session[:username] = SUPERUSER session[:usergroups] = [] end return true else session[:username] = username success, groups = getUsersGroups(username) session[:usergroups] = success ? groups : [] return true end end return false end",True,Ruby,self.loginByToken,auth.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def test_new_attribute_interpolation assert_equal(""<a href='12'>bar</a>\n"", render('%a(href=""1#{1 + 1}"") bar')) assert_equal(""<a href='2: 2, 3: 3'>bar</a>\n"", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3})) assert_equal(%Q{<a href='1\#{1 + 1}'>bar</a>\n}, render('%a(href=""1\#{1 + 1}"") bar')) end def test_truthy_new_attributes assert_equal(""<a href='href'>bar</a>\n"", render(""%a(href) bar"", :format => :xhtml)) assert_equal(""<a bar='baz' href>bar</a>\n"", render(""%a(href bar='baz') bar"", :format => :html5)) assert_equal(""<a href>bar</a>\n"", render(""%a(href=true) bar"")) assert_equal(""<a>bar</a>\n"", render(""%a(href=false) bar"")) end def test_new_attribute_parsing assert_equal(""<a a2='b2'>bar</a>\n"", render(""%a(a2=b2) bar"", :locals => {:b2 => 'b2'})) assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a=""#{'foo""bar'}"") bar})) #' assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a=""#{""foo'bar""}"") bar})) #' assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a='foo""bar') bar})) assert_equal(%Q{<a a='foo&#039;bar'>bar</a>\n}, render(%q{%a(a=""foo'bar"") bar})) assert_equal(""<a a:b='foo'>bar</a>\n"", render(""%a(a:b='foo') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = 'foo' b = 'bar') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = foo b = bar) bar"", :locals => {:foo => 'foo', :bar => 'bar'})) assert_equal(""<a a='foo'>(b='bar')</a>\n"", render(""%a(a='foo')(b='bar')"")) assert_equal(""<a a='foo)bar'>baz</a>\n"", render(""%a(a='foo)bar') baz"")) assert_equal(""<a a='foo'>baz</a>\n"", render(""%a( a = 'foo' ) baz"")) end def test_new_attribute_escaping assert_equal(%Q{<a a='foo "" bar'>bar</a>\n}, render(%q{%a(a=""foo \"" bar"") bar}))"
1986,"def self.getSuperuserSession() return { :username => SUPERUSER, :usergroups => [], } end",True,Ruby,self.getSuperuserSession,auth.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def test_html5_data_attributes_without_hyphenation assert_equal(""<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\n"", render(""%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-one_plus_one='2'></div>\n"", render(""%div{:data => {:one_plus_one => 1+1}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-foo='Here&#039;s a \""quoteful\"" string.'></div>\n"", render(%{%div{:data => {:foo => %{Here's a ""quoteful"" string.}}}},"
1987,"def self.getUsersGroups(username) stdout, stderr, retval = run_cmd( getSuperuserSession, ""id"", ""-Gn"", username ) if retval != 0 $logger.info( ""Unable to determine groups of user '#{username}': #{stderr.join(' ').strip}"" ) return [false, []] end return [true, stdout.join(' ').split(nil)] end",True,Ruby,self.getUsersGroups,auth.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def test_attr_wrapper assert_equal(""<p strange=*attrs*></p>\n"", render(""%p{ :strange => 'attrs'}"", :attr_wrapper => '*')) assert_equal(""<p escaped='quo\""te'></p>\n"", render(""%p{ :escaped => 'quo\""te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""quo&#039;te\""></p>\n"", render(""%p{ :escaped => 'quo\\'te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped='q&#039;uo\""te'></p>\n"", render(""%p{ :escaped => 'q\\'uo\""te'}"", :attr_wrapper => '""')) assert_equal(""<?xml version=\""1.0\"" encoding=\""utf-8\"" ?>\n"", render(""!!! XML"", :attr_wrapper => '""', :format => :xhtml)) end"
1994,"def send(force=false) nodes_txt = @nodes.join(', ') @configs.each { |cfg| $logger.info( ""Sending config '#{cfg.class.name}' version #{cfg.version} #{cfg.hash}""\ + "" to nodes: #{nodes_txt}"" ) } data = self.prepare_request_data(@configs, @cluster_name, force) node_response = {} threads = [] @nodes.each { |node| threads << Thread.new { code, out = send_request_with_token( @session, node, 'set_configs', true, data, true, nil, 30, @additional_tokens ) if 200 == code begin node_response[node] = JSON.parse(out) rescue JSON::ParserError end elsif 404 == code node_response[node] = {'status' => 'not_supported'} else begin response = JSON.parse(out) if true == response['notauthorized'] or true == response['notoken'] node_response[node] = {'status' => 'notauthorized'} end rescue JSON::ParserError end end if not node_response.key?(node) node_response[node] = {'status' => 'error'} end # old pcsd returns this instead of 404 if pacemaker isn't running there if node_response[node]['pacemaker_not_running'] node_response[node] = {'status' => 'not_supported'} end } } threads.each { |t| t.join } node_response.each { |node, response| $logger.info(""Sending config response from #{node}: #{response}"") } return node_response end",True,Ruby,send,cfgsync.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def origins(*args, &blk) @origins = args.flatten.collect do |n| case n when Regexp, /^https?:\/\//, 'file://' then n when '*' then @public_resources = true; n else Regexp.compile(""^[a-z][a-z0-9.+-]*:\\\/\\\/#{Regexp.quote(n)}$"") end end.flatten"
1995,"def self.save_sync_new_tokens(config, new_tokens, nodes, cluster_name) with_new_tokens = PCSTokens.new(config.text) with_new_tokens.tokens.update(new_tokens) config_new = PcsdTokens.from_text(with_new_tokens.text) if not cluster_name or cluster_name.empty? # we run on a standalone host, no config syncing config_new.version += 1 config_new.save() return true, {} end # we run in a cluster so we need to sync the config publisher = ConfigPublisher.new( PCSAuth.getSuperuserSession(), [config_new], nodes, cluster_name, new_tokens ) old_configs, node_responses = publisher.publish() if not old_configs.include?(config_new.class.name) # no node had newer tokens file, we are ok, everything done return true, node_responses end # get tokens from all nodes and merge them fetcher = ConfigFetcher.new( PCSAuth.getSuperuserSession(), [config_new.class], nodes, cluster_name ) fetched_tokens = fetcher.fetch_all()[config_new.class.name] config_new = Cfgsync::merge_tokens_files(config, fetched_tokens, new_tokens) # and try to publish again return Cfgsync::save_sync_new_version( config_new, nodes, cluster_name, true, new_tokens ) end",True,Ruby,self.save_sync_new_tokens,cfgsync.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def match_resource(path, env) origin = env[HTTP_ORIGIN] origin_matched = false all_resources.each do |r| if r.allow_origin?(origin, env) origin_matched = true if found = r.match_resource(path, env) return [found, nil] end end end [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN] end"
2000,"def initialize(session, config_classes, nodes, cluster_name) @config_classes = config_classes @nodes = nodes @cluster_name = cluster_name @session = session end",True,Ruby,initialize,cfgsync.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def process_cors(env, path) resource, error = match_resource(path, env) if resource Result.hit(env) cors = resource.to_headers(env) cors else Result.miss(env, error) nil end end"
2002,"def get_configs_cluster(nodes, cluster_name) data = { 'cluster_name' => cluster_name, } $logger.debug 'Fetching configs from the cluster' threads = [] node_configs = {} nodes.each { |node| threads << Thread.new { code, out = send_request_with_token( @session, node, 'get_configs', false, data ) if 200 == code begin parsed = JSON::parse(out) if 'ok' == parsed['status'] and cluster_name == parsed['cluster_name'] node_configs[node], _ = Cfgsync::sync_msg_to_configs(parsed) end rescue JSON::ParserError end end } } threads.each { |t| t.join } return node_configs end",True,Ruby,get_configs_cluster,cfgsync.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def process_preflight(env, path) result = Result.preflight(env) resource, error = match_resource(path, env) unless resource result.miss(error) return {} end return resource.process_preflight(env, result) end"
2004,"def self.load_current_node(session, crm_dom=nil) node = ClusterEntity::Node.new node.corosync = corosync_running? node.corosync_enabled = corosync_enabled? node.pacemaker = pacemaker_running? node.pacemaker_enabled = pacemaker_enabled? node.cman = cman_running? node.pcsd_enabled = pcsd_enabled? node_online = (node.corosync and node.pacemaker) node.status = node_online ? 'online' : 'offline' node.uptime = get_node_uptime node.id = get_local_node_id if node_online and crm_dom node_el = crm_dom.elements[""//node[@id='#{node.id}']""] if node_el and node_el.attributes['standby'] == 'true' node.status = 'standby' else node.status = 'online' end node.quorum = !!crm_dom.elements['//current_dc[@with_quorum=""true""]'] else node.status = 'offline' end return node end",True,Ruby,self.load_current_node,cluster_entity.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def call(env) env[HTTP_ORIGIN] ||= env[HTTP_X_ORIGIN] if env[HTTP_X_ORIGIN] path = evaluate_path(env) add_headers = nil if env[HTTP_ORIGIN] debug(env) do [ 'Incoming Headers:', "" Origin: #{env[HTTP_ORIGIN]}"", "" Path-Info: #{path}"", "" Access-Control-Request-Method: #{env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]}"", "" Access-Control-Request-Headers: #{env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]}"" ].join(""\n"") end if env[REQUEST_METHOD] == OPTIONS and env[HTTP_ACCESS_CONTROL_REQUEST_METHOD] headers = process_preflight(env, path) debug(env) do ""Preflight Headers:\n"" + headers.collect{|kv| "" #{kv.join(': ')}""}.join(""\n"") end return [200, headers, []] else add_headers = process_cors(env, path) end else Result.miss(env, Result::MISS_NO_ORIGIN) end # This call must be done BEFORE calling the app because for some reason # env[PATH_INFO] gets changed after that and it won't match. (At least # in rails 4.1.6) vary_resource = resource_for_path(path) status, headers, body = @app.call env if add_headers headers = add_headers.merge(headers) debug(env) do add_headers.each_pair do |key, value| if headers.has_key?(key) headers[""X-Rack-CORS-Original-#{key}""] = value end end end end # Vary header should ALWAYS mention Origin if there's ANY chance for the # response to be different depending on the Origin header value. # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/ if vary_resource vary = headers[VARY] cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any? vary_resource.vary_headers else DEFAULT_VARY_HEADERS end headers[VARY] = ((vary ? ([vary].flatten.map { |v| v.split(/,\s*/) }.flatten) : []) + cors_vary_headers).uniq.join(', ') end"
2006,"def getFenceAgentMetadata(session, fenceagentname) options_required = {} options_optional = {} options_advanced = { ""priority"" => """", ""pcmk_host_argument"" => """", ""pcmk_host_map"" => """", ""pcmk_host_list"" => """", ""pcmk_host_check"" => """" } for a in [""reboot"", ""list"", ""status"", ""monitor"", ""off""] options_advanced[""pcmk_"" + a + ""_action""] = """" options_advanced[""pcmk_"" + a + ""_timeout""] = """" options_advanced[""pcmk_"" + a + ""_retries""] = """" end # There are bugs in stonith_admin & the new fence_agents interaction # eventually we'll want to switch back to this, but for now we directly # call the agent to get metadata #metadata = `stonith_admin --metadata -a #{fenceagentname}` if not fenceagentname.start_with?('fence_') or fenceagentname.include?('/') $logger.error ""Invalid fence agent '#{fenceagentname}'"" return [options_required, options_optional, options_advanced] end stdout, stderr, retval = run_cmd( session, ""/usr/sbin/#{fenceagentname}"", '-o', 'metadata' ) metadata = stdout.join begin doc = REXML::Document.new(metadata) rescue REXML::ParseException => e $logger.error( ""Unable to parse metadata of fence agent '#{resourcepath}': #{e}"" ) return [options_required, options_optional, options_advanced] end short_desc = """" long_desc = """" if doc.root short_desc = doc.root.attributes[""shortdesc""] end if short_desc == """" doc.elements.each('resource-agent/shortdesc') {|sd| short_desc = sd.text ? sd.text.strip : sd.text } end doc.elements.each('resource-agent/longdesc') {|ld| long_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/parameters/parameter') { |param| temp_array = [] if param.elements[""shortdesc""] temp_array << param.elements[""shortdesc""].text else temp_array << """" end if param.elements[""longdesc""] temp_array << param.elements[""longdesc""].text else temp_array << """" end if param.attributes[""required""] == ""1"" and param.attributes[""name""] != ""action"" options_required[param.attributes[""name""]] = temp_array else options_optional[param.attributes[""name""]] = temp_array end } [options_required, options_optional, options_advanced, [short_desc, long_desc]] end",True,Ruby,getFenceAgentMetadata,fenceagent.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""does not remove multiple '../' at the beginning"" do expect(File.cleanpath('../../A/B')).to eq 'A/B' end"
2007,"def getFenceAgents(session, fence_agent = nil) fence_agent_list = {} agents = Dir.glob('/usr/sbin/fence_' + '*') agents.each { |a| fa = FenceAgent.new fa.name = a.sub(/.*\//,"""") next if fa.name == ""fence_ack_manual"" if fence_agent and a.sub(/.*\//,"""") == fence_agent.sub(/.*:/,"""") required_options, optional_options, advanced_options, info = getFenceAgentMetadata(session, fa.name) fa.required_options = required_options fa.optional_options = optional_options fa.advanced_options = advanced_options fa.info = info end fence_agent_list[fa.name] = fa } fence_agent_list end",True,Ruby,getFenceAgents,fenceagent.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.save_url_to_path(url, width, path) cmd = ""phantomjs rasterise.js #{url.shellescape} #{width} #{path}"" run(cmd) end"
2010,"def run_cmd(session, *args) options = {} return run_cmd_options(session, options, *args) end",True,Ruby,run_cmd,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def attrs_to_s attributes.inject("""") do |res, (name, value)| next unless value value = if value.is_a?(Array) value.map { |val| Rumble.html_escape(val) }.join("" "") elsif value == true name else Rumble.html_escape(value) end res << "" #{name}=\""#{value.gsub('""'.freeze, '&quot;'.freeze)}\"""" res end end"
2013,"def allowed_for_superuser(session) $logger.debug( ""permission check superuser username=#{session[:username]} groups=#{session[:groups]}"" ) if SUPERUSER != session[:username] $logger.debug('permission denied') return false end $logger.debug('permission granted for superuser') return true end",True,Ruby,allowed_for_superuser,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def test_hash_data str = <<-HTML <div data-modal=""true"" data-safe=""&quot;&quot;&quot;"" data-unsafe=""&quot;&amp;quot;&quot;""> </div> HTML assert_rumble str do div data: { modal: true, safe: '""&quot;""'.html_safe, unsafe: '""&quot;""' } end end"
2014,"def get_corosync_nodes() stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, PCS, ""status"", ""nodes"", ""corosync"" ) if retval != 0 return [] end stdout.each {|x| x.strip!} corosync_online = stdout[1].sub(/^.*Online:/,"""").strip corosync_offline = stdout[2].sub(/^.*Offline:/,"""").strip corosync_nodes = (corosync_online.split(/ /)) + (corosync_offline.split(/ /)) return corosync_nodes end",True,Ruby,get_corosync_nodes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def show render (params[:page].to_s ||= 'start') end
2017,"def add_acl_role(session, name, description) cmd = [PCS, ""acl"", ""role"", ""create"", name.to_s] if description.to_s != """" cmd << ""description=#{description.to_s}"" end stdout, stderror, retval = run_cmd(session, *cmd) if retval != 0 return stderror.join(""\n"").strip end return """" end",True,Ruby,add_acl_role,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def write_key_to_disk(key, identity) # Writing is disabled. Don't bother checking any other states. return unless lookup_config_option('learn_public_keys') =~ /^1|y/ publickey_dir = lookup_config_option('publickey_dir') unless publickey_dir Log.info(""Public key sent with request but no publickey_dir defined in configuration. Not writing key to disk."") return end if File.directory?(publickey_dir) # Reject identity if it would result in directory traversal. old_keyfile = File.join(File.expand_path(publickey_dir), ""#{identity}_pub.pem"") unless File.expand_path(old_keyfile) == old_keyfile Log.warn(""Identity returned by server would result in directory traversal. Not writing key to disk."") return end if File.exists?(old_keyfile) old_key = File.read(old_keyfile).chomp unless old_key == key unless lookup_config_option('overwrite_stored_keys', 'n') =~ /^1|y/ Log.warn(""Public key sent from '%s' does not match the stored key. Not overwriting."" % identity) else Log.warn(""Public key sent from '%s' does not match the stored key. Overwriting."" % identity) File.open(old_keyfile, 'w') { |f| f.puts key } end end else Log.debug(""Discovered a new public key for '%s'. Writing to '%s'"" % [identity, publickey_dir]) File.open(old_keyfile, 'w') { |f| f.puts key } end else raise(""Cannot write public key to '%s'. Directory does not exist."" % publickey_dir) end end"
2019,"def add_fence_level(session, level, devices, node, remove = false) if not remove stdout, stderr, retval = run_cmd( session, PCS, ""stonith"", ""level"", ""add"", level, node, devices ) return retval,stdout, stderr else stdout, stderr, retval = run_cmd( session, PCS, ""stonith"", ""level"", ""remove"", level, node, devices ) return retval,stdout, stderr end end",True,Ruby,add_fence_level,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'should not overwrite an existing file if overwrite_stored_key is not set' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') @plugin.stubs(:lookup_config_option).with('overwrite_stored_keys', 'n').returns('n') File.stubs(:directory?).with('ssh/pkd').returns(true) full_path = File.join(File.expand_path('ssh/pkd'), 'rspec_pub.pem') File.stubs(:exists?).with(full_path).returns(true) File.stubs(:read).with(full_path).returns('ssh-rsa dcba') Log.expects(:warn) File.expects(:open).never @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end"
2020,"def remove_node(session, new_nodename, all=false) if all # we check for a quorum loss warning in remote_remove_nodes out, stderror, retval = run_cmd( session, PCS, ""cluster"", ""node"", ""remove"", new_nodename, ""--force"" ) else out, stderror, retval = run_cmd( session, PCS, ""cluster"", ""localnode"", ""remove"", new_nodename ) end $logger.info(""Removing #{new_nodename} from pcs_settings.conf"") corosync_nodes = get_corosync_nodes() pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.update_cluster($cluster_name, corosync_nodes) sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, corosync_nodes, $cluster_name, true ) return retval, out + stderror end",True,Ruby,remove_node,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'should overwrite the existing public key if overwrite_stored_key is set' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') @plugin.stubs(:lookup_config_option).with('overwrite_stored_keys', 'n').returns('1') File.stubs(:directory?).with('ssh/pkd').returns(true) full_path = File.join(File.expand_path('ssh/pkd'), 'rspec_pub.pem') File.stubs(:exists?).with(full_path).returns(true) File.stubs(:read).with(full_path).returns('ssh-rsa dcba') file = mock File.expects(:open).with(full_path, 'w').yields(file) file.expects(:puts).with('ssh-rsa abcd') Log.expects(:warn) @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end"
2022,"def get_node_attributes(session, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(session) return {} unless cib_dom end node_attrs = {} cib_dom.elements.each( '/cib/configuration/nodes/node/instance_attributes/nvpair' ) { |e| node = e.parent.parent.attributes['uname'] node_attrs[node] ||= [] node_attrs[node] << { :id => e.attributes['id'], :key => e.attributes['name'], :value => e.attributes['value'] } } node_attrs.each { |_, val| val.sort_by! { |obj| obj[:key] }} return node_attrs end",True,Ruby,get_node_attributes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'should write the public key to disk if its the first time its been seen' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') File.stubs(:directory?).with('ssh/pkd').returns(true) full_path = File.join(File.expand_path('ssh/pkd'), 'rspec_pub.pem') File.stubs(:exists?).with(full_path).returns(false) file = mock File.expects(:open).with(full_path, 'w').yields(file) file.expects(:puts).with('ssh-rsa abcd') @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end"
2024,"def send_request_with_token(session, node, request, post=false, data={}, remote=true, raw_data=nil, timeout=30, additional_tokens={}) token = additional_tokens[node] || get_node_token(node) $logger.info ""SRWT Node: #{node} Request: #{request}"" if not token $logger.error ""Unable to connect to node #{node}, no token available"" return 400,'{""notoken"":true}' end cookies_data = { 'token' => token, } return send_request( session, node, request, post, data, remote, raw_data, timeout, cookies_data ) end",True,Ruby,send_request_with_token,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def params super rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e raise BadRequest, ""Invalid query parameters: #{Rack::Utils.escape_html(e.message)}"" end"
2027,"def get_pacemaker_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, PACEMAKERD, ""-$"" ) rescue stdout = [] end if retval == 0 match = /(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end",True,Ruby,get_pacemaker_version,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def accepts?(env) session = session env token = session[:csrf] ||= session['_csrf_token'] || random_string safe?(env) || secure_compare(env['HTTP_X_CSRF_TOKEN'], token) || secure_compare(Request.new(env).params[options[:authenticity_param]], token) end"
2029,"def get_cman_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, CMAN_TOOL, ""-V"" ) rescue stdout = [] end if retval == 0 match = /(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end",True,Ruby,get_cman_version,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def attachment(filename = nil, disposition = :attachment) response['Content-Disposition'] = disposition.to_s.dup return unless filename params = format('; filename=""%s""', File.basename(filename).gsub(/[""\r\n]/, MULTIPART_FORM_DATA_REPLACEMENT_TABLE)) response['Content-Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content-Type'] || ext.empty? end"
2032,"def send_cluster_request_with_token(session, cluster_name, request, post=false, data={}, remote=true, raw_data=nil) $logger.info(""SCRWT: "" + request) nodes = get_cluster_nodes(cluster_name) return send_nodes_request_with_token( session, nodes, request, post, data, remote, raw_data ) end",True,Ruby,send_cluster_request_with_token,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def ffi_lib(*names) raise LoadError.new(""library names list must not be empty"") if names.empty? lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL ffi_libs = names.map do |name| if name == FFI::CURRENT_PROCESS FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL) else libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact lib = nil errors = {} libnames.each do |libname| begin orig = libname lib = FFI::DynamicLibrary.open(libname, lib_flags) break if lib rescue Exception => ex ldscript = false if ex.message =~ /(([^ \t()])+\.so([^ \t:()])*):([ \t])*(invalid ELF header|file too short|invalid file format)/ if File.read($1) =~ /(?:GROUP|INPUT) *\( *([^ \)]+)/ libname = $1 ldscript = true end end if ldscript retry else # TODO better library lookup logic unless libname.start_with?(""/"") path = ['/usr/lib/','/usr/local/lib/'].find do |pth| File.exist?(pth + libname) end if path libname = path + libname retry end end libr = (orig == libname ? orig : ""#{orig} #{libname}"") errors[libr] = ex end end end if lib.nil? raise LoadError.new(errors.values.join("".\n"")) end # return the found lib lib end end @ffi_libs = ffi_libs end"
2033,"def send_local_certs_to_nodes(session, nodes) begin data = { 'ssl_cert' => File.read(CRT_FILE), 'ssl_key' => File.read(KEY_FILE), 'cookie_secret' => File.read(COOKIE_FILE), } rescue => e return { 'status' => 'error', 'text' => ""Unable to read certificates: #{e}"", 'node_status' => {}, } end crt_errors = verify_cert_key_pair(data['ssl_cert'], data['ssl_key']) if crt_errors and not crt_errors.empty? return { 'status' => 'error', 'text' => ""Invalid certificate and/or key: #{crt_errors.join}"", 'node_status' => {}, } end secret_errors = verify_cookie_secret(data['cookie_secret']) if secret_errors and not secret_errors.empty? return { 'status' => 'error', 'text' => ""Invalid cookie secret: #{secret_errors.join}"", 'node_status' => {}, } end node_response = {} threads = [] nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( session, node, '/set_certs', true, data ) node_response[node] = [code, response] } } threads.each { |t| t.join } node_error = [] node_status = {} node_response.each { |node, response| if response[0] == 200 node_status[node] = { 'status' => 'ok', 'text' => 'Success', } else text = response[1] if response[0] == 401 text = ""Unable to authenticate, try running 'pcs cluster auth'"" elsif response[0] == 400 begin parsed_response = JSON.parse(response[1], {:symbolize_names => true}) if parsed_response[:noresponse] text = ""Unable to connect"" elsif parsed_response[:notoken] or parsed_response[:notauthorized] text = ""Unable to authenticate, try running 'pcs cluster auth'"" end rescue JSON::ParserError end end node_status[node] = { 'status' => 'error', 'text' => text } node_error << node end } return { 'status' => node_error.empty?() ? 'ok' : 'error', 'text' => node_error.empty?() ? 'Success' : \ ""Unable to save pcsd certificates to nodes: #{node_error.join(', ')}"", 'node_status' => node_status, } end",True,Ruby,send_local_certs_to_nodes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def ffi_lib(*names) raise LoadError.new(""library names list must not be empty"") if names.empty? lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL ffi_libs = names.map do |name| if name == FFI::CURRENT_PROCESS FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL) else libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact lib = nil errors = {} libnames.each do |libname| begin orig = libname lib = FFI::DynamicLibrary.open(libname, lib_flags) break if lib rescue Exception => ex ldscript = false if ex.message =~ /(([^ \t()])+\.so([^ \t:()])*):([ \t])*(invalid ELF header|file too short|invalid file format)/ if File.read($1) =~ /(?:GROUP|INPUT) *\( *([^ \)]+)/ libname = $1 ldscript = true end end if ldscript retry else # TODO better library lookup logic unless libname.start_with?(""/"") || FFI::Platform.windows? path = ['/usr/lib/','/usr/local/lib/'].find do |pth| File.exist?(pth + libname) end if path libname = path + libname retry end end libr = (orig == libname ? orig : ""#{orig} #{libname}"") errors[libr] = ex end end end if lib.nil? raise LoadError.new(errors.values.join("".\n"")) end # return the found lib lib end end @ffi_libs = ffi_libs end"
2037,"def get_cib_dom(session) begin stdout, _, retval = run_cmd(session, 'cibadmin', '-Q', '-l') if retval == 0 return REXML::Document.new(stdout.join(""\n"")) end rescue $logger.error 'Failed to parse cib.' end return nil end",True,Ruby,get_cib_dom,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_template(""recaptcha.html"")"
2040,"def run_cmd_options(session, options, *args) $logger.info(""Running: "" + args.join("" "")) start = Time.now out = """" errout = """" proc_block = proc { |pid, stdin, stdout, stderr| if options and options.key?('stdin') stdin.puts(options['stdin']) stdin.close() end out = stdout.readlines() errout = stderr.readlines() duration = Time.now - start $logger.debug(out) $logger.debug(errout) $logger.debug(""Duration: "" + duration.to_s + ""s"") } cib_user = session[:username] # when running 'id -Gn' to get the groups they are not defined yet cib_groups = (session[:usergroups] || []).join(' ') $logger.info(""CIB USER: #{cib_user}, groups: #{cib_groups}"") # Open4.popen4 reimplementation which sets ENV in a child process prior # to running an external process by exec status = Open4::do_popen(proc_block, :init) { |ps_read, ps_write| ps_read.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC) ps_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC) ENV['CIB_user'] = cib_user ENV['CIB_user_groups'] = cib_groups exec(*args) } retval = status.exitstatus $logger.info(""Return Value: "" + retval.to_s) return out, errout, retval end",True,Ruby,run_cmd_options,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_template(""recaptcha.html"")"
2041,"def add_colocation_constraint( session, resourceA, resourceB, score, force=false, autocorrect=true ) if score == """" or score == nil score = ""INFINITY"" end command = [ PCS, ""constraint"", ""colocation"", ""add"", resourceA, resourceB, score ] command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(session, *command) return retval, stderr.join(' ') end",True,Ruby,add_colocation_constraint,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_template(""recaptcha.html"")"
2043,"def disable_cluster(session) stdout, stderror, retval = run_cmd(session, PCS, ""cluster"", ""disable"") return false if retval != 0 return true end",True,Ruby,disable_cluster,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_template(""recaptcha.html"")"
2044,"def add_node_attr(session, node, key, value) stdout, stderr, retval = run_cmd( session, PCS, ""property"", ""set"", ""--node"", node, key.to_s + '=' + value.to_s ) return retval end",True,Ruby,add_node_attr,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def call(env) node = env[:node] return if node.type != Nokogiri::XML::Node::ELEMENT_NODE || env[:is_whitelisted] name = env[:node_name] # Delete any element that isn't in the config whitelist, unless the node has # already been deleted from the document. # # It's important that we not try to reparent the children of a node that has # already been deleted, since that seems to trigger a memory leak in # Nokogiri. unless @elements.include?(name) || node.parent.nil? # Elements like br, div, p, etc. need to be replaced with whitespace in # order to preserve readability. if @whitespace_elements.include?(name) node.add_previous_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:before].to_s, node.document)) unless node.children.empty? node.add_next_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:after].to_s, node.document)) end end unless @remove_all_contents || @remove_element_contents.include?(name) node.add_previous_sibling(node.children) end node.unlink return end attr_whitelist = @attributes[name] || @attributes[:all] if attr_whitelist.nil? # Delete all attributes from elements with no whitelisted attributes. node.attribute_nodes.each {|attr| attr.unlink } else allow_data_attributes = attr_whitelist.include?(:data) # Delete any attribute that isn't allowed on this element. node.attribute_nodes.each do |attr| attr_name = attr.name.downcase unless attr_whitelist.include?(attr_name) # The attribute isn't whitelisted. if allow_data_attributes && attr_name.start_with?('data-') # Arbitrary data attributes are allowed. If this is a data # attribute, continue. next if attr_name =~ REGEX_DATA_ATTR end # Either the attribute isn't a data attribute or arbitrary data # attributes aren't allowed. Remove the attribute. attr.unlink next end # The attribute is whitelisted. # Remove any attributes that use unacceptable protocols. if @protocols.include?(name) && @protocols[name].include?(attr_name) attr_protocols = @protocols[name][attr_name] if attr.value =~ REGEX_PROTOCOL unless attr_protocols.include?($1.downcase) attr.unlink next end else unless attr_protocols.include?(:relative) attr.unlink next end end # Leading and trailing whitespace around URLs is ignored at parse # time. Stripping it here prevents it from being escaped by the # libxml2 workaround below. attr.value = attr.value.strip end # libxml2 >= 2.9.2 doesn't escape comments within some attributes, in an # attempt to preserve server-side includes. This can result in XSS since # an unescaped double quote can allow an attacker to inject a # non-whitelisted attribute. # # Sanitize works around this by implementing its own escaping for # affected attributes, some of which can exist on any element and some # of which can only exist on `<a>` elements. # # The relevant libxml2 code is here: # <https://github.com/GNOME/libxml2/commit/960f0e275616cadc29671a218d7fb9b69eb35588> if UNSAFE_LIBXML_ATTRS_GLOBAL.include?(attr_name) || (name == 'a' && UNSAFE_LIBXML_ATTRS_A.include?(attr_name)) attr.value = attr.value.gsub(UNSAFE_LIBXML_ESCAPE_REGEX, UNSAFE_LIBXML_ESCAPE_CHARS) end end end # Add required attributes. if @add_attributes.include?(name) @add_attributes[name].each {|key, val| node[key] = val } end end"
2045,"def remove_acl_permission(session, acl_perm_id) stdout, stderror, retval = run_cmd( session, PCS, ""acl"", ""permission"", ""delete"", acl_perm_id.to_s ) if retval != 0 if stderror.empty? return ""Error removing permission"" else return stderror.join(""\n"").strip end end return """" end",True,Ruby,remove_acl_permission,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'should not choke on valueless attributes' do @s.fragment('foo <a href>foo</a> bar') .must_equal 'foo <a href rel=""nofollow"">foo</a> bar' end"
2052,"def remove_constraint_rule(session, rule_id) stdout, stderror, retval = run_cmd( session, PCS, ""constraint"", ""rule"", ""remove"", rule_id ) $logger.info stdout return retval end",True,Ruby,remove_constraint_rule,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'removes existing content types' do subject.content_type :xls, 'application/vnd.ms-excel' subject.get :excel do 'some binary content' end get '/excel.json' expect(last_response.status).to eq(406) if ActiveSupport::VERSION::MAJOR == 3 expect(last_response.body).to eq('The requested format &#x27;txt&#x27; is not supported.') else expect(last_response.body).to eq('The requested format &#39;txt&#39; is not supported.') end end"
2054,"def get_stonith_agents_avail(session) code, result = send_cluster_request_with_token( session, params[:cluster], 'get_avail_fence_agents' ) return {} if 200 != code begin sa = JSON.parse(result) if (sa[""noresponse""] == true) or (sa[""notauthorized""] == ""true"") or (sa[""notoken""] == true) or (sa[""pacemaker_not_running""] == true) return {} else return sa end rescue JSON::ParserError return {} end end",True,Ruby,get_stonith_agents_avail,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'returns json error' do subject.content_type :json, 'application/json' subject.default_error_formatter :json subject.get '/something' do 'foo' end get '/something' expect(last_response.status).to eq(406) if ActiveSupport::VERSION::MAJOR == 3 expect(last_response.body).to eq('{&quot;error&quot;:&quot;The requested format &#x27;txt&#x27; is not supported.&quot;}') else expect(last_response.body).to eq('{&quot;error&quot;:&quot;The requested format &#39;txt&#39; is not supported.&quot;}') end end"
2056,"def run_auth_requests(session, nodes_to_send, nodes_to_auth, username, password, force=false, local=true) data = {} nodes_to_auth.each_with_index { |node, index| data[""node-#{index}""] = node } data['username'] = username data['password'] = password data['bidirectional'] = 1 if not local data['force'] = 1 if force auth_responses = {} threads = [] nodes_to_send.each { |node| threads << Thread.new { code, response = send_request(session, node, 'auth', true, data) if 200 == code token = response.strip if '' == token auth_responses[node] = {'status' => 'bad_password'} else auth_responses[node] = {'status' => 'ok', 'token' => token} end else auth_responses[node] = {'status' => 'noresponse'} end } } threads.each { |t| t.join } return auth_responses end",True,Ruby,run_auth_requests,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'is possible to return hash errors in jsonapi format' do get '/' expect(['{&quot;error&quot;:&quot;rain!&quot;,&quot;detail&quot;:&quot;missing widget&quot;}', '{&quot;detail&quot;:&quot;missing widget&quot;,&quot;error&quot;:&quot;rain!&quot;}']).to include(last_response.body) end"
2058,"def get_acls(session, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(session) return {} unless cib_dom end acls = { 'role' => {}, 'group' => {}, 'user' => {}, 'target' => {} } cib_dom.elements.each('/cib/configuration/acls/*') { |e| type = e.name[4..-1] if e.name == 'acl_role' role_id = e.attributes['id'] desc = e.attributes['description'] acls[type][role_id] = {} acls[type][role_id]['description'] = desc ? desc : '' acls[type][role_id]['permissions'] = [] e.elements.each('acl_permission') { |p| p_id = p.attributes['id'] p_kind = p.attributes['kind'] val = '' if p.attributes['xpath'] val = ""xpath #{p.attributes['xpath']}"" elsif p.attributes['reference'] val = ""id #{p.attributes['reference']}"" else next end acls[type][role_id]['permissions'] << ""#{p_kind} #{val} (#{p_id})"" } elsif ['acl_target', 'acl_group'].include?(e.name) id = e.attributes['id'] acls[type][id] = [] e.elements.each('role') { |r| acls[type][id] << r.attributes['id'] } end } acls['user'] = acls['target'] return acls end",True,Ruby,get_acls,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,it 'is possible to return errors in jsonapi format' do get '/' expect(last_response.body).to eq('{&quot;error&quot;:&quot;rain!&quot;}') end
2063,"def get_cluster_name() if ISRHEL6 stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC_CMAPCTL, ""cluster"" ) if retval == 0 stdout.each { |line| match = /^cluster\.name=(.*)$/.match(line) return match[1] if match } end begin cluster_conf = Cfgsync::ClusterConf.from_file().text() rescue return '' end conf_dom = REXML::Document.new(cluster_conf) if conf_dom.root and conf_dom.root.name == 'cluster' return conf_dom.root.attributes['name'] end return '' end stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC_CMAPCTL, ""totem.cluster_name"" ) if retval != 0 and not ISRHEL6 # Cluster probably isn't running, try to get cluster name from # corosync.conf begin corosync_conf = CorosyncConf::parse_string( Cfgsync::CorosyncConf.from_file().text() ) # mimic corosync behavior - the last cluster_name found is used cluster_name = nil corosync_conf.sections('totem').each { |totem| totem.attributes('cluster_name').each { |attrib| cluster_name = attrib[1] } } return cluster_name if cluster_name rescue return '' end return """" else return stdout.join().gsub(/.*= /,"""").strip end end",True,Ruby,get_cluster_name,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,it 'is possible to specify a custom formatter' do get '/' expect(last_response.body).to eq('{:custom_formatter=&gt;&quot;rain!&quot;}') end
2066,"def remove_acl_usergroup(session, role_id, usergroup_id) stdout, stderror, retval = run_cmd( session, PCS, ""acl"", ""role"", ""unassign"", role_id.to_s, usergroup_id.to_s, ""--autodelete"" ) if retval != 0 if stderror.empty? return ""Error removing user / group"" else return stderror.join(""\n"").strip end end return """" end",True,Ruby,remove_acl_usergroup,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def build_entry_path(dest_path, _, compressed_file_path) basename = File.basename(compressed_file_path) basename.gsub!(/#{Regexp.escape(extension)}$/, '') File.join(dest_path, basename) end"
2068,"def add_location_constraint( session, resource, node, score, force=false, autocorrect=true ) if node == """" return ""Bad node"" end if score == """" nodescore = node else nodescore = node + ""="" + score end cmd = [PCS, ""constraint"", ""location"", resource, ""prefers"", nodescore] cmd << '--force' if force cmd << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(session, *cmd) return retval, stderr.join(' ') end",True,Ruby,add_location_constraint,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def decompress(dest_path, compressed_file_path, max_size) @strategies.reverse.reduce(compressed_file_path) do |to_decompress, strategy| next_compressed_file = strategy.decompress(dest_path, to_decompress, max_size) FileUtils.rm_rf(to_decompress) next_compressed_file end end"
2069,"def check_gui_status_of_nodes(session, nodes, check_mutuality=false, timeout=10) options = {} options[:check_auth_only] = '' if not check_mutuality threads = [] not_authorized_nodes = [] online_nodes = [] offline_nodes = [] nodes = nodes.uniq.sort nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( session, node, 'check_auth', false, options, true, nil, timeout ) if code == 200 if check_mutuality begin parsed_response = JSON.parse(response) if parsed_response['node_list'] and parsed_response['node_list'].uniq.sort == nodes online_nodes << node else not_authorized_nodes << node end rescue not_authorized_nodes << node end else online_nodes << node end else begin parsed_response = JSON.parse(response) if parsed_response['notauthorized'] or parsed_response['notoken'] not_authorized_nodes << node else offline_nodes << node end rescue JSON::ParserError end end } } threads.each { |t| t.join } return online_nodes, offline_nodes, not_authorized_nodes end",True,Ruby,check_gui_status_of_nodes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def decompress(dest_path, compressed_file_path, max_size) sanitized_compressed_file_path = sanitize_path(compressed_file_path) sanitized_dest_path = sanitize_path(dest_path) get_compressed_file_stream(sanitized_compressed_file_path) do |compressed_file| available_size = calculate_available_size(max_size) entries_of(compressed_file).each do |entry| entry_path = build_entry_path(sanitized_dest_path, entry, sanitized_compressed_file_path) if !is_safe_path_for_extraction?(entry_path, sanitized_dest_path) next end FileUtils.mkdir_p(File.dirname(entry_path)) if is_file?(entry) remaining_size = extract_file(entry, entry_path, available_size) available_size = remaining_size else extract_folder(entry, entry_path) end end decompression_results_path(sanitized_dest_path, sanitized_compressed_file_path) end end"
2070,"def get_fence_levels(session, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(session) return {} unless cib_dom end fence_levels = {} cib_dom.elements.each( '/cib/configuration/fencing-topology/fencing-level' ) { |e| target = e.attributes['target'] fence_levels[target] ||= [] fence_levels[target] << { 'level' => e.attributes['index'], 'devices' => e.attributes['devices'] } } fence_levels.each { |_, val| val.sort_by! { |obj| obj['level'].to_i }} return fence_levels end",True,Ruby,get_fence_levels,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def build_entry_path(dest_path, entry, _) File.join(dest_path, entry.full_name) end"
2072,"def getAllSettings(session, cib_dom=nil) unless cib_dom cib_dom = get_cib_dom(session) end ret = {} if cib_dom cib_dom.elements.each('/cib/configuration/crm_config//nvpair') { |e| ret[e.attributes['name']] = e.attributes['value'] } end return ret end",True,Ruby,getAllSettings,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def build_entry_path(dest_path, entry, _) File.join(dest_path, entry.name) end"
2075,"def add_order_constraint( session, resourceA, resourceB, actionA, actionB, score, symmetrical=true, force=false, autocorrect=true ) sym = symmetrical ? ""symmetrical"" : ""nonsymmetrical"" if score != """" score = ""score="" + score end command = [ PCS, ""constraint"", ""order"", actionA, resourceA, ""then"", actionB, resourceB, score, sym ] command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(session, *command) return retval, stderr.join(' ') end",True,Ruby,add_order_constraint,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def import! FileUtils.mkdir(@temp_folder) available_size = SiteSetting.decompressed_theme_max_file_size_mb Compression::Engine.engine_for(@original_filename).tap do |engine| engine.decompress(@temp_folder, @filename, available_size) strip_root_directory end rescue RuntimeError raise RemoteTheme::ImportError, I18n.t(""themes.import_error.unpack_failed"") rescue Compression::Zip::ExtractFailed raise RemoteTheme::ImportError, I18n.t(""themes.import_error.file_too_big"") end"
2078,"def get_resource_agents_avail(session) code, result = send_cluster_request_with_token( session, params[:cluster], 'get_avail_resource_agents' ) return {} if 200 != code begin ra = JSON.parse(result) if (ra[""noresponse""] == true) or (ra[""notauthorized""] == ""true"") or (ra[""notoken""] == true) or (ra[""pacemaker_not_running""] == true) return {} else return ra end rescue JSON::ParserError return {} end end",True,Ruby,get_resource_agents_avail,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def read_file(relative_path) File.read(""#{temp_folder}/#{relative_path}"") end"
2079,"def add_location_constraint_rule( session, resource, rule, score, force=false, autocorrect=true ) cmd = [PCS, ""constraint"", ""location"", resource, ""rule""] if score != '' if is_score(score.upcase) cmd << ""score=#{score.upcase}"" else cmd << ""score-attribute=#{score}"" end end cmd.concat(rule.shellsplit()) cmd << '--force' if force cmd << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(session, *cmd) return retval, stderr.join(' ') end",True,Ruby,add_location_constraint_rule,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'decompress the folder and inspect files correctly' do engine = described_class.engine_for(@compressed_path) engine.decompress(temp_folder, ""#{temp_folder}/#{folder_name}.tar"", available_size) expect(read_file(""test/hello.txt"")).to eq(""hello world"") expect(read_file(""test/a/inner"")).to eq(""hello world inner"") end"
2080,"def get_crm_mon_dom(session) begin stdout, _, retval = run_cmd( session, CRM_MON, '--one-shot', '-r', '--as-xml' ) if retval == 0 return REXML::Document.new(stdout.join(""\n"")) end rescue $logger.error 'Failed to parse crm_mon.' end return nil end",True,Ruby,get_crm_mon_dom,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""exports the theme correctly"" do package file = 'discourse-header-icons.zip' Dir.chdir(dir) do available_size = SiteSetting.decompressed_theme_max_file_size_mb Compression::Zip.new.decompress(dir, file, available_size) `rm #{file}` folders = Dir.glob(""**/*"").reject { |f| File.file?(f) } expect(folders).to contain_exactly(""assets"", ""common"", ""locales"", ""mobile"") files = Dir.glob(""**/*"").reject { |f| File.directory?(f) } expect(files).to contain_exactly(""about.json"", ""assets/logo.png"", ""assets/other_logo.png"", ""common/body_tag.html"", ""locales/en.yml"", ""mobile/mobile.scss"", ""settings.yml"") expect(JSON.parse(File.read('about.json')).deep_symbolize_keys).to eq( ""name"": ""Header Icons"", ""about_url"": ""abouturl"", ""license_url"": ""licenseurl"", ""component"": false, ""assets"": { ""logo"": ""assets/logo.png"", ""other_logo"": ""assets/other_logo.png"" }, ""authors"": ""David Taylor"", ""minimum_discourse_version"": ""1.0.0"", ""maximum_discourse_version"": ""3.0.0.beta1"", ""theme_version"": ""1.0"", ""color_schemes"": { ""Orphan Color Scheme"": { ""header_primary"": ""F0F0F0"", ""header_background"": ""1E1E1E"", ""tertiary"": ""858585"" }, ""Theme Color Scheme"": { ""header_primary"": ""F0F0F0"", ""header_background"": ""1E1E1E"", ""tertiary"": ""858585"" } }, ""modifiers"": {}, ""learn_more"": ""https://meta.discourse.org/t/beginners-guide-to-using-discourse-themes/91966"" ) expect(File.read(""common/body_tag.html"")).to eq(""<b>testtheme1</b>"") expect(File.read(""mobile/mobile.scss"")).to eq(""body {background-color: $background_color; font-size: $font-size}"") expect(File.read(""settings.yml"")).to eq(""somesetting: #{rand_hex}"") expect(File.read(""locales/en.yml"")).to eq({ en: { key: ""value"" } }.deep_stringify_keys.to_yaml) theme.update!(name: ""Discourse Header Icons"") exporter = ThemeStore::ZipExporter.new(theme) filename = exporter.package_filename exporter.cleanup! expect(filename).to end_with ""/discourse-header-icons.zip"" end end"
2081,"def add_acl_permission(session, acl_role_id, perm_type, xpath_id, query_id) stdout, stderror, retval = run_cmd( session, PCS, ""acl"", ""permission"", ""add"", acl_role_id.to_s, perm_type.to_s, xpath_id.to_s, query_id.to_s ) if retval != 0 if stderror.empty? return ""Error adding permission"" else return stderror.join(""\n"").strip end end return """" end",True,Ruby,add_acl_permission,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def validate_invitiation!(sso) invite_key = secure_session[""invite-key""] return if invite_key.blank? invite = Invite.find_by(invite_key: invite_key) if invite.blank? raise Invite::ValidationFailed.new(I18n.t(""invite.not_found"", base_url: Discourse.base_url)) end if invite.redeemable? if invite.is_email_invite? && sso.email != invite.email raise Invite::ValidationFailed.new(I18n.t(""invite.not_matching_email"")) end elsif invite.expired? raise Invite::ValidationFailed.new(I18n.t('invite.expired', base_url: Discourse.base_url)) elsif invite.redeemed? raise Invite::ValidationFailed.new(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url)) end invite end"
2082,"def get_local_node_id() if ISRHEL6 out, errout, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC_CMAPCTL, ""cluster.cman"" ) if retval != 0 return """" end match = /cluster\.nodename=(.*)/.match(out.join(""\n"")) if not match return """" end local_node_name = match[1] out, errout, retval = run_cmd( PCSAuth.getSuperuserSession, CMAN_TOOL, ""nodes"", ""-F"", ""id"", ""-n"", local_node_name ) if retval != 0 return """" end return out[0].strip() end out, errout, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC_CMAPCTL, ""-g"", ""runtime.votequorum.this_node_id"" ) if retval != 0 return """" else return out[0].split(/ = /)[1].strip() end end",True,Ruby,get_local_node_id,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def is_invite_link? self.email.blank? end
2086,"def add_meta_attr(session, resource, key, value) stdout, stderr, retval = run_cmd( session, PCS, ""resource"", ""meta"", resource, key.to_s + ""="" + value.to_s ) return retval end",True,Ruby,add_meta_attr,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def can_redeem_invite? return false if !invite.redeemable? return false if email.blank? # Invite scoped to email has already been redeemed by anyone. if invite.is_email_invite? && InvitedUser.exists?(invite_id: invite.id) return false end # The email will be present for either an invite link (where the user provides # us the email manually) or for an invite scoped to an email, where we # prefill the email and do not let the user modify it. # # Note that an invite link can also have a domain scope which must be checked. email_to_check = redeeming_user&.email || email if invite.email.present? && !invite.email_matches?(email_to_check) raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.not_matching_email')) end if invite.domain.present? && !invite.domain_matches?(email_to_check) raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end # Anon user is trying to redeem an invitation, if an existing user already # redeemed it then we cannot redeem now. redeeming_user ||= User.where(admin: false, staged: false).find_by_email(email) if redeeming_user.present? && InvitedUser.exists?(user_id: redeeming_user.id, invite_id: invite.id) return false end true end"
2087,"def get_node_status(session, cib_dom) node_status = { :cluster_name => $cluster_name, :groups => [], :constraints => { # :rsc_location => [], # :rcs_colocation => [], # :rcs_order => [] }, :cluster_settings => {}, :need_ring1_address => need_ring1_address?, :is_cman_with_udpu_transport => is_cman_with_udpu_transport?, :acls => get_acls(session, cib_dom), :username => session[:username], :fence_levels => get_fence_levels(session, cib_dom), :node_attr => node_attrs_to_v2(get_node_attributes(session, cib_dom)), :nodes_utilization => get_nodes_utilization(cib_dom), :known_nodes => [] } nodes = get_nodes_status() known_nodes = [] nodes.each { |_, node_list| known_nodes.concat node_list } node_status[:known_nodes] = known_nodes.uniq nodes.each do |k,v| node_status[k.to_sym] = v end if cib_dom node_status[:groups] = get_resource_groups(cib_dom) node_status[:constraints] = getAllConstraints(cib_dom.elements['/cib/configuration/constraints']) end node_status[:cluster_settings] = getAllSettings(session, cib_dom) return node_status end",True,Ruby,get_node_status,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def add_to_private_topics_if_invited # Should not happen because of ensure_email_is_present!, but better to cover bases. return if email.blank? topic_ids = TopicInvite.joins(:invite) .joins(:topic) .where(""topics.archetype = ?"", Archetype::private_message) .where(""invites.email = ?"", email) .pluck(:topic_id) topic_ids.each do |id| if !TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id) TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id) end end end"
2089,"def add_acl_usergroup(session, acl_role_id, user_group, name) if (user_group == ""user"") or (user_group == ""group"") stdout, stderr, retval = run_cmd( session, PCS, ""acl"", user_group, ""create"", name.to_s, acl_role_id.to_s ) if retval == 0 return """" end if not /^error: (user|group) #{name.to_s} already exists$/i.match(stderr.join(""\n"").strip) return stderr.join(""\n"").strip end end stdout, stderror, retval = run_cmd( session, PCS, ""acl"", ""role"", ""assign"", acl_role_id.to_s, name.to_s ) if retval != 0 if stderror.empty? return ""Error adding #{user_group}"" else return stderror.join(""\n"").strip end end return """" end",True,Ruby,add_acl_usergroup,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def notify_invitee return if invite.invited_by.blank? invite.invited_by.notifications.create!( notification_type: Notification.types[:invitee_accepted], data: { display_username: invited_user.username }.to_json ) end"
2091,"def allowed_for_local_cluster(session, action) pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) return pcs_config.permissions_local.allows?( session[:username], session[:usergroups], action ) end",True,Ruby,allowed_for_local_cluster,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def initialize( invite:, email: nil, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil, redeeming_user: nil) @invite = invite @username = username @name = name @password = password @user_custom_fields = user_custom_fields @ip_address = ip_address @session = session @email_token = email_token @redeeming_user = redeeming_user ensure_email_is_present!(email) end"
2094,"def enable_cluster(session) stdout, stderror, retval = run_cmd(session, PCS, ""cluster"", ""enable"") return false if retval != 0 return true end",True,Ruby,enable_cluster,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""adds user to group"" do group = Fabricate(:group, grant_trust_level: 2) InvitedGroup.create(group_id: group.id, invite_id: invite.id) group.add_owner(invite.invited_by) user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user.group_users.count).to eq(4) expect(user.trust_level).to eq(2) end"
2095,"def need_ring1_address?() out, errout, retval = run_cmd(PCSAuth.getSuperuserSession, COROSYNC_CMAPCTL) if retval != 0 return false else udpu_transport = false rrp = false out.each { |line| # support both corosync-objctl and corosync-cmapctl format if /^\s*totem\.transport(\s+.*)?=\s*udpu$/.match(line) udpu_transport = true elsif /^\s*totem\.rrp_mode(\s+.*)?=\s*(passive|active)$/.match(line) rrp = true end } # on rhel6 ring1 address is required regardless of transport # it has to be added to cluster.conf in order to set up ring1 # in corosync by cman return ((ISRHEL6 and rrp) or (rrp and udpu_transport)) end end",True,Ruby,need_ring1_address?,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""raises an error if the email does not match the invite email"" do redeemer = InviteRedeemer.new(invite: invite, email: ""blah@test.com"", username: username, name: name) expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(""invite.not_matching_email"")) end"
2096,"def remove_constraint(session, constraint_id) stdout, stderror, retval = run_cmd( session, PCS, ""constraint"", ""remove"", constraint_id ) $logger.info stdout return retval end",True,Ruby,remove_constraint,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should redeem the invite and approve the user when user email is in auto_approve_email_domains setting"" do SiteSetting.auto_approve_email_domains = ""example.com"" user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.approved).to eq(true) expect(user.approved_by).to eq(Discourse.system_user) end"
2099,"def send_local_configs_to_nodes( session, nodes, force=false, clear_local_permissions=false ) configs = Cfgsync::get_configs_local(true) if clear_local_permissions pcs_config = PCSConfig.new(configs[Cfgsync::PcsdSettings.name].text()) pcs_config.permissions_local = Permissions::PermissionsSet.new([]) configs[Cfgsync::PcsdSettings.name].text = pcs_config.text() end publisher = Cfgsync::ConfigPublisher.new( session, configs.values(), nodes, $cluster_name ) return publisher.send(force) end",True,Ruby,send_local_configs_to_nodes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should redeem the invite if invited by non staff and approve if staff not required to approve"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(false) end"
2100,"def verify_cert_key_pair(cert, key) errors = [] cert_modulus = nil key_modulus = nil stdout, stderr, retval = run_cmd_options( PCSAuth.getSuperuserSession(), { 'stdin' => cert, }, '/usr/bin/openssl', 'x509', '-modulus', '-noout' ) if retval != 0 errors << ""Invalid certificate: #{stderr.join}"" else cert_modulus = stdout.join.strip end stdout, stderr, retval = run_cmd_options( PCSAuth.getSuperuserSession(), { 'stdin' => key, }, '/usr/bin/openssl', 'rsa', '-modulus', '-noout' ) if retval != 0 errors << ""Invalid key: #{stderr.join}"" else key_modulus = stdout.join.strip end if errors.empty? and cert_modulus and key_modulus if cert_modulus != key_modulus errors << 'Certificate does not match the key' end end return errors end",True,Ruby,verify_cert_key_pair,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can set custom fields"" do required_field = Fabricate(:user_field) optional_field = Fabricate(:user_field, required: false) user_fields = { required_field.id.to_s => 'value1', optional_field.id.to_s => 'value2' } user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem expect(user).to be_present expect(user.custom_fields[""user_field_#{required_field.id}""]).to eq('value1') expect(user.custom_fields[""user_field_#{optional_field.id}""]).to eq('value2') end"
2101,"def pcs_auth(session, nodes, username, password, force=false, local=true) # if no sync is needed, do not report a sync error sync_successful = true sync_failed_nodes = [] sync_responses = {} # check for already authorized nodes if not force online, offline, not_authenticated = check_gui_status_of_nodes( session, nodes, true ) if not_authenticated.length < 1 result = {} online.each { |node| result[node] = {'status' => 'already_authorized'} } offline.each { |node| result[node] = {'status' => 'noresponse'} } return result, sync_successful, sync_failed_nodes, sync_responses end end # authorize the nodes locally (i.e. not bidirectionally) auth_responses = run_auth_requests( session, nodes, nodes, username, password, force, true ) # get the tokens and sync them within the local cluster new_tokens = {} auth_responses.each { |node, response| new_tokens[node] = response['token'] if 'ok' == response['status'] } if not new_tokens.empty? cluster_nodes = get_corosync_nodes() tokens_cfg = Cfgsync::PcsdTokens.from_file('') # only tokens used in pcsd-to-pcsd communication can and need to be synced # those are accessible only when running under root account if Process.uid != 0 # other tokens just need to be stored localy for the user sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, [], nil ) return auth_responses, sync_successful, sync_failed_nodes, sync_responses end sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, cluster_nodes, $cluster_name ) sync_failed_nodes = [] sync_not_supported_nodes = [] sync_responses.each { |node, response| if 'not_supported' == response['status'] sync_not_supported_nodes << node elsif response['status'] != 'ok' sync_failed_nodes << node else node_result = response['result'][Cfgsync::PcsdTokens.name] if 'not_supported' == node_result sync_not_supported_nodes << node elsif not ['accepted', 'rejected'].include?(node_result) sync_failed_nodes << node end end } if not local # authorize nodes outside of the local cluster and nodes not supporting # the tokens file synchronization in the other direction nodes_to_auth = [] nodes.each { |node| nodes_to_auth << node if sync_not_supported_nodes.include?(node) nodes_to_auth << node if not cluster_nodes.include?(node) } auth_responses2 = run_auth_requests( session, nodes_to_auth, nodes, username, password, force, false ) auth_responses.update(auth_responses2) end end return auth_responses, sync_successful, sync_failed_nodes, sync_responses end",True,Ruby,pcs_auth,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""adds an entry to the group logs when the invited user is added to a group"" do group = Fabricate(:group) InvitedGroup.create(group_id: group.id, invite_id: invite.id) group.add_owner(invite.invited_by) GroupHistory.destroy_all user = InviteRedeemer.new( invite: invite, email: invite.email, username: username, name: name, password: password ).redeem expect(group.reload.usernames.split("","")).to include(user.username) expect(GroupHistory.exists?( target_user_id: user.id, acting_user: invite.invited_by.id, group_id: group.id, action: GroupHistory.actions[:add_user_to_group] )).to eq(true) end"
2102,"def get_nodes_status() corosync_online = [] corosync_offline = [] pacemaker_online = [] pacemaker_offline = [] pacemaker_standby = [] in_pacemaker = false stdout, stderr, retval = run_cmd( PCSAuth.getSuperuserSession, PCS, ""status"", ""nodes"", ""both"" ) stdout.each {|l| l = l.chomp if l.start_with?(""Pacemaker Nodes:"") in_pacemaker = true end if l.start_with?(""Pacemaker Remote Nodes:"") break end if l.end_with?("":"") next end title,nodes = l.split(/: /,2) if nodes == nil next end if title == "" Online"" in_pacemaker ? pacemaker_online.concat(nodes.split(/ /)) : corosync_online.concat(nodes.split(/ /)) elsif title == "" Standby"" if in_pacemaker pacemaker_standby.concat(nodes.split(/ /)) end elsif title == "" Maintenance"" if in_pacemaker pacemaker_online.concat(nodes.split(/ /)) end else in_pacemaker ? pacemaker_offline.concat(nodes.split(/ /)) : corosync_offline.concat(nodes.split(/ /)) end } return { 'corosync_online' => corosync_online, 'corosync_offline' => corosync_offline, 'pacemaker_online' => pacemaker_online, 'pacemaker_offline' => pacemaker_offline, 'pacemaker_standby' => pacemaker_standby, } end",True,Ruby,get_nodes_status,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should redeem an invite but not approve the user when invite is created by a staff user"" do inviter = invite.invited_by inviter.update!(admin: true) user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(user.approved).to eq(false) expect(inviter.notifications.count).to eq(1) end"
2106,"def get_corosync_version() begin stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC, ""-v"" ) rescue stdout = [] end if retval == 0 match = /version\D+(\d+)\.(\d+)\.(\d+)/.match(stdout.join()) if match return match[1..3].collect { | x | x.to_i } end end return nil end",True,Ruby,get_corosync_version,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can set password"" do user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(false) end"
2107,"def send_nodes_request_with_token(session, nodes, request, post=false, data={}, remote=true, raw_data=nil) out = """" code = 0 $logger.info(""SNRWT: "" + request) # If we're removing nodes, we don't send this to one of the nodes we're # removing, unless we're removing all nodes if request == ""/remove_nodes"" new_nodes = nodes.dup data.each {|k,v| if new_nodes.include? v new_nodes.delete v end } if new_nodes.length > 0 nodes = new_nodes end end for node in nodes $logger.info ""SNRWT Node: #{node} Request: #{request}"" code, out = send_request_with_token( session, node, request, post, data, remote, raw_data ) # try next node if: # - current node does not support the request (old version of pcsd?) (404) # - an exception or other error occurred (5xx) # - we don't have a token for the node (401, notoken) # - we didn't get a response form the node (e.g. an exception occurred) # - pacemaker is not running on the node # do not try next node if # - node returned 400 - it means the request cannot be processed because of # invalid arguments or another known issue, no node would be able to # process the request (e.g. removing a non-existing resource) # - node returned 403 - permission denied, no node should allow to process # the request log = ""SNRWT Node #{node} Request #{request}"" if (404 == code) or (code >= 500 and code <= 599) $logger.info(""#{log}: HTTP code #{code}"") next end if (401 == code) or ('{""notoken"":true}' == out) $logger.info(""#{log}: Bad or missing token"") next end if '{""pacemaker_not_running"":true}' == out $logger.info(""#{log}: Pacemaker not running"") next end if '{""noresponse"":true}' == out $logger.info(""#{log}: No response"") next end $logger.info(""#{log}: HTTP code #{code}"") break end return code, out end",True,Ruby,send_nodes_request_with_token,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should redeem the invite but not approve the user when invite is created by a regular user"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(user.approved).to eq(false) expect(inviter.notifications.count).to eq(1) end"
2109,"def pcsd_restart_nodes(session, nodes) node_response = {} threads = [] nodes.each { |node| threads << Thread.new { code, response = send_request_with_token( session, node, '/pcsd_restart', true ) node_response[node] = [code, response] } } threads.each { |t| t.join } node_error = [] node_status = {} node_response.each { |node, response| if response[0] == 200 node_status[node] = { 'status' => 'ok', 'text' => 'Success', } else text = response[1] if response[0] == 401 text = ""Unable to authenticate, try running 'pcs cluster auth'"" elsif response[0] == 400 begin parsed_response = JSON.parse(response[1], {:symbolize_names => true}) if parsed_response[:noresponse] text = ""Unable to connect"" elsif parsed_response[:notoken] or parsed_response[:notauthorized] text = ""Unable to authenticate, try running 'pcs cluster auth'"" end rescue JSON::ParserError end end node_status[node] = { 'status' => 'error', 'text' => text } node_error << node end } return { 'status' => node_error.empty?() ? 'ok' : 'error', 'text' => node_error.empty?() ? 'Success' : \ ""Unable to restart pcsd on nodes: #{node_error.join(', ')}"", 'node_status' => node_status, } end",True,Ruby,pcsd_restart_nodes,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""only allows one user to be created per invite"" do user = invite_redeemer.redeem invite.reload user.email = ""john@example.com"" user.save! another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name) another_user = another_invite_redeemer.redeem expect(another_user).to eq(nil) end"
2110,"def add_node(session, new_nodename, all=false, auto_start=true) if all command = [PCS, ""cluster"", ""node"", ""add"", new_nodename] if auto_start command << '--start' command << '--enable' end out, stderror, retval = run_cmd(session, *command) else out, stderror, retval = run_cmd( session, PCS, ""cluster"", ""localnode"", ""add"", new_nodename ) end $logger.info(""Adding #{new_nodename} to pcs_settings.conf"") corosync_nodes = get_corosync_nodes() pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.update_cluster($cluster_name, corosync_nodes) sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, corosync_nodes, $cluster_name, true ) return retval, out.join(""\n"") + stderror.join(""\n"") end",True,Ruby,add_node,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should correctly update the invite redeemed_at date"" do SiteSetting.invite_expiry_days = 2 invite.update!(created_at: 10.days.ago) inviter = invite.invited_by inviter.admin = true user = invite_redeemer.redeem invite.reload expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(invite.invited_users.first).to be_present end"
2111,"def add_order_set_constraint( session, resource_set_list, force=false, autocorrect=true ) command = [PCS, ""constraint"", ""order""] resource_set_list.each { |resource_set| command << ""set"" command.concat(resource_set) } command << '--force' if force command << '--autocorrect' if autocorrect stdout, stderr, retval = run_cmd(session, *command) return retval, stderr.join(' ') end",True,Ruby,add_order_set_constraint,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""does not add user to group if inviter does not have permissions"" do group = Fabricate(:group, grant_trust_level: 2) InvitedGroup.create(group_id: group.id, invite_id: invite.id) user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user.group_users.count).to eq(0) end"
2113,"def get_current_node_name() stdout, stderror, retval = run_cmd( PCSAuth.getSuperuserSession, CRM_NODE, ""-n"" ) if retval == 0 and stdout.length > 0 return stdout[0].chomp() end return """" end",True,Ruby,get_current_node_name,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""should delete invite if invited_by user has been removed"" do invite.invited_by.destroy! expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound) end"
2114,"def send_request(session, node, request, post=false, data={}, remote=true, raw_data=nil, timeout=30, cookies_data=nil) cookies_data = {} if not cookies_data begin request = ""/#{request}"" if not request.start_with?(""/"") # fix ipv6 address for URI.parse node6 = node if (node.include?("":"") and ! node.start_with?(""["")) node6 = ""[#{node}]"" end if remote uri = URI.parse(""https://#{node6}:2224/remote"" + request) else uri = URI.parse(""https://#{node6}:2224"" + request) end if post req = Net::HTTP::Post.new(uri.path) raw_data ? req.body = raw_data : req.set_form_data(data) else req = Net::HTTP::Get.new(uri.path) req.set_form_data(data) end cookies_to_send = [] cookies_data_default = {} # Let's be safe about characters in cookie variables and do base64. # We cannot do it for CIB_user however to be backward compatible # so we at least remove disallowed characters. cookies_data_default['CIB_user'] = PCSAuth.cookieUserSafe( session[:username].to_s ) cookies_data_default['CIB_user_groups'] = PCSAuth.cookieUserEncode( (session[:usergroups] || []).join(' ') ) cookies_data_default.update(cookies_data) cookies_data_default.each { |name, value| cookies_to_send << CGI::Cookie.new('name' => name, 'value' => value).to_s } req.add_field('Cookie', cookies_to_send.join(';')) # uri.host returns ""[addr]"" for ipv6 addresses, which is wrong # uri.hostname returns ""addr"" for ipv6 addresses, which is correct, but it # is not available in older ruby versions # There is a bug in Net::HTTP.new in some versions of ruby which prevents # ipv6 addresses being used here at all. myhttp = Net::HTTP.new(node, uri.port) myhttp.use_ssl = true myhttp.verify_mode = OpenSSL::SSL::VERIFY_NONE res = myhttp.start do |http| http.read_timeout = timeout http.request(req) end return res.code.to_i, res.body rescue Exception => e $logger.info ""No response from: #{node} request: #{request}, exception: #{e}"" return 400,'{""noresponse"":true}' end end",True,Ruby,send_request,pcs.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'redirects to the first topic the user was invited to and creates the topic notification' do topic = Fabricate(:topic) TopicInvite.create!(invite: invite, topic: topic) put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(200) expect(response.parsed_body['redirect_to']).to eq(topic.relative_url) expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1) end"
2116,"def protected! gui_request = ( # these are URLs for web pages request.path == '/' or request.path == '/manage' or request.path == '/permissions' or request.path.match('/managec/.+/main') ) if request.path.start_with?('/remote/') or request.path == '/run_pcs' unless PCSAuth.loginByToken(session, cookies) halt [401, '{""notauthorized"":""true""}'] end else #/managec/* /manage/* /permissions if !gui_request and request.env['HTTP_X_REQUESTED_WITH'] != 'XMLHttpRequest' then # Accept non GUI requests only with header # ""X_REQUESTED_WITH: XMLHttpRequest"". (check if they are send via AJAX). # This prevents CSRF attack. halt [401, '{""notauthorized"":""true""}'] elsif not PCSAuth.isLoggedIn(session) if gui_request session[:pre_login_path] = request.path redirect '/login' else halt [401, '{""notauthorized"":""true""}'] end end end end",True,Ruby,protected!,pcsd.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""does not try to log in the user automatically"" do expect do put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } end.not_to change { UserAuthToken.count } expect(response.status).to eq(200) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success"")) end"
2118,"def update_fence_device(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Updating fence device"" $logger.info params param_line = getParamList(params) $logger.info param_line if not params[:resource_id] out, stderr, retval = run_cmd( session, PCS, ""stonith"", ""create"", params[:name], params[:resource_type], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end return ""{}"" end if param_line.length != 0 out, stderr, retval = run_cmd( session, PCS, ""stonith"", ""update"", params[:resource_id], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end end return ""{}"" end",True,Ruby,update_fence_device,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""errors if the user's email domain doesn't match the invite domain"" do user.update!(email: ""blah@test.com"") invite.update!(email: nil, domain: ""example.com"") put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(412) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.domain_not_allowed"")) end"
2119,"def resource_unclone(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( session, PCS, 'resource', 'unclone', params[:resource_id] ) if retval != 0 return [400, 'Unable to unclone ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,resource_unclone,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""adds the user to the groups specified on the invite and allows them to access the secure topic"" do group.add_owner(invite.invited_by) secured_category = Fabricate(:category) secured_category.permissions = { group.name => :full } secured_category.save! topic = Fabricate(:topic, category: secured_category) TopicInvite.create!(invite: invite, topic: topic) InvitedGroup.create!(invite: invite, group: group) put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(200) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success"")) expect(response.parsed_body['redirect_to']).to eq(topic.relative_url) invite.reload expect(invite.redeemed?).to be_truthy expect(user.reload.groups).to include(group) expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1) end"
2120,"def resource_form(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end cib_dom = get_cib_dom(session) @cur_resource = get_resource_by_id(params[:resource], cib_dom) @groups = get_resource_groups(cib_dom) @version = params[:version] if @cur_resource.instance_of?(ClusterEntity::Primitive) and !@cur_resource.stonith @cur_resource_group = @cur_resource.get_group @cur_resource_clone = @cur_resource.get_clone @cur_resource_ms = @cur_resource.get_master @resource = ResourceAgent.new(@cur_resource.agentname) if @cur_resource.provider == 'heartbeat' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(session, HEARTBEAT_AGENTS_DIR + @cur_resource.type) elsif @cur_resource.provider == 'pacemaker' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(session, PACEMAKER_AGENTS_DIR + @cur_resource.type) elsif @cur_resource._class == 'nagios' @resource.required_options, @resource.optional_options, @resource.info = getResourceMetadata(session, NAGIOS_METADATA_DIR + @cur_resource.type + '.xml') end @existing_resource = true if @resource erb :resourceagentform else ""Can't find resource"" end else ""Resource #{params[:resource]} doesn't exist"" end end",True,Ruby,resource_form,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it 'redeems the invitation and creates the invite accepted notification' do put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(200) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success"")) invite.reload expect(invite.invited_users.first.user).to eq(user) expect(invite.redeemed?).to be_truthy expect( Notification.exists?( user: invite.invited_by, notification_type: Notification.types[:invitee_accepted] ) ).to eq(true) end"
2123,"def clusters_overview(params, request, session) cluster_map = {} forbidden_clusters = {} threads = [] config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) config.clusters.each { |cluster| threads << Thread.new { cluster_map[cluster.name] = { 'cluster_name' => cluster.name, 'error_list' => [ {'message' => 'Unable to connect to the cluster. Request timeout.'} ], 'warning_list' => [], 'status' => 'unknown', 'node_list' => get_default_overview_node_list(cluster.name), 'resource_list' => [] } overview_cluster = nil online, offline, not_authorized_nodes = check_gui_status_of_nodes( session, get_cluster_nodes(cluster.name), false, 3 ) not_supported = false forbidden = false cluster_nodes_auth = (online + offline).uniq cluster_nodes_all = (cluster_nodes_auth + not_authorized_nodes).uniq nodes_not_in_cluster = [] for node in cluster_nodes_auth code, response = send_request_with_token( session, node, 'cluster_status', true, {}, true, nil, 8 ) if code == 404 not_supported = true next end if 403 == code forbidden = true forbidden_clusters[cluster.name] = true break end begin parsed_response = JSON.parse(response) if parsed_response['noresponse'] or parsed_response['pacemaker_not_running'] next elsif parsed_response['notoken'] or parsed_response['notauthorized'] next elsif parsed_response['cluster_name'] != cluster.name # queried node is not in the cluster (any more) nodes_not_in_cluster << node next else overview_cluster = parsed_response break end rescue JSON::ParserError end end if cluster_nodes_all.sort == nodes_not_in_cluster.sort overview_cluster = { 'cluster_name' => cluster.name, 'error_list' => [], 'warning_list' => [], 'status' => 'unknown', 'node_list' => [], 'resource_list' => [] } end if not overview_cluster overview_cluster = { 'cluster_name' => cluster.name, 'error_list' => [], 'warning_list' => [], 'status' => 'unknown', 'node_list' => get_default_overview_node_list(cluster.name), 'resource_list' => [] } if not_supported overview_cluster['warning_list'] = [ { 'message' => 'Cluster is running an old version of pcs/pcsd which does not provide data for the dashboard.', }, ] else if forbidden overview_cluster['error_list'] = [ { 'message' => 'You do not have permissions to view the cluster.', 'type' => 'forbidden', }, ] overview_cluster['node_list'] = [] else overview_cluster['error_list'] = [ { 'message' => 'Unable to connect to the cluster.', }, ] end end end if not_authorized_nodes.length > 0 overview_cluster['warning_list'] << { 'message' => 'GUI is not authorized against node(s) '\ + not_authorized_nodes.join(', '), 'type' => 'nodes_not_authorized', 'node_list' => not_authorized_nodes, } end overview_cluster['node_list'].each { |node| if node['status_version'] == '1' overview_cluster['warning_list'] << { :message => 'Some nodes are running old version of pcs/pcsd.' } break end } cluster_map[cluster.name] = overview_cluster } } begin Timeout::timeout(18) { threads.each { |t| t.join } } rescue Timeout::Error threads.each { |t| t.exit } end # update clusters in PCSConfig not_current_data = false config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) cluster_map.each { |cluster, values| next if forbidden_clusters[cluster] nodes = [] values['node_list'].each { |node| nodes << node['name'] } if !config.cluster_nodes_equal?(cluster, nodes) $logger.info(""Updating node list for: #{cluster} #{config.get_nodes(cluster)}->#{nodes}"") config.update_cluster(cluster, nodes) not_current_data = true end } if not_current_data sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) end overview = { 'not_current_data' => not_current_data, 'cluster_list' => cluster_map.values.sort { |a, b| a['clustername'] <=> b['clustername'] } } return JSON.generate(overview) end",True,Ruby,clusters_overview,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""errors if the user's email doesn't match the invite email"" do user.update!(email: ""blah@test.com"") put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(412) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.not_matching_email"")) end"
2124,"def wizard_submit(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end wizard = PCSDWizard.getWizard(params[""wizard""]) if wizard != nil return erb wizard.process_responses(params) else return ""Error finding Wizard - #{params[""wizard""]}"" end end",True,Ruby,wizard_submit,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index user = if params[:username] && !params[:recent] user_record = User.find_by(username: params[:username].to_s) raise Discourse::NotFound if !user_record user_record else current_user end guardian.ensure_can_see_notifications!(user) if notification_types = params[:filter_by_types]&.split("","").presence notification_types.map! do |type| Notification.types[type.to_sym] || ( raise Discourse::InvalidParameters.new(""invalid notification type: #{type}"") ) end end if params[:recent].present? limit = (params[:limit] || 15).to_i limit = 50 if limit > 50 include_reviewables = false if SiteSetting.enable_experimental_sidebar_hamburger notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types) # notification_types is blank for the ""all notifications"" user menu tab include_reviewables = notification_types.blank? && guardian.can_see_review_queue? else notifications = Notification.recent_report(current_user, limit, notification_types) end if notifications.present? && !(params.has_key?(:silent) || @readonly_mode) if current_user.bump_last_seen_notification! current_user.reload current_user.publish_notifications_state end end if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables current_user_id = current_user.id Scheduler::Defer.later ""bump last seen reviewable for user"" do # we lookup current_user again in the background thread to avoid # concurrency issues where the user object returned by the # current_user controller method is changed by the time the deferred # block is executed User.find_by(id: current_user_id)&.bump_last_seen_reviewable! end end notifications = filter_inaccessible_notifications(notifications) json = { notifications: serialize_data(notifications, NotificationSerializer), seen_notification_id: current_user.seen_notification_id } if include_reviewables json[:pending_reviewables] = Reviewable.basic_serializers_for_list( Reviewable.user_menu_list_for(current_user), current_user ).as_json end render_json_dump(json) else offset = params[:offset].to_i notifications = Notification.where(user_id: user.id) .visible .includes(:topic) .order(created_at: :desc) notifications = notifications.where(read: true) if params[:filter] == ""read"" notifications = notifications.where(read: false) if params[:filter] == ""unread"" total_rows = notifications.dup.count notifications = notifications.offset(offset).limit(60) notifications = filter_inaccessible_notifications(notifications) render_json_dump(notifications: serialize_data(notifications, NotificationSerializer), total_rows_notifications: total_rows, seen_notification_id: user.seen_notification_id, load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter])) end end"
2125,"def auth(params, request, session) token = PCSAuth.validUser(params['username'],params['password'], true) # If we authorized to this machine, attempt to authorize everywhere node_list = [] if token and params[""bidirectional""] params.each { |k,v| if k.start_with?(""node-"") node_list.push(v) end } if node_list.length > 0 pcs_auth( session, node_list, params['username'], params['password'], params[""force""] == ""1"" ) end end return token end",True,Ruby,auth,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def validate_message_length(message) return if message.length <= SiteSetting.chat_maximum_message_length raise Discourse::InvalidParameters.new( ""Body cannot be over #{SiteSetting.chat_maximum_message_length} characters"", ) end"
2127,"def set_cluster_conf(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end if params[:cluster_conf] != nil and params[:cluster_conf].strip != """" Cfgsync::ClusterConf.backup() Cfgsync::ClusterConf.from_text(params[:cluster_conf]).save() return 200, 'Updated cluster.conf...' else $logger.info ""Invalid cluster.conf file"" return 400, 'Failed to update cluster.conf...' end end",True,Ruby,set_cluster_conf,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""publishes a DiscourseEvent for updated messages"" do chat_message = create_chat_message(user1, ""This will be changed"", public_chat_channel) events = DiscourseEvent.track_events do Chat::ChatMessageUpdater.update( guardian: guardian, chat_message: chat_message, new_content: ""Change to this!"", ) end expect(events.map { _1[:event_name] }).to include(:chat_message_edited) end"
2128,"def remove_resource(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end force = params['force'] no_error_if_not_exists = params.include?('no_error_if_not_exists') errors = """" params.each { |k,v| if k.index(""resid-"") == 0 resid = k.gsub('resid-', '') command = [PCS, 'resource', 'delete', resid] command << '--force' if force out, errout, retval = run_cmd(session, *command) if retval != 0 unless out.index("" does not exist."") != -1 and no_error_if_not_exists errors += errout.join(' ').strip + ""\n"" end end end } errors.strip! if errors == """" return 200 else $logger.info(""Remove resource errors:\n""+errors) return [400, errors] end end",True,Ruby,remove_resource,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""errors if a user other than the message user is trying to edit the message"" do og_message = ""This won't be changed!"" chat_message = create_chat_message(user1, og_message, public_chat_channel) new_message = ""2 short"" updater = Chat::ChatMessageUpdater.update( guardian: Guardian.new(Fabricate(:user)), chat_message: chat_message, new_content: new_message, ) expect(updater.failed?).to eq(true) expect(updater.error).to match(Discourse::InvalidAccess) end"
2129,"def remote_add_node(params, request, session, all=false) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end auto_start = false if params[:auto_start] and params[:auto_start] == ""1"" auto_start = true end if params[:new_nodename] != nil node = params[:new_nodename] if params[:new_ring1addr] != nil node += ',' + params[:new_ring1addr] end retval, output = add_node(session, node, all, auto_start) end if retval == 0 return [200, JSON.generate([retval, get_corosync_conf()])] end return [400,output] end",True,Ruby,remote_add_node,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def send_notification_email(opts) post = opts[:post] title = opts[:title] allow_reply_by_email = opts[:allow_reply_by_email] use_site_subject = opts[:use_site_subject] add_re_to_subject = opts[:add_re_to_subject] && post.post_number > 1 use_topic_title_subject = opts[:use_topic_title_subject] username = opts[:username] from_alias = opts[:from_alias] notification_type = opts[:notification_type] user = opts[:user] group_name = opts[:group_name] locale = user_locale(user) template = +""user_notifications.user_#{notification_type}"" if post.topic.private_message? template << ""_pm"" if group_name template << ""_group"" elsif user.staged template << ""_staged"" end end # category name category = Topic.find_by(id: post.topic_id)&.category if opts[:show_category_in_subject] && post.topic_id && category && !category.uncategorized? show_category_in_subject = category.name # subcategory case if !category.parent_category_id.nil? show_category_in_subject = ""#{Category.where(id: category.parent_category_id).pluck_first(:name)}/#{show_category_in_subject}"" end else show_category_in_subject = nil end # tag names if opts[:show_tags_in_subject] && post.topic_id tags = DiscourseTagging .visible_tags(Guardian.new(user)) .joins(:topic_tags) .where(""topic_tags.topic_id = ?"", post.topic_id) .limit(3) .pluck(:name) show_tags_in_subject = tags.any? ? tags.join("" "") : nil end group = post.topic.allowed_groups&.first if post.topic.private_message? subject_pm = if opts[:show_group_in_subject] && group.present? if group.full_name ""[#{group.full_name}] "" else ""[#{group.name}] "" end else I18n.t('subject_pm') end participants = self.class.participants(post, user) end if SiteSetting.private_email? title = I18n.t(""system_messages.private_topic_title"", id: post.topic_id) end context = +"""" tu = TopicUser.get(post.topic_id, user) context_posts = self.class.get_context_posts(post, tu, user) # make .present? cheaper context_posts = context_posts.to_a if context_posts.present? context << +""-- \n*#{I18n.t('user_notifications.previous_discussion')}*\n"" context_posts.each do |cp| context << email_post_markdown(cp, true) end end translation_override_exists = TranslationOverride.where( locale: SiteSetting.default_locale, translation_key: ""#{template}.text_body_template"" ).exists? if opts[:use_invite_template] invite_template = +""user_notifications.invited"" invite_template << ""_group"" if group_name invite_template << if post.topic.private_message? ""_to_private_message_body"" else ""_to_topic_body"" end topic_excerpt = post.excerpt.tr(""\n"", "" "") if post.is_first_post? && post.excerpt topic_url = post.topic&.url if SiteSetting.private_email? topic_excerpt = """" topic_url = """" end message = I18n.t(invite_template, username: username, group_name: group_name, topic_title: gsub_emoji_to_unicode(title), topic_excerpt: topic_excerpt, site_title: SiteSetting.title, site_description: SiteSetting.site_description, topic_url: topic_url ) html = PrettyText.cook(message, sanitize: false).html_safe else reached_limit = SiteSetting.max_emails_per_day_per_user > 0 reached_limit &&= (EmailLog.where(user_id: user.id) .where('created_at > ?', 1.day.ago) .count) >= (SiteSetting.max_emails_per_day_per_user - 1) in_reply_to_post = post.reply_to_post if user.user_option.email_in_reply_to if SiteSetting.private_email? message = I18n.t('system_messages.contents_hidden') else message = email_post_markdown(post) + (reached_limit ? ""\n\n#{I18n.t ""user_notifications.reached_limit"", count: SiteSetting.max_emails_per_day_per_user}"" : """") end first_footer_classes = ""highlight"" if (allow_reply_by_email && user.staged) || (user.suspended? || user.staged?) first_footer_classes = """" end unless translation_override_exists html = UserNotificationRenderer.render( template: 'email/notification', format: :html, locals: { context_posts: context_posts, reached_limit: reached_limit, post: post, in_reply_to_post: in_reply_to_post, classes: Rtl.new(user).css_class, first_footer_classes: first_footer_classes, reply_above_line: false } ) end end email_opts = { topic_title: Emoji.gsub_emoji_to_unicode(title), topic_title_url_encoded: title ? UrlHelper.encode_component(title) : title, message: message, url: post.url(without_slug: SiteSetting.private_email?), post_id: post.id, topic_id: post.topic_id, context: context, username: username, group_name: group_name, add_unsubscribe_link: !user.staged, mailing_list_mode: user.user_option.mailing_list_mode, unsubscribe_url: post.unsubscribe_url(user), allow_reply_by_email: allow_reply_by_email, only_reply_by_email: allow_reply_by_email && user.staged, use_site_subject: use_site_subject, add_re_to_subject: add_re_to_subject, show_category_in_subject: show_category_in_subject, show_tags_in_subject: show_tags_in_subject, private_reply: post.topic.private_message?, subject_pm: subject_pm, participants: participants, include_respond_instructions: !(user.suspended? || user.staged?), template: template, use_topic_title_subject: use_topic_title_subject, site_description: SiteSetting.site_description, site_title: SiteSetting.title, site_title_url_encoded: UrlHelper.encode_component(SiteSetting.title), locale: locale } unless translation_override_exists email_opts[:html_override] = html end # If we have a display name, change the from address email_opts[:from_alias] = from_alias if from_alias.present? TopicUser.change(user.id, post.topic_id, last_emailed_post_number: post.post_number) build_email(user.email, email_opts) end"
2130,"def remote_pcsd_restart(params, request, session) pcsd_restart() return [200, 'success'] end",True,Ruby,remote_pcsd_restart,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def show(for_card: false) return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user @user = fetch_user_from_params( include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts) ) user_serializer = nil if guardian.can_see_profile?(@user) serializer_class = for_card ? UserCardSerializer : UserSerializer user_serializer = serializer_class.new(@user, scope: guardian, root: 'user') topic_id = params[:include_post_count_for].to_i if topic_id != 0 && guardian.can_see?(Topic.find_by_id(topic_id)) user_serializer.topic_post_count = { topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count } end else user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: 'user') end if !params[:skip_track_visit] && (@user != current_user) track_visit_to_user_profile end # This is a hack to get around a Rails issue where values with periods aren't handled correctly # when used as part of a route. if params[:external_id] && params[:external_id].ends_with?('.json') return render_json_dump(user_serializer) end respond_to do |format| format.html do @restrict_fields = guardian.restrict_user_fields?(@user) store_preloaded(""user_#{@user.username}"", MultiJson.dump(user_serializer)) render :show end format.json do render_json_dump(user_serializer) end end end"
2131,"def resource_clone(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( session, PCS, 'resource', 'clone', params[:resource_id] ) if retval != 0 return [400, 'Unable to create clone resource from ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,resource_clone,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.validate(record, attribute, value, range) if value.nil? record.errors.add attribute, I18n.t('errors.messages.blank') elsif value.length > range.end record.errors.add attribute, I18n.t('errors.messages.too_long_validation', max: range.end, length: value.length)"
2133,"def add_constraint_rule_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end if params[""c_type""] == ""loc"" retval, error = add_location_constraint_rule( session, params[""res_id""], params[""rule""], params[""score""], params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params[""c_type""]}""] end if retval == 0 return [200, ""Successfully added constraint""] else return [400, ""Error adding constraint: #{error}""] end end",True,Ruby,add_constraint_rule_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can be updated"" do user = post_user token = user.email_tokens.first put ""/u/update-activation-email.json"", params: { email: 'updatedemail@example.com' } expect(response.status).to eq(200) user.reload expect(user.email).to eq('updatedemail@example.com') expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present expect(EmailToken.find_by(id: token.id)).to eq(nil) end"
2135,"def node_standby(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'node_standby', true, {""node""=>params[:name]} ) # data={""node""=>params[:name]} for backward compatibility with older versions of pcs/pcsd else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Standby Node"" stdout, stderr, retval = run_cmd(session, PCS, ""cluster"", ""standby"") return stdout end end",True,Ruby,node_standby,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def set_draft if params[:data].present? ChatDraft.find_or_initialize_by( user: current_user, chat_channel_id: @chat_channel.id, ).update!(data: params[:data]) else ChatDraft.where(user: current_user, chat_channel_id: @chat_channel.id).destroy_all end render json: success_json end"
2136,"def update_resource (params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end param_line = getParamList(params) if not params[:resource_id] out, stderr, retval = run_cmd( session, PCS, ""resource"", ""create"", params[:name], params[:resource_type], *param_line ) if retval != 0 return JSON.generate({""error"" => ""true"", ""stderr"" => stderr, ""stdout"" => out}) end if params[:resource_group] and params[:resource_group] != """" run_cmd( session, PCS, ""resource"",""group"", ""add"", params[:resource_group], params[:name] ) resource_group = params[:resource_group] end if params[:resource_clone] and params[:resource_clone] != """" name = resource_group ? resource_group : params[:name] run_cmd(session, PCS, ""resource"", ""clone"", name) elsif params[:resource_ms] and params[:resource_ms] != """" name = resource_group ? resource_group : params[:name] run_cmd(session, PCS, ""resource"", ""master"", name) end return JSON.generate({}) end if param_line.length != 0 # If it's a clone resource we strip off everything after the last ':' if params[:resource_clone] params[:resource_id].sub!(/(.*):.*/,'\1') end run_cmd( session, PCS, ""resource"", ""update"", params[:resource_id], *param_line ) end if params[:resource_group] if params[:resource_group] == """" if params[:_orig_resource_group] != """" run_cmd( session, PCS, ""resource"", ""group"", ""remove"", params[:_orig_resource_group], params[:resource_id] ) end else run_cmd( session, PCS, ""resource"", ""group"", ""add"", params[:resource_group], params[:resource_id] ) end end if params[:resource_clone] and params[:_orig_resource_clone] == ""false"" run_cmd(session, PCS, ""resource"", ""clone"", params[:resource_id]) end if params[:resource_ms] and params[:_orig_resource_ms] == ""false"" run_cmd(session, PCS, ""resource"", ""master"", params[:resource_id]) end if params[:_orig_resource_clone] == ""true"" and not params[:resource_clone] run_cmd( session, PCS, ""resource"", ""unclone"", params[:resource_id].sub(/:.*/,'') ) end if params[:_orig_resource_ms] == ""true"" and not params[:resource_ms] run_cmd( session, PCS, ""resource"", ""unclone"", params[:resource_id].sub(/:.*/,'') ) end return JSON.generate({}) end",True,Ruby,update_resource,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def self.modern_mobile_device?(user_agent) user_agent[0...USER_AGENT_MAX_LENGTH].match?(MODERN_MOBILE_REGEX) end
2141,"def cluster_start(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'cluster_start', true ) else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Starting Daemons"" output = `#{PCS} cluster start` $logger.debug output return output end end",True,Ruby,cluster_start,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.local_upload_html(url) additional_controls = if SiteSetting.disable_onebox_media_download_controls ""controlslist='nodownload'"" else """" end normalized_url = ::Onebox::Helpers.normalize_url_for_output(url) case File.extname(URI(url).path || """") when VIDEO_REGEX <<~HTML <div class=""onebox video-onebox""> <video #{additional_controls} width=""100%"" height=""100%"" controls=""""> <source src='#{normalized_url}'> <a href='#{normalized_url}'> #{normalized_url} </a> </video> </div> HTML when AUDIO_REGEX <<~HTML <audio #{additional_controls} controls> <source src='#{normalized_url}'> <a href='#{normalized_url}'> #{normalized_url} </a> </audio> HTML end end"
2142,"def get_sw_versions(params, request, session) versions = { ""rhel"" => get_rhel_version(), ""pcs"" => get_pcsd_version(), ""pacemaker"" => get_pacemaker_version(), ""corosync"" => get_corosync_version(), ""cman"" => get_cman_version(), } return JSON.generate(versions) end",True,Ruby,get_sw_versions,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.each_onebox_link(doc, extra_paths: []) onebox_links = doc.css(""a.#{ONEBOX_CSS_CLASS}"", *extra_paths) if onebox_links.present? onebox_links.each { |link| yield(link[""href""], link) if link[""href""].present? } end doc end HTML5_BLOCK_ELEMENTS ||= %w[ address article aside blockquote canvas center dd div dl dt fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr li main nav noscript ol output p pre section table tfoot ul video ] def self.apply(string_or_doc, extra_paths: nil) doc = string_or_doc doc = Loofah.fragment(doc) if doc.is_a?(String) changed = false each_onebox_link(doc, extra_paths: extra_paths) do |url, element| onebox, _ = yield(url, element) next if onebox.blank? parsed_onebox = Loofah.fragment(onebox) next if parsed_onebox.children.blank? changed = true parent = element.parent if parent&.node_name&.downcase == ""p"" && parsed_onebox.children.any? { |child| HTML5_BLOCK_ELEMENTS.include?(child.node_name.downcase) } siblings = parent.children element_idx = siblings.find_index(element) before_idx = first_significant_element_index(siblings, element_idx - 1, -1) after_idx = first_significant_element_index(siblings, element_idx + 1, +1) if before_idx < 0 && after_idx >= siblings.size parent.replace parsed_onebox elsif before_idx < 0 parent.children = siblings[after_idx..siblings.size] parent.add_previous_sibling(parsed_onebox) elsif after_idx >= siblings.size parent.children = siblings[0..before_idx] parent.add_next_sibling(parsed_onebox) else parent_rest = parent.dup parent.children = siblings[0..before_idx] parent_rest.children = siblings[after_idx..siblings.size] parent.add_next_sibling(parent_rest) parent.add_next_sibling(parsed_onebox) end else element.replace parsed_onebox end end Result.new(doc, changed) end def self.first_significant_element_index(elements, index, step) while index >= 0 && index < elements.size && ( elements[index].node_name.downcase == ""br"" || ( elements[index].node_name.downcase == ""text"" && elements[index].to_html.strip.blank? ) ) index = index + step end index end def self.is_previewing?(user_id) Discourse.redis.get(preview_key(user_id)) == ""1"" end def self.preview_onebox!(user_id) Discourse.redis.setex(preview_key(user_id), 1.minute, ""1"") end def self.onebox_previewed!(user_id) Discourse.redis.del(preview_key(user_id)) end def self.engine(url) Onebox::Matcher.new( url, { allowed_iframe_regexes: Onebox::Engine.origins_to_regexes(allowed_iframe_origins) }, ).oneboxed end def self.recently_failed?(url) Discourse.cache.read(onebox_failed_cache_key(url)).present? end def self.cache_failed!(url) Discourse.cache.write(onebox_failed_cache_key(url), true, expires_in: 1.hour) end private def self.preview_key(user_id) ""onebox:preview:#{user_id}"" end def self.blank_onebox { preview: """", onebox: """" } end def self.onebox_cache_key(url) ""onebox__#{url}"" end def self.onebox_failed_cache_key(url) ""onebox_failed__#{url}"" end def self.onebox_raw(url, opts = {}) url = UrlHelper.normalized_encode(url).to_s local_onebox(url, opts) || external_onebox(url) rescue => e # no point warning here, just cause we have an issue oneboxing a url # we can later hunt for failed oneboxes by searching logs if needed Rails.logger.info(""Failed to onebox #{url} #{e} #{e.backtrace}"") # return a blank hash, so rest of the code works blank_onebox end def self.local_onebox(url, opts = {}) return unless route = Discourse.route_for(url) html = case route[:controller] when ""uploads"" local_upload_html(url) when ""topics"" local_topic_html(url, route, opts) when ""users"" local_user_html(url, route) when ""list"" local_category_html(url, route) else if handler = local_handlers[route[:controller]] handler.call(url, route) end end normalized_url = ::Onebox::Helpers.normalize_url_for_output(URI(url).to_s) html = html.presence || ""<a href='#{normalized_url}'>#{normalized_url}</a>"" { onebox: html, preview: html } end"
2143,"def save_tokens(params, request, session) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(session, Permissions::FULL) return 403, ""Permission denied"" end new_tokens = {} params.each{|nodes| if nodes[0].start_with?""node:"" and nodes[0].length > 5 node = nodes[0][5..-1] token = nodes[1] new_tokens[node] = token end } tokens_cfg = Cfgsync::PcsdTokens.from_file('') sync_successful, sync_responses = Cfgsync::save_sync_new_tokens( tokens_cfg, new_tokens, get_corosync_nodes(), $cluster_name ) if sync_successful return [200, JSON.generate(read_tokens())] else return [400, ""Cannot update tokenfile.""] end end",True,Ruby,save_tokens,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.tag_counts_json(tags, guardian) show_pm_tags = guardian.can_tag_pms? target_tags = Tag.where(id: tags.map(&:target_tag_id).compact.uniq).select(:id, :name) tags .map do |t| topic_count = t.public_send(Tag.topic_count_column(guardian)) next if topic_count == 0 && t.pm_topic_count > 0 && !show_pm_tags attrs = { id: t.name, text: t.name, name: t.name, description: t.description, count: topic_count, pm_only: topic_count == 0 && t.pm_topic_count > 0, target_tag: t.target_tag_id ? target_tags.find { |x| x.id == t.target_tag_id }&.name : nil, } if show_pm_tags && SiteSetting.display_personal_messages_tag_counts attrs[:pm_count] = t.pm_topic_count end attrs end .compact end"
2144,"def cluster_disable(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'cluster_disable', true ) else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end success = disable_cluster(session) if not success return JSON.generate({""error"" => ""true""}) end return ""Cluster Disabled"" end end",True,Ruby,cluster_disable,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""shows topic tags and pm tags"" do get ""/tags.json"" tags = response.parsed_body[""tags""] serialized_tag = tags.find { |t| t[""id""] == topic_tag.name } expect(serialized_tag[""count""]).to eq(2) expect(serialized_tag[""pm_count""]).to eq(5) serialized_tag = tags.find { |t| t[""id""] == test_tag.name } expect(serialized_tag[""count""]).to eq(0) expect(serialized_tag[""pm_count""]).to eq(1) end"
2147,"def get_permissions_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) data = { 'user_types' => Permissions::get_user_types(), 'permission_types' => Permissions::get_permission_types(), 'permissions_dependencies' => Permissions::permissions_dependencies(), 'users_permissions' => pcs_config.permissions_local.to_hash(), } return [200, JSON.generate(data)] end",True,Ruby,get_permissions_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""retrieves all tags as a staff user"" do sign_in(admin) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] serialized_tag = tags.find { |t| t[""id""] == test_tag.name } expect(serialized_tag[""count""]).to eq(0) expect(serialized_tag[""pm_count""]).to eq(nil) expect(serialized_tag[""pm_only""]).to eq(false) serialized_tag = tags.find { |t| t[""id""] == topic_tag.name } expect(serialized_tag[""count""]).to eq(1) expect(serialized_tag[""pm_count""]).to eq(nil) expect(serialized_tag[""pm_only""]).to eq(false) end"
2149,"def fence_device_form(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end @cur_resource = get_resource_by_id(params[:resource], get_cib_dom(session)) if @cur_resource.instance_of?(ClusterEntity::Primitive) and @cur_resource.stonith @resource_agents = getFenceAgents(session, @cur_resource.agentname) @existing_resource = true @fenceagent = @resource_agents[@cur_resource.type] erb :fenceagentform else ""Can't find fence device"" end end",True,Ruby,fence_device_form,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""returns the right tags and categories tags for admin user"" do category.update!(tags: [test_tag]) sign_in(admin) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] expect(tags.length).to eq(2) expect(tags[0][""name""]).to eq(test_tag.name) expect(tags[0][""text""]).to eq(test_tag.name) expect(tags[0][""description""]).to eq(test_tag.description) expect(tags[0][""count""]).to eq(0) expect(tags[0][""pm_count""]).to eq(nil) expect(tags[0][""target_tag""]).to eq(nil) expect(tags[1][""name""]).to eq(topic_tag.name) categories = response.parsed_body[""extras""][""categories""] expect(categories[0][""id""]).to eq(category.id) expect(categories[0][""tags""].length).to eq(1) expect(categories[0][""tags""][0][""name""]).to eq(test_tag.name) expect(categories[0][""tags""][0][""text""]).to eq(test_tag.name) expect(categories[0][""tags""][0][""description""]).to eq(test_tag.description) expect(categories[0][""tags""][0][""count""]).to eq(0) expect(categories[0][""tags""][0][""pm_count""]).to eq(nil) expect(categories[0][""tags""][0][""target_tag""]).to eq(nil) end"
2150,"def add_fence_level_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end retval, stdout, stderr = add_fence_level( session, params[""level""], params[""devices""], params[""node""], params[""remove""] ) if retval == 0 return [200, ""Successfully added fence level""] else return [400, stderr] end end",True,Ruby,add_fence_level_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""only retrieve tags that have been used in public topics for non-staff user"" do sign_in(user) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] expect(tags.length).to eq(1) expect(tags[0][""name""]).to eq(topic_tag.name) expect(tags[0][""count""]).to eq(1) expect(tags[0][""pm_count""]).to eq(nil) end"
2154,"def add_acl_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end if params[""item""] == ""permission"" retval = add_acl_permission( session, params[""role_id""], params[""type""], params[""xpath_id""], params[""query_id""] ) elsif (params[""item""] == ""user"") or (params[""item""] == ""group"") retval = add_acl_usergroup( session, params[""role_id""], params[""item""], params[""usergroup""] ) else retval = ""Error: Unknown adding request"" end if retval == """" return [200, ""Successfully added permission to role""] else return [ 400, retval.include?(""cib_replace failed"") ? ""Error adding permission"" : retval ] end end",True,Ruby,add_acl_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def perform_show_response if request.head? head :ok return end topic_view_serializer = TopicViewSerializer.new( @topic_view, scope: guardian, root: false, include_raw: !!params[:include_raw], exclude_suggested_and_related: !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id] || !!params[:filter_top_level_replies], ) respond_to do |format| format.html do @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags.visible(guardian) : [] @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || [] @description_meta = @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary store_preloaded(""topic_#{@topic_view.topic.id}"", MultiJson.dump(topic_view_serializer)) render :show end format.json { render_json_dump(topic_view_serializer) } end end"
2155,"def remote_remove_nodes(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end count = 0 out = """" node_list = [] options = [] while params[""nodename-"" + count.to_s] node_list << params[""nodename-"" + count.to_s] count = count + 1 end options << ""--force"" if params[""force""] cur_node = get_current_node_name() if i = node_list.index(cur_node) node_list.push(node_list.delete_at(i)) end # stop the nodes at once in order to: # - prevent resources from moving pointlessly # - get possible quorum loss warning stop_params = node_list + options stdout, stderr, retval = run_cmd( session, PCS, ""cluster"", ""stop"", *stop_params ) if retval != 0 return [400, stderr.join] end node_list.each {|node| retval, output = remove_node(session, node, true) out = out + output.join(""\n"") } config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) if config.get_nodes($cluster_name) == nil or config.get_nodes($cluster_name).length == 0 return [200,""No More Nodes""] end return out end",True,Ruby,remote_remove_nodes,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def page_title title = @topic.title if @post_number > 1 title += "" - "" post = @topic.posts.find_by(post_number: @post_number) author = post&.user if author && @guardian.can_see_post?(post) title += I18n.t( ""inline_oneboxer.topic_page_title_post_number_by_user"", post_number: @post_number, username: author.username, ) else title += I18n.t(""inline_oneboxer.topic_page_title_post_number"", post_number: @post_number) end end if SiteSetting.topic_page_title_includes_category if @topic.category_id != SiteSetting.uncategorized_category_id && @topic.category_id && @topic.category title += "" - #{@topic.category.name}"" elsif SiteSetting.tagging_enabled && visible_tags.exists? title += "" - #{visible_tags.order(""tags.#{Tag.topic_count_column(@guardian)} DESC"").first.name}"" end end title end"
2157,"def remote_remove_node(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end if params[:remove_nodename] != nil retval, output = remove_node(session, params[:remove_nodename]) else return 400, ""No nodename specified"" end if retval == 0 return JSON.generate([retval, get_corosync_conf()]) end return JSON.generate([retval,output]) end",True,Ruby,remote_remove_node,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def find_topic(topic_or_topic_id) return topic_or_topic_id if topic_or_topic_id.is_a?(Topic) # with_deleted covered in #check_and_raise_exceptions Topic.with_deleted.includes(:category).find_by(id: topic_or_topic_id) end
2158,"def get_avail_resource_agents(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end agents = getResourceAgents(session) return JSON.generate(agents) end",True,Ruby,get_avail_resource_agents,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def refresh_disk_space log ""Refreshing disk stats..."" store.reset_cache rescue => ex log ""Something went wrong while refreshing disk stats."", ex end"
2162,"def get_cluster_properties_definition(params, request, session) unless allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end stdout, _, retval = run_cmd( session, PCS, 'property', 'get_cluster_properties_definition' ) if retval == 0 return [200, stdout] end return [400, '{}'] end",True,Ruby,get_cluster_properties_definition,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def run ensure_no_operation_is_running ensure_we_have_a_user log ""[STARTED]"" log ""'#{@user.username}' has started the backup!"" mark_backup_as_running listen_for_shutdown_signal ensure_directory_exists(@tmp_directory) ensure_directory_exists(@archive_directory) update_metadata dump_public_schema log ""Finalizing backup..."" @with_uploads ? create_archive : move_dump_backup upload_archive after_create_hook rescue SystemExit log ""Backup process was cancelled!"" rescue Exception => ex log ""EXCEPTION: "" + ex.message log ex.backtrace.join(""\n"") else @success = true @backup_filename ensure delete_old clean_up notify_user log ""Finished!"" publish_completion end"
2164,"def set_sync_options(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end options = [ 'sync_thread_pause', 'sync_thread_resume', 'sync_thread_disable', 'sync_thread_enable', ] if params.keys.count { |key| options.include?(key) } != 1 return [400, 'Exactly one option has to be specified'] end if params['sync_thread_disable'] if Cfgsync::ConfigSyncControl.sync_thread_disable($semaphore_cfgsync) return 'sync thread disabled' else return [400, 'sync thread disable error'] end end if params['sync_thread_enable'] if Cfgsync::ConfigSyncControl.sync_thread_enable() return 'sync thread enabled' else return [400, 'sync thread enable error'] end end if params['sync_thread_resume'] if Cfgsync::ConfigSyncControl.sync_thread_resume() return 'sync thread resumed' else return [400, 'sync thread resume error'] end end if params['sync_thread_pause'] if Cfgsync::ConfigSyncControl.sync_thread_pause( $semaphore_cfgsync, params['sync_thread_pause'] ) return 'sync thread paused' else return [400, 'sync thread pause error'] end end return [400, 'Exactly one option has to be specified'] end",True,Ruby,set_sync_options,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def delete_old return if Rails.env.development? log ""Deleting old backups..."" store.delete_old rescue => ex log ""Something went wrong while deleting old backups."", ex end"
2166,"def remove_constraint_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end if params[:constraint_id] retval = remove_constraint(session, params[:constraint_id]) if retval == 0 return ""Constraint #{params[:constraint_id]} removed"" else return [400, ""Error removing constraint: #{params[:constraint_id]}""] end else return [400,""Bad Constraint Options""] end end",True,Ruby,remove_constraint_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def clean_up log ""Cleaning stuff up..."" delete_uploaded_archive remove_tar_leftovers mark_backup_as_not_running refresh_disk_space if success end"
2167,"def set_certs(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end ssl_cert = (params['ssl_cert'] || '').strip ssl_key = (params['ssl_key'] || '').strip if ssl_cert.empty? and !ssl_key.empty? return [400, 'cannot save ssl certificate without ssl key'] end if !ssl_cert.empty? and ssl_key.empty? return [400, 'cannot save ssl key without ssl certificate'] end if !ssl_cert.empty? and !ssl_key.empty? ssl_errors = verify_cert_key_pair(ssl_cert, ssl_key) if ssl_errors and !ssl_errors.empty? return [400, ssl_errors.join] end begin write_file_lock(CRT_FILE, 0700, ssl_cert) write_file_lock(KEY_FILE, 0700, ssl_key) rescue => e # clean the files if we ended in the middle # the files will be regenerated on next pcsd start FileUtils.rm(CRT_FILE, {:force => true}) FileUtils.rm(KEY_FILE, {:force => true}) return [400, ""cannot save ssl files: #{e}""] end end if params['cookie_secret'] cookie_secret = params['cookie_secret'].strip if !cookie_secret.empty? begin write_file_lock(COOKIE_FILE, 0700, cookie_secret) rescue => e return [400, ""cannot save cookie secret: #{e}""] end end end return [200, 'success'] end",True,Ruby,set_certs,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def upload_archive return unless store.remote? log ""Uploading archive..."" content_type = MiniMime.lookup_by_filename(@backup_filename).content_type archive_path = File.join(@archive_directory, @backup_filename) store.upload_file(@backup_filename, archive_path, content_type) end"
2168,"def add_group(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end rg = params[""resource_group""] resources = params[""resources""] output, errout, retval = run_cmd( session, PCS, ""resource"", ""group"", ""add"", rg, *(resources.split("" "")) ) if retval == 0 return 200 else return 400, errout end end",True,Ruby,add_group,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def publish_completion if success log(""[SUCCESS]"") DiscourseEvent.trigger(:backup_complete, logs: @logs, ticket: @ticket) else log(""[FAILED]"") DiscourseEvent.trigger(:backup_failed, logs: @logs, ticket: @ticket) end end"
2169,"def fence_device_metadata(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end return 200 if not params[:resourcename] or params[:resourcename] == """" @fenceagent = FenceAgent.new(params[:resourcename]) @fenceagent.required_options, @fenceagent.optional_options, @fenceagent.advanced_options, @fenceagent.info = getFenceAgentMetadata(session, params[:resourcename]) @new_fenceagent = params[:new] erb :fenceagentform end",True,Ruby,fence_device_metadata,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def notify_user return if success && @user.id == Discourse::SYSTEM_USER_ID log ""Notifying '#{@user.username}' of the end of the backup..."" status = success ? :backup_succeeded : :backup_failed logs = Discourse::Utils.logs_markdown(@logs, user: @user) post = SystemMessage.create_from_system_user(@user, status, logs: logs) post.topic.invite_group(@user, Group[:admins]) if @user.id == Discourse::SYSTEM_USER_ID rescue => ex log ""Something went wrong while notifying user."", ex end"
2170,"def status_all(params, request, session, nodes=[], dont_update_config=false) if nodes == nil return JSON.generate({""error"" => ""true""}) end final_response = {} threads = [] forbidden_nodes = {} nodes.each {|node| threads << Thread.new { code, response = send_request_with_token(session, node, 'status') if 403 == code forbidden_nodes[node] = true end begin final_response[node] = JSON.parse(response) rescue JSON::ParserError => e final_response[node] = {""bad_json"" => true} $logger.info(""ERROR: Parse Error when parsing status JSON from #{node}"") end if final_response[node] and final_response[node][""notoken""] == true $logger.error(""ERROR: bad token for #{node}"") end } } threads.each { |t| t.join } if forbidden_nodes.length > 0 return 403, 'Permission denied' end # Get full list of nodes and see if we need to update the configuration node_list = [] final_response.each { |fr,n| node_list += n[""corosync_offline""] if n[""corosync_offline""] node_list += n[""corosync_online""] if n[""corosync_online""] node_list += n[""pacemaker_offline""] if n[""pacemaker_offline""] node_list += n[""pacemaker_online""] if n[""pacemaker_online""] } node_list.uniq! if node_list.length > 0 config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) old_node_list = config.get_nodes(params[:cluster]) if !(dont_update_config or config.cluster_nodes_equal?(params[:cluster], node_list)) $logger.info(""Updating node list for: #{params[:cluster]} #{old_node_list}->#{node_list}"") config.update_cluster(params[:cluster], node_list) sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return status_all(params, request, session, node_list, true) end end $logger.debug(""NODE LIST: "" + node_list.inspect) return JSON.generate(final_response) end",True,Ruby,status_all,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def delete_uploaded_archive return unless store.remote? archive_path = File.join(@archive_directory, @backup_filename) if File.exist?(archive_path) log ""Removing archive from local storage..."" File.delete(archive_path) end rescue => ex log ""Something went wrong while deleting uploaded archive from local storage."", ex end"
2171,"def get_cluster_tokens(params, request, session) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(session, Permissions::FULL) return 403, ""Permission denied"" end on, off = get_nodes nodes = on + off nodes.uniq! return [200, JSON.generate(get_tokens_of_nodes(nodes))] end",True,Ruby,get_cluster_tokens,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""returns a non-empty parameterized title when site title contains unicode"" do SiteSetting.title = ""Ɣ"" backuper = BackupRestore::Backuper.new(Discourse.system_user.id) expect(backuper.send(:get_parameterized_title)).to eq(""discourse"") end"
2172,"def get_wizard(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end wizard = PCSDWizard.getWizard(params[""wizard""]) if wizard != nil return erb wizard.collection_page else return ""Error finding Wizard - #{params[""wizard""]}"" end end",True,Ruby,get_wizard,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""returns a valid parameterized site title"" do SiteSetting.title = ""Coding Horror"" backuper = BackupRestore::Backuper.new(Discourse.system_user.id) expect(backuper.send(:get_parameterized_title)).to eq(""coding-horror"") end"
2173,"def config_backup(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'config_backup', true ) else if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end $logger.info ""Backup node configuration"" stdout, stderr, retval = run_cmd(session, PCS, ""config"", ""backup"") if retval == 0 $logger.info ""Backup successful"" return [200, stdout] end $logger.info ""Error during backup: #{stderr.join(' ').strip()}"" return [400, ""Unable to backup node: #{stderr.join(' ')}""] end end",True,Ruby,config_backup,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def self.ip_allowed?(ip) ip = ip.is_a?(IPAddr) ? ip : IPAddr.new(ip) ip = ip.native return false if ip_in_ranges?(ip, blocked_ip_blocks) || ip_in_ranges?(ip, PRIVATE_IP_RANGES) true end"
2175,"def cluster_status_gui(session, cluster_name, dont_update_config=false) cluster_nodes = get_cluster_nodes(cluster_name) status = cluster_status_from_nodes(session, cluster_nodes, cluster_name) unless status return 403, 'Permission denied' end new_cluster_nodes = [] new_cluster_nodes += status[:corosync_offline] if status[:corosync_offline] new_cluster_nodes += status[:corosync_online] if status[:corosync_online] new_cluster_nodes += status[:pacemaker_offline] if status[:pacemaker_offline] new_cluster_nodes += status[:pacemaker_online] if status[:pacemaker_online] new_cluster_nodes.uniq! if new_cluster_nodes.length > 0 config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) if !(dont_update_config or config.cluster_nodes_equal?(cluster_name, new_cluster_nodes)) old_cluster_nodes = config.get_nodes(cluster_name) $logger.info(""Updating node list for: #{cluster_name} #{old_cluster_nodes}->#{new_cluster_nodes}"") config.update_cluster(cluster_name, new_cluster_nodes) sync_config = Cfgsync::PcsdSettings.from_text(config.text()) # on version conflict just go on, config will be corrected eventually # by displaying the cluster in the web UI Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return cluster_status_gui(session, cluster_name, true) end end return JSON.generate(status) end",True,Ruby,cluster_status_gui,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def get_size(url) return @size_cache[url] if @size_cache.has_key?(url) absolute_url = url absolute_url = Discourse.base_url_no_prefix + absolute_url if absolute_url =~ %r{\A/[^/]} return unless absolute_url # FastImage fails when there's no scheme absolute_url = SiteSetting.scheme + "":"" + absolute_url if absolute_url.start_with?(""//"") # we can't direct FastImage to our secure-uploads url because it bounces # anonymous requests with a 404 error if url && Upload.secure_uploads_url?(url) absolute_url = Upload.signed_url_from_secure_uploads_url(absolute_url) end return unless is_valid_image_url?(absolute_url) upload = Upload.get_from_url(absolute_url) if upload && upload.width && upload.width > 0 @size_cache[url] = [upload.width, upload.height] else @size_cache[url] = FinalDestination::FastImage.size(absolute_url) end rescue Zlib::BufError, URI::Error, OpenSSL::SSL::SSLError # FastImage.size raises BufError for some gifs, leave it. end"
2177,"def cluster_enable(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'cluster_enable', true ) else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end success = enable_cluster(session) if not success return JSON.generate({""error"" => ""true""}) end return ""Cluster Enabled"" end end",True,Ruby,cluster_enable,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def policy(theme_id = nil, base_url: Discourse.base_url, path_info: ""/"") new.build(theme_id, base_url: base_url, path_info: path_info) end"
2179,"def cluster_stop(params, request, session) if params[:name] params_without_name = params.reject {|key, value| key == ""name"" or key == :name } code, response = send_request_with_token( session, params[:name], 'cluster_stop', true, params_without_name ) else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end options = [] if params.has_key?(""component"") if params[""component""].downcase == ""pacemaker"" options << ""--pacemaker"" elsif params[""component""].downcase == ""corosync"" options << ""--corosync"" end end options << ""--force"" if params[""force""] $logger.info ""Stopping Daemons"" stdout, stderr, retval = run_cmd(session, PCS, ""cluster"", ""stop"", *options) if retval != 0 return [400, stderr.join] else return stdout.join end end end",True,Ruby,cluster_stop,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def build(theme_id, base_url:, path_info: ""/"") builder = Builder.new(base_url: base_url) Extension.theme_extensions(theme_id).each { |extension| builder << extension } Extension.plugin_extensions.each { |extension| builder << extension } builder << Extension.site_setting_extension builder << Extension.path_specific_extension(path_info) builder.build end"
2182,"def resource_ungroup(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:group_id] return [400, 'group_id has to be specified.'] end _, stderr, retval = run_cmd( session, PCS, 'resource', 'ungroup', params[:group_id] ) if retval != 0 return [400, 'Unable to ungroup group ' + ""'#{params[:group_id]}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,resource_ungroup,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def initialize(base_url:) @directives = Default.new(base_url: base_url).directives @base_url = base_url end
2183,"def get_corosync_conf_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end return get_corosync_conf() end",True,Ruby,get_corosync_conf_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def initialize(base_url:) @base_url = base_url @directives = {}.tap do |directives| directives[:upgrade_insecure_requests] = [] if SiteSetting.force_https directives[:base_uri] = [:self] directives[:object_src] = [:none] directives[:script_src] = script_src directives[:worker_src] = worker_src directives[ :report_uri ] = report_uri if SiteSetting.content_security_policy_collect_reports directives[:frame_ancestors] = frame_ancestors if restrict_embed? directives[:manifest_src] = [""'self'""] end end"
2184,"def add_node_attr_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end retval = add_node_attr( session, params[""node""], params[""key""], params[""value""] ) # retval = 2 if removing attr which doesn't exist if retval == 0 or retval == 2 return [200, ""Successfully added attribute to node""] else return [400, ""Error adding attribute to node""] end end",True,Ruby,add_node_attr_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def cacheable? !!( GlobalSetting.anon_cache_store_threshold > 0 && !has_auth_cookie? && get? && no_cache_bypass ) end
2185,"def remove_acl_roles_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end errors = """" params.each { |name, value| if name.index(""role-"") == 0 out, errout, retval = run_cmd( session, PCS, ""acl"", ""role"", ""delete"", value.to_s, ""--autodelete"" ) if retval != 0 errors += ""Unable to remove role #{value}"" unless errout.include?(""cib_replace failure"") errors += "": #{errout.join("" "").strip()}"" end errors += ""\n"" $logger.info errors end end } if errors == """" return [200, ""Successfully removed ACL roles""] else return [400, errors] end end",True,Ruby,remove_acl_roles_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""allowlists Google Tag Manager when integrated"" do SiteSetting.gtm_container_id = ""GTM-ABCDEF"" script_srcs = parse(policy)[""script-src""] expect(script_srcs).to include(""https://www.googletagmanager.com/gtm.js"") # nonce is added by the GtmScriptNonceInjector middleware to prevent the # nonce from getting cached by AnonymousCache expect(script_srcs.to_s).not_to include(""nonce-"") end"
2186,"def resource_start(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( session, PCS, ""resource"", ""enable"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end",True,Ruby,resource_start,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""when GTM is enabled it adds the same nonce to the policy and the GTM tag"" do SiteSetting.content_security_policy = true SiteSetting.content_security_policy_report_only = true SiteSetting.gtm_container_id = ""GTM-ABCDEF"" get ""/latest"" script_src = parse(response.headers[""Content-Security-Policy""])[""script-src""] report_only_script_src = parse(response.headers[""Content-Security-Policy-Report-Only""])[""script-src""] nonce = extract_nonce_from_script_src(script_src) report_only_nonce = extract_nonce_from_script_src(report_only_script_src) expect(nonce).to eq(report_only_nonce) gtm_meta_tag = Nokogiri::HTML5.fragment(response.body).css(""#data-google-tag-manager"").first expect(gtm_meta_tag[""data-nonce""]).to eq(nonce) end"
2189,"def set_resource_utilization(params, reqest, session) unless allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] and params[:name] return 400, 'resource_id and name are required' end res_id = params[:resource_id] name = params[:name] value = params[:value] || '' _, stderr, retval = run_cmd( session, PCS, 'resource', 'utilization', res_id, ""#{name}=#{value}"" ) if retval != 0 return [400, ""Unable to set utilization '#{name}=#{value}' for "" + ""resource '#{res_id}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,set_resource_utilization,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index offset = (params[:offset] || 0).to_i limit = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT) keys = ApiKey .where(hidden: false) .includes(:user, :api_key_scopes) # Sort revoked keys by revoked_at and active keys by created_at .order(""revoked_at DESC NULLS FIRST, created_at DESC"") .offset(offset) .limit(limit) render_json_dump(keys: serialize_data(keys, ApiKeySerializer), offset: offset, limit: limit) end"
2190,"def remote_node_available(params, request, session) if (not ISRHEL6 and File.exist?(Cfgsync::CorosyncConf.file_path)) or (ISRHEL6 and File.exist?(Cfgsync::ClusterConf.file_path)) or File.exist?(""/var/lib/pacemaker/cib/cib.xml"") return JSON.generate({:node_available => false}) end return JSON.generate({:node_available => true}) end",True,Ruby,remote_node_available,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def parse_params(report_params) begin start_date = ( if report_params[:start_date].present? Time.parse(report_params[:start_date]).to_date else 1.days.ago end ).beginning_of_day end_date = ( if report_params[:end_date].present? Time.parse(report_params[:end_date]).to_date else start_date + 30.days end ).end_of_day rescue ArgumentError => e raise Discourse::InvalidParameters.new(e.message) end facets = nil facets = report_params[:facets].map { |s| s.to_s.to_sym } if Array === report_params[:facets] limit = fetch_limit_from_params(params: report_params, default: nil, max: REPORTS_LIMIT) filters = nil filters = report_params[:filters] if report_params.has_key?(:filters) { start_date: start_date, end_date: end_date, filters: filters, facets: facets, limit: limit } end"
2194,"def add_constraint_set_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end case params[""c_type""] when ""ord"" retval, error = add_order_set_constraint( session, params[""resources""].values, params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params[""c_type""]}""] end",True,Ruby,add_constraint_set_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index filters = params.slice(*UserHistory.staff_filters + %i[page limit]) page = (params[:page] || 0).to_i page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT) staff_action_logs = UserHistory.staff_action_records(current_user, filters) count = staff_action_logs.count staff_action_logs = staff_action_logs.offset(page * page_size).limit(page_size).to_a load_more_params = params.permit(UserHistory.staff_filters) load_more_params.merge!(page: page + 1, page_size: page_size) render_json_dump( staff_action_logs: serialize_data(staff_action_logs, UserHistorySerializer), total_rows_staff_action_logs: count, load_more_staff_action_logs: admin_staff_action_logs_path(load_more_params), extras: { user_history_actions: staff_available_actions, }, ) end"
2196,"def get_tokens(params, request, session) # pcsd runs as root thus always returns hacluster's tokens if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end return [200, JSON.generate(read_tokens)] end",True,Ruby,get_tokens,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index unless SiteSetting.enable_user_directory? raise Discourse::InvalidAccess.new(:enable_user_directory) end period = params.require(:period) period_type = DirectoryItem.period_types[period.to_sym] raise Discourse::InvalidAccess.new(:period_type) unless period_type result = DirectoryItem.where(period_type: period_type).includes(user: :user_custom_fields) if params[:group] group = Group.find_by(name: params[:group]) raise Discourse::InvalidParameters.new(:group) if group.blank? guardian.ensure_can_see!(group) guardian.ensure_can_see_group_members!(group) result = result.includes(user: :groups).where(users: { groups: { id: group.id } }) else result = result.includes(user: :primary_group) end result = apply_exclude_groups_filter(result) if params[:exclude_usernames] result = result .references(:user) .where.not(users: { username: params[:exclude_usernames].split("","") }) end order = params[:order] || DirectoryColumn.automatic_column_names.first dir = params[:asc] ? ""ASC"" : ""DESC"" active_directory_column_names = DirectoryColumn.active_column_names if active_directory_column_names.include?(order.to_sym) result = result.order(""directory_items.#{order} #{dir}, directory_items.id"") elsif params[:order] === ""username"" result = result.order(""users.#{order} #{dir}, directory_items.id"") else # Ordering by user field value user_field = UserField.find_by(name: params[:order]) if user_field result = result .references(:user) .joins( ""LEFT OUTER JOIN user_custom_fields ON user_custom_fields.user_id = users.id AND user_custom_fields.name = 'user_field_#{user_field.id}'"", ) .order( ""user_custom_fields.name = 'user_field_#{user_field.id}' ASC, user_custom_fields.value #{dir}"", ) end end result = result.includes(:user_stat) if period_type == DirectoryItem.period_types[:all] page = params[:page].to_i user_ids = nil if params[:name].present? user_ids = UserSearch.new(params[:name], include_staged_users: true).search.pluck(:id) if user_ids.present? # Add the current user if we have at least one other match user_ids << current_user.id if current_user && result.dup.where(user_id: user_ids).exists? result = result.where(user_id: user_ids) else result = result.where(""false"") end end if params[:username] user_id = User.where(username_lower: params[:username].to_s.downcase).pick(:id) if user_id result = result.where(user_id: user_id) else result = result.where(""false"") end end limit = fetch_limit_from_params(default: PAGE_SIZE, max: PAGE_SIZE) result_count = result.count result = result.limit(limit).offset(limit * page).to_a more_params = params.slice(:period, :order, :asc, :group, :user_field_ids).permit! more_params[:page] = page + 1 load_more_uri = URI.parse(directory_items_path(more_params)) load_more_directory_items_json = ""#{load_more_uri.path}.json?#{load_more_uri.query}"" # Put yourself at the top of the first page if result.present? && current_user.present? && page == 0 && !params[:group].present? position = result.index { |r| r.user_id == current_user.id } # Don't show the record unless you're not in the top positions already if (position || 10) >= 10 unless @users_in_exclude_groups&.include?(current_user.id) your_item = DirectoryItem.where(period_type: period_type, user_id: current_user.id).first result.insert(0, your_item) if your_item end end end last_updated_at = DirectoryItem.last_updated_at(period_type) serializer_opts = {} if params[:user_field_ids] serializer_opts[:user_custom_field_map] = {} user_field_ids = params[:user_field_ids]&.split(""|"")&.map(&:to_i) user_field_ids.each do |user_field_id| serializer_opts[:user_custom_field_map][ ""#{User::USER_FIELD_PREFIX}#{user_field_id}"" ] = user_field_id end end if params[:plugin_column_ids] serializer_opts[:plugin_column_ids] = params[:plugin_column_ids]&.split(""|"")&.map(&:to_i) end serializer_opts[:attributes] = active_directory_column_names serialized = serialize_data(result, DirectoryItemSerializer, serializer_opts) render_json_dump( directory_items: serialized, meta: { last_updated_at: last_updated_at, total_rows_directory_items: result_count, load_more_directory_items: load_more_directory_items_json, }, ) end"
2197,"def node_restart(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'node_restart', true ) else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Restarting Node"" output = `/sbin/reboot` $logger.debug output return output end end",True,Ruby,node_restart,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index params.permit(:offset) stream = Draft.stream( user: current_user, offset: params[:offset], limit: fetch_limit_from_params(default: nil, max: INDEX_LIMIT), ) render json: { drafts: stream ? serialize_data(stream, DraftSerializer) : [] } end"
2200,"def get_cib(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end cib, stderr, retval = run_cmd(session, CIBADMIN, ""-Ql"") if retval != 0 if not pacemaker_running? return [400, '{""pacemaker_not_running"":true}'] end return [500, ""Unable to get CIB: "" + cib.to_s + stderr.to_s] else return [200, cib] end end",True,Ruby,get_cib,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def members group = find_group(:group_id) guardian.ensure_can_see_group_members!(group) limit = fetch_limit_from_params(default: 50, max: MEMBERS_LIMIT) offset = params[:offset].to_i raise Discourse::InvalidParameters.new(:offset) if offset < 0 dir = (params[:asc] && params[:asc].present?) ? ""ASC"" : ""DESC"" order = ""NOT group_users.owner"" if params[:requesters] guardian.ensure_can_edit!(group) users = group.requesters total = users.count if (filter = params[:filter]).present? filter = filter.split("","") if filter.include?("","") if current_user&.admin users = users.filter_by_username_or_email(filter) else users = users.filter_by_username(filter) end end users = users .select(""users.*, group_requests.reason, group_requests.created_at requested_at"") .order(params[:order] == ""requested_at"" ? ""group_requests.created_at #{dir}"" : """") .order(username_lower: dir) .limit(limit) .offset(offset) return( render json: { members: serialize_data(users, GroupRequesterSerializer), meta: { total: total, limit: limit, offset: offset, }, } ) end if params[:order] && %w[last_posted_at last_seen_at].include?(params[:order]) order = ""#{params[:order]} #{dir} NULLS LAST"" elsif params[:order] == ""added_at"" order = ""group_users.created_at #{dir}"" end users = group.users.human_users total = users.count if (filter = params[:filter]).present? filter = filter.split("","") if filter.include?("","") if current_user&.admin users = users.filter_by_username_or_email(filter) else users = users.filter_by_username(filter) end end users = users .includes(:primary_group) .includes(:user_option) .select(""users.*, group_users.created_at as added_at"") .order(order) .order(username_lower: dir) members = users.limit(limit).offset(offset) owners = users.where(""group_users.owner"") render json: { members: serialize_data(members, GroupUserSerializer), owners: serialize_data(owners, GroupUserSerializer), meta: { total: total, limit: limit, offset: offset, }, } end"
2203,"def add_constraint_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end case params[""c_type""] when ""loc"" retval, error = add_location_constraint( session, params[""res_id""], params[""node_id""], params[""score""], params[""force""], !params['disable_autocorrect'] ) when ""ord"" resA = params[""res_id""] resB = params[""target_res_id""] actionA = params['res_action'] actionB = params['target_action'] if params[""order""] == ""before"" resA, resB = resB, resA actionA, actionB = actionB, actionA end retval, error = add_order_constraint( session, resA, resB, actionA, actionB, params[""score""], true, params[""force""], !params['disable_autocorrect'] ) when ""col"" resA = params[""res_id""] resB = params[""target_res_id""] score = params[""score""] if params[""colocation_type""] == ""apart"" if score.length > 0 and score[0] != ""-"" score = ""-"" + score elsif score == """" score = ""-INFINITY"" end end retval, error = add_colocation_constraint( session, resA, resB, score, params[""force""], !params['disable_autocorrect'] ) else return [400, ""Unknown constraint type: #{params['c_type']}""] end",True,Ruby,add_constraint_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index user = if params[:username] && !params[:recent] user_record = User.find_by(username: params[:username].to_s) raise Discourse::NotFound if !user_record user_record else current_user end guardian.ensure_can_see_notifications!(user) if notification_types = params[:filter_by_types]&.split("","").presence notification_types.map! do |type| Notification.types[type.to_sym] || (raise Discourse::InvalidParameters.new(""invalid notification type: #{type}"")) end end if params[:recent].present? limit = fetch_limit_from_params(default: 15, max: INDEX_LIMIT) include_reviewables = false notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types) # notification_types is blank for the ""all notifications"" user menu tab include_reviewables = notification_types.blank? && guardian.can_see_review_queue? if notifications.present? && !(params.has_key?(:silent) || @readonly_mode) if current_user.bump_last_seen_notification! current_user.reload current_user.publish_notifications_state end end if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables current_user_id = current_user.id Scheduler::Defer.later ""bump last seen reviewable for user"" do # we lookup current_user again in the background thread to avoid # concurrency issues where the user object returned by the # current_user controller method is changed by the time the deferred # block is executed User.find_by(id: current_user_id)&.bump_last_seen_reviewable! end end notifications = filter_inaccessible_notifications(notifications) json = { notifications: serialize_data(notifications, NotificationSerializer), seen_notification_id: current_user.seen_notification_id, } if include_reviewables json[:pending_reviewables] = Reviewable.basic_serializers_for_list( Reviewable.user_menu_list_for(current_user), current_user, ).as_json end render_json_dump(json) else offset = params[:offset].to_i notifications = Notification.where(user_id: user.id).visible.includes(:topic).order(created_at: :desc) notifications = notifications.where(read: true) if params[:filter] == ""read"" notifications = notifications.where(read: false) if params[:filter] == ""unread"" total_rows = notifications.dup.count notifications = notifications.offset(offset).limit(60) notifications = filter_inaccessible_notifications(notifications) render_json_dump( notifications: serialize_data(notifications, NotificationSerializer), total_rows_notifications: total_rows, seen_notification_id: user.seen_notification_id, load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]), ) end end"
2206,"def resource_change_group(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end if params[:resource_id].nil? or params[:group_id].nil? return [400, 'resource_id and group_id have to be specified.'] end if params[:group_id].empty? if params[:old_group_id] _, stderr, retval = run_cmd( session, PCS, 'resource', 'group', 'remove', params[:old_group_id], params[:resource_id] ) if retval != 0 return [400, ""Unable to remove resource '#{params[:resource_id]}' "" + ""from group '#{params[:old_group_id]}': #{stderr.join('')}"" ] end end return 200 end _, stderr, retval = run_cmd( session, PCS, 'resource', 'group', 'add', params[:group_id], params[:resource_id] ) if retval != 0 return [400, ""Unable to add resource '#{params[:resource_id]}' to "" + ""group '#{params[:group_id]}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,resource_change_group,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index params.require(:post_action_type_id) params.require(:id) post_action_type_id = params[:post_action_type_id].to_i page = params[:page].to_i page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT) # Find the post, and then determine if they can see the post (if deleted) post = Post.with_deleted.where(id: params[:id].to_i).first guardian.ensure_can_see!(post) unknown_user_ids = Set.new if current_user.present? result = DB.query_single(<<~SQL, user_id: current_user.id) SELECT mu.muted_user_id AS id FROM muted_users AS mu WHERE mu.user_id = :user_id UNION SELECT iu.ignored_user_id AS id FROM ignored_users AS iu WHERE iu.user_id = :user_id SQL unknown_user_ids.merge(result) end post_actions = post .post_actions .where(post_action_type_id: post_action_type_id) .includes(:user) .offset(page * page_size) .order(""post_actions.created_at ASC"") .limit(page_size) if !guardian.can_see_post_actors?(post.topic, post_action_type_id) raise Discourse::InvalidAccess unless current_user post_actions = post_actions.where(user_id: current_user.id) end action_type = PostActionType.types.key(post_action_type_id) total_count = post[""#{action_type}_count""].to_i data = { post_action_users: serialize_data( post_actions.to_a, PostActionUserSerializer, unknown_user_ids: unknown_user_ids, ), } data[:total_rows_post_action_users] = total_count if total_count > page_size render_json_dump(data) end"
2213,"def get_configs(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end if not $cluster_name or $cluster_name.empty? return JSON.generate({'status' => 'not_in_cluster'}) end if params[:cluster_name] != $cluster_name return JSON.generate({'status' => 'wrong_cluster_name'}) end out = { 'status' => 'ok', 'cluster_name' => $cluster_name, 'configs' => {}, } Cfgsync::get_configs_local.each { |name, cfg| out['configs'][cfg.class.name] = { 'type' => 'file', 'text' => cfg.text, } } return JSON.generate(out) end",True,Ruby,get_configs,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def deleted_posts params.permit(:offset, :limit) guardian.ensure_can_see_deleted_posts! user = fetch_user_from_params offset = [params[:offset].to_i, 0].max limit = fetch_limit_from_params(default: 60, max: DELETED_POSTS_MAX_LIMIT) posts = user_posts(guardian, user.id, offset: offset, limit: limit).where.not(deleted_at: nil) render_serialized(posts, AdminUserActionSerializer) end"
2217,"def get_sync_capabilities(params, request, session) return JSON.generate({ 'syncable_configs' => Cfgsync::get_cfg_classes_by_name().keys, }) end",True,Ruby,get_sync_capabilities,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def search matches = TagGroup.includes(:tags).visible(guardian).all matches = matches.where(""lower(name) ILIKE ?"", ""%#{params[:q].strip}%"") if params[:q].present? if params[:names].present? matches = matches.where(""lower(NAME) in (?)"", params[:names].map(&:downcase)) end matches = matches.order(""name"").limit( fetch_limit_from_params(default: 5, max: SiteSetting.max_tag_search_results), ) render json: { results: matches.map { |x| { name: x.name, tag_names: x.tags.base_tags.pluck(:name).sort } }, } end"
2221,"def remove_acl_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end if params[""item""] == ""permission"" retval = remove_acl_permission(session, params[""acl_perm_id""]) elsif params[""item""] == ""usergroup"" retval = remove_acl_usergroup( session, params[""role_id""],params[""usergroup_id""] ) else retval = ""Error: Unknown removal request"" end if retval == """" return [200, ""Successfully removed permission from role""] else return [400, retval] end end",True,Ruby,remove_acl_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def search filter_params = { for_input: params[:filterForInput], selected_tags: params[:selected_tags], exclude_synonyms: params[:excludeSynonyms], exclude_has_synonyms: params[:excludeHasSynonyms], } if limit = fetch_limit_from_params(default: nil, max: SiteSetting.max_tag_search_results) filter_params[:limit] = limit end filter_params[:category] = Category.find_by_id(params[:categoryId]) if params[:categoryId] if !params[:q].blank? clean_name = DiscourseTagging.clean_tag(params[:q]) filter_params[:term] = clean_name filter_params[:order_search_results] = true else filter_params[:order_popularity] = true end tags_with_counts, filter_result_context = DiscourseTagging.filter_allowed_tags(guardian, **filter_params, with_context: true) tags = self.class.tag_counts_json(tags_with_counts, guardian) json_response = { results: tags } if clean_name && !tags.find { |h| h[:id].downcase == clean_name.downcase } && tag = Tag.where_name(clean_name).first # filter_allowed_tags determined that the tag entered is not allowed json_response[:forbidden] = params[:q] if filter_params[:exclude_synonyms] && tag.synonym? json_response[:forbidden_message] = I18n.t( ""tags.forbidden.synonym"", tag_name: tag.target_tag.name, ) elsif filter_params[:exclude_has_synonyms] && tag.synonyms.exists? json_response[:forbidden_message] = I18n.t( ""tags.forbidden.has_synonyms"", tag_name: tag.name, ) else category_names = tag.categories.where(id: guardian.allowed_category_ids).pluck(:name) category_names += Category .joins(tag_groups: :tags) .where(id: guardian.allowed_category_ids, ""tags.id"": tag.id) .pluck(:name) if category_names.present? category_names.uniq! json_response[:forbidden_message] = I18n.t( ""tags.forbidden.restricted_to"", count: category_names.count, tag_name: tag.name, category_names: category_names.join("", ""), ) else json_response[:forbidden_message] = I18n.t( ""tags.forbidden.in_this_category"", tag_name: tag.name, ) end end end if required_tag_group = filter_result_context[:required_tag_group] json_response[:required_tag_group] = required_tag_group end render json: json_response end"
2224,"def remote(params, request, session) remote_cmd_without_pacemaker = { :status => method(:node_status), :status_all => method(:status_all), :cluster_status => method(:cluster_status_remote), :auth => method(:auth), :check_auth => method(:check_auth), :setup_cluster => method(:setup_cluster), :create_cluster => method(:create_cluster), :get_quorum_info => method(:get_quorum_info), :get_cib => method(:get_cib), :get_corosync_conf => method(:get_corosync_conf_remote), :set_cluster_conf => method(:set_cluster_conf), :set_corosync_conf => method(:set_corosync_conf), :get_sync_capabilities => method(:get_sync_capabilities), :set_sync_options => method(:set_sync_options), :get_configs => method(:get_configs), :set_configs => method(:set_configs), :set_certs => method(:set_certs), :pcsd_restart => method(:remote_pcsd_restart), :get_permissions => method(:get_permissions_remote), :set_permissions => method(:set_permissions_remote), :cluster_start => method(:cluster_start), :cluster_stop => method(:cluster_stop), :config_backup => method(:config_backup), :config_restore => method(:config_restore), :node_restart => method(:node_restart), :node_standby => method(:node_standby), :node_unstandby => method(:node_unstandby), :cluster_enable => method(:cluster_enable), :cluster_disable => method(:cluster_disable), :resource_status => method(:resource_status), :get_sw_versions => method(:get_sw_versions), :node_available => method(:remote_node_available), :add_node_all => lambda { |params_, request_, session_| remote_add_node(params_, request_, session_, true) }, :add_node => lambda { |params_, request_, session_| remote_add_node(params_, request_, session_, false) }, :remove_nodes => method(:remote_remove_nodes), :remove_node => method(:remote_remove_node), :cluster_destroy => method(:cluster_destroy), :get_wizard => method(:get_wizard), :wizard_submit => method(:wizard_submit), :get_tokens => method(:get_tokens), :get_cluster_tokens => method(:get_cluster_tokens), :save_tokens => method(:save_tokens), :get_cluster_properties_definition => method(:get_cluster_properties_definition) } remote_cmd_with_pacemaker = { :resource_start => method(:resource_start), :resource_stop => method(:resource_stop), :resource_cleanup => method(:resource_cleanup), :resource_form => method(:resource_form), :fence_device_form => method(:fence_device_form), :update_resource => method(:update_resource), :update_fence_device => method(:update_fence_device), :resource_metadata => method(:resource_metadata), :fence_device_metadata => method(:fence_device_metadata), :get_avail_resource_agents => method(:get_avail_resource_agents), :get_avail_fence_agents => method(:get_avail_fence_agents), :remove_resource => method(:remove_resource), :add_constraint_remote => method(:add_constraint_remote), :add_constraint_rule_remote => method(:add_constraint_rule_remote), :add_constraint_set_remote => method(:add_constraint_set_remote), :remove_constraint_remote => method(:remove_constraint_remote), :remove_constraint_rule_remote => method(:remove_constraint_rule_remote), :add_meta_attr_remote => method(:add_meta_attr_remote), :add_group => method(:add_group), :update_cluster_settings => method(:update_cluster_settings), :add_fence_level_remote => method(:add_fence_level_remote), :add_node_attr_remote => method(:add_node_attr_remote), :add_acl_role => method(:add_acl_role_remote), :remove_acl_roles => method(:remove_acl_roles_remote), :add_acl => method(:add_acl_remote), :remove_acl => method(:remove_acl_remote), :resource_change_group => method(:resource_change_group), :resource_master => method(:resource_master), :resource_clone => method(:resource_clone), :resource_unclone => method(:resource_unclone), :resource_ungroup => method(:resource_ungroup), :set_resource_utilization => method(:set_resource_utilization), :set_node_utilization => method(:set_node_utilization) } command = params[:command].to_sym if remote_cmd_without_pacemaker.include? command return remote_cmd_without_pacemaker[command].call(params, request, session) elsif remote_cmd_with_pacemaker.include? command if pacemaker_running? return remote_cmd_with_pacemaker[command].call(params, request, session) else return [200,'{""pacemaker_not_running"":true}'] end else return [404, ""Unknown Request""] end end",True,Ruby,remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def user_menu_bookmarks if !current_user.username_equals_to?(params[:username]) raise Discourse::InvalidAccess.new(""username doesn't match current_user's username"") end reminder_notifications = Notification .for_user_menu(current_user.id, limit: USER_MENU_LIST_LIMIT) .unread .where(notification_type: Notification.types[:bookmark_reminder]) if reminder_notifications.size < USER_MENU_LIST_LIMIT exclude_bookmark_ids = reminder_notifications.filter_map { |notification| notification.data_hash[:bookmark_id] } bookmark_list = UserBookmarkList.new( user: current_user, guardian: guardian, per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size, ) bookmark_list.load do |query| if exclude_bookmark_ids.present? query.where(""bookmarks.id NOT IN (?)"", exclude_bookmark_ids) end end end if reminder_notifications.present? serialized_notifications = ActiveModel::ArraySerializer.new( reminder_notifications, each_serializer: NotificationSerializer, scope: guardian, ) end if bookmark_list bookmark_list.bookmark_serializer_opts = { link_to_first_unread_post: true } serialized_bookmarks = serialize_data(bookmark_list, UserBookmarkListSerializer, scope: guardian, root: false)[ :bookmarks ] end render json: { notifications: serialized_notifications || [], bookmarks: serialized_bookmarks || [], } end"
2225,"def config_restore(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'config_restore', true, {:tarball => params[:tarball]} ) else if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end $logger.info ""Restore node configuration"" if params[:tarball] != nil and params[:tarball] != """" out = """" errout = """" status = Open4::popen4(PCS, ""config"", ""restore"", ""--local"") { |pid, stdin, stdout, stderr| stdin.print(params[:tarball]) stdin.close() out = stdout.readlines() errout = stderr.readlines() } retval = status.exitstatus if retval == 0 $logger.info ""Restore successful"" return ""Succeeded"" else $logger.info ""Error during restore: #{errout.join(' ').strip()}"" return errout.length > 0 ? errout.join(' ').strip() : ""Error"" end else $logger.info ""Error: Invalid tarball"" return ""Error: Invalid tarball"" end end end",True,Ruby,config_restore,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def bookmarks user = fetch_user_from_params guardian.ensure_can_edit!(user) user_guardian = Guardian.new(user) respond_to do |format| format.json do bookmark_list = UserBookmarkList.new( user: user, guardian: guardian, search_term: params[:q], page: params[:page], per_page: fetch_limit_from_params(default: nil, max: BOOKMARKS_LIMIT), ) bookmark_list.load if bookmark_list.bookmarks.empty? render json: { bookmarks: [] } else page = params[:page].to_i + 1 bookmark_list.more_bookmarks_url = ""#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}"" render_serialized(bookmark_list, UserBookmarkListSerializer) end end format.ics do @bookmark_reminders = Bookmark .with_reminders .where(user_id: user.id) .order(:reminder_at) .map do |bookmark| bookmark.registered_bookmarkable.serializer.new( bookmark, scope: user_guardian, root: false, ) end end end end"
2227,"def add_meta_attr_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end retval = add_meta_attr( session, params[""res_id""], params[""key""],params[""value""] ) if retval == 0 return [200, ""Successfully added meta attribute""] else return [400, ""Error adding meta attribute""] end end",True,Ruby,add_meta_attr_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def search_users term = params[:term].to_s.strip topic_id = params[:topic_id].to_i if params[:topic_id].present? category_id = params[:category_id].to_i if params[:category_id].present? topic_allowed_users = params[:topic_allowed_users] || false group_names = params[:groups] || [] group_names << params[:group] if params[:group] @groups = Group.where(name: group_names) if group_names.present? options = { topic_allowed_users: topic_allowed_users, searching_user: current_user, groups: @groups, } options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast( params[:include_staged_users], ) options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users]) if limit = fetch_limit_from_params(default: nil, max: SEARCH_USERS_LIMIT) options[:limit] = limit end options[:topic_id] = topic_id if topic_id options[:category_id] = category_id if category_id results = UserSearch.new(term, options).search to_render = serialize_found_users(results) # blank term is only handy for in-topic search of users after @ # we do not want group results ever if term is blank groups = if term.present? && current_user if params[:include_groups] == ""true"" Group.visible_groups(current_user) elsif params[:include_mentionable_groups] == ""true"" Group.mentionable(current_user) elsif params[:include_messageable_groups] == ""true"" Group.messageable(current_user) end end if groups DiscoursePluginRegistry .groups_callback_for_users_search_controller_action .each do |param_name, block| groups = block.call(groups, current_user) if params[param_name.to_s] end # the plugin registry callbacks above are only evaluated when a param # is present matching the name of the callback. Any modifier registered using # register_modifier(:groups_for_users_search) will be evaluated without needing the # param. groups = DiscoursePluginRegistry.apply_modifier(:groups_for_users_search, groups) groups = Group.search_groups(term, groups: groups, sort: :auto) to_render[:groups] = groups.map { |m| { name: m.name, full_name: m.full_name } } end render json: to_render end"
2230,"def resource_master(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:resource_id] return [400, 'resource_id has to be specified.'] end _, stderr, retval = run_cmd( session, PCS, 'resource', 'master', params[:resource_id] ) if retval != 0 return [400, 'Unable to create master/slave resource from ' + ""'#{params[:resource_id]}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,resource_master,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def initialize(user:, guardian:, search_term: nil, per_page: nil, page: 0) @user = user @guardian = guardian @per_page = per_page || PER_PAGE @per_page = PER_PAGE if @per_page > PER_PAGE @search_term = search_term @page = page.to_i @bookmarks = [] @bookmark_serializer_opts = {} end"
2234,"def set_configs(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end return JSON.generate({'status' => 'bad_json'}) if not params['configs'] begin configs_json = JSON.parse(params['configs']) rescue JSON::ParserError return JSON.generate({'status' => 'bad_json'}) end has_cluster = !($cluster_name == nil or $cluster_name.empty?) if has_cluster and $cluster_name != configs_json['cluster_name'] return JSON.generate({'status' => 'wrong_cluster_name'}) end $semaphore_cfgsync.synchronize { force = configs_json['force'] remote_configs, unknown_cfg_names = Cfgsync::sync_msg_to_configs(configs_json) local_configs = Cfgsync::get_configs_local result = {} unknown_cfg_names.each { |name| result[name] = 'not_supported' } remote_configs.each { |name, remote_cfg| begin # Save a remote config if it is a newer version than local. If the config # is not present on a local node, the node is beeing added to a cluster, # so we need to save the config as well. if force or not local_configs.key?(name) or remote_cfg > local_configs[name] local_configs[name].class.backup() if local_configs.key?(name) remote_cfg.save() result[name] = 'accepted' elsif remote_cfg == local_configs[name] # Someone wants this node to have a config that it already has. # So the desired state is met and the result is a success then. result[name] = 'accepted' else result[name] = 'rejected' end rescue => e $logger.error(""Error saving config '#{name}': #{e}"") result[name] = 'error' end } return JSON.generate({'status' => 'ok', 'result' => result}) } end",True,Ruby,set_configs,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def load(&blk) query = BookmarkQuery.new( user: @user, guardian: @guardian, search_term: @search_term, page: @page, per_page: @per_page, ) @bookmarks = query.list_all(&blk) @has_more = (@page.to_i + 1) * @per_page < query.count @bookmarks end"
2235,"def cluster_status_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end cluster_name = $cluster_name # If node is not in a cluster, return empty data if not cluster_name or cluster_name.empty? overview = { :cluster_name => nil, :error_list => [], :warning_list => [], :quorate => nil, :status => 'unknown', :node_list => [], :resource_list => [], } return JSON.generate(overview) end cluster_nodes = get_nodes().flatten status = cluster_status_from_nodes(session, cluster_nodes, cluster_name) unless status return 403, 'Permission denied' end return JSON.generate(status) end",True,Ruby,cluster_status_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def list_all(&blk) ts_query = @search_term.present? ? Search.ts_query(term: @search_term) : nil search_term_wildcard = @search_term.present? ? ""%#{@search_term}%"" : nil queries = Bookmark .registered_bookmarkables .map do |bookmarkable| interim_results = bookmarkable.perform_list_query(@user, @guardian) # this could occur if there is some security reason that the user cannot # access the bookmarkables that they have bookmarked, e.g. if they had 1 bookmark # on a topic and that topic was moved into a private category next if interim_results.blank? if @search_term.present? interim_results = bookmarkable.perform_search_query(interim_results, search_term_wildcard, ts_query) end # this is purely to make the query easy to read and debug, otherwise it's # all mashed up into a massive ball in MiniProfiler :) ""---- #{bookmarkable.model.to_s} bookmarkable ---\n\n #{interim_results.to_sql}"" end .compact # same for interim results being blank, the user might have been locked out # from all their various bookmarks, in which case they will see nothing and # no further pagination/ordering/etc is required return [] if queries.empty? union_sql = queries.join(""\n\nUNION\n\n"") results = Bookmark.select(""bookmarks.*"").from(""(\n\n#{union_sql}\n\n) as bookmarks"") results = results.order( ""(CASE WHEN bookmarks.pinned THEN 0 ELSE 1 END), bookmarks.reminder_at ASC, bookmarks.updated_at DESC"", ) @count = results.count results = results.offset(@page * @per_page) if @page.positive? if updated_results = blk&.call(results) results = updated_results end results = results.limit(@per_page).to_a BookmarkQuery.preload(results, self) results end"
2237,"def resource_status(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end resource_id = params[:resource] @resources,@groups = getResourcesGroups(session) location = """" res_status = """" @resources.each {|r| if r.id == resource_id if r.failed res_status = ""Failed"" elsif !r.active res_status = ""Inactive"" else res_status = ""Running"" end if r.nodes.length != 0 location = r.nodes[0].name break end end } status = {""location"" => location, ""status"" => res_status} return JSON.generate(status) end",True,Ruby,resource_status,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def initialize(user:, guardian: nil, search_term: nil, page: nil, per_page: nil) @user = user @search_term = search_term @guardian = guardian || Guardian.new(@user) @page = page ? page.to_i : 0 @per_page = per_page ? per_page.to_i : 20 @count = 0 end"
2239,"def setup_cluster(params, request, session) if not allowed_for_superuser(session) return 403, 'Permission denied' end $logger.info(""Setting up cluster: "" + params.inspect) nodes_rrp = params[:nodes].split(';') options = [] myoptions = JSON.parse(params[:options]) transport_udp = false options_udp = [] myoptions.each { |o,v| if [""wait_for_all"", ""last_man_standing"", ""auto_tie_breaker""].include?(o) options << ""--"" + o + ""=1"" end options << ""--"" + o + ""="" + v if [ ""token"", ""token_coefficient"", ""join"", ""consensus"", ""miss_count_const"", ""fail_recv_const"", ""last_man_standing_window"", ].include?(o) if o == ""transport"" and v == ""udp"" options << ""--transport=udp"" transport_udp = true end if o == ""transport"" and v == ""udpu"" options << ""--transport=udpu"" transport_udp = false end if [""addr0"", ""addr1"", ""mcast0"", ""mcast1"", ""mcastport0"", ""mcastport1"", ""ttl0"", ""ttl1""].include?(o) options_udp << ""--"" + o + ""="" + v end if [""broadcast0"", ""broadcast1""].include?(o) options_udp << ""--"" + o end if o == ""ipv6"" options << ""--ipv6"" end } if transport_udp nodes = [] nodes_rrp.each { |node| nodes << node.split(',')[0] } else nodes = nodes_rrp end nodes_options = nodes + options nodes_options += options_udp if transport_udp stdout, stderr, retval = run_cmd( session, PCS, ""cluster"", ""setup"", ""--enable"", ""--start"", ""--name"", params[:clustername], *nodes_options ) if retval != 0 return [ 400, (stdout + [''] + stderr).collect { |line| line.rstrip() }.join(""\n"") ] end return 200 end",True,Ruby,setup_cluster,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def index params.permit(:username, :offset, :limit) offset = params[:offset].to_i limit = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT) memberships = Chat::ChannelMembershipsQuery.call( channel: channel_from_params, offset: offset, limit: limit, username: params[:username], ) render_serialized( memberships, Chat::UserChannelMembershipSerializer, root: ""memberships"", meta: { total_rows: channel_from_params.user_count, load_more_url: ""/chat/api/channels/#{channel_from_params.id}/memberships?offset=#{offset + limit}&limit=#{limit}&username=#{params[:username]}"", }, ) end"
2243,"def node_unstandby(params, request, session) if params[:name] code, response = send_request_with_token( session, params[:name], 'node_unstandby', true, {""node""=>params[:name]} ) # data={""node""=>params[:name]} for backward compatibility with older versions of pcs/pcsd else if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end $logger.info ""Unstandby Node"" stdout, stderr, retval = run_cmd(session, PCS, ""cluster"", ""unstandby"") return stdout end end",True,Ruby,node_unstandby,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""is respected"" do expect(bookmark_query(per_page: 1).list_all.count).to eq(1) end"
2244,"def get_avail_fence_agents(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end agents = getFenceAgents(session) return JSON.generate(agents) end",True,Ruby,get_avail_fence_agents,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can search by post content"" do bookmarks = bookmark_query(search_term: ""content"").list_all expect(bookmarks.map(&:id)).to eq([bookmark4.id]) end"
2246,"def set_node_utilization(params, reqest, session) unless allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end unless params[:node] and params[:name] return 400, 'node and name are required' end node = params[:node] name = params[:name] value = params[:value] || '' _, stderr, retval = run_cmd( session, PCS, 'node', 'utilization', node, ""#{name}=#{value}"" ) if retval != 0 return [400, ""Unable to set utilization '#{name}=#{value}' for node "" + ""'#{res_id}': #{stderr.join('')}"" ] end return 200 end",True,Ruby,set_node_utilization,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can search by topic title"" do bookmarks = bookmark_query(search_term: ""bugfix"").list_all expect(bookmarks.map(&:id)).to eq([bookmark4.id]) end"
2247,"def check_auth(params, request, session) if params.include?(""check_auth_only"") return [200, ""{\""success\"":true}""] end return JSON.generate({ 'success' => true, 'node_list' => get_token_node_list, }) end",True,Ruby,check_auth,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""can search by bookmark name"" do bookmarks = bookmark_query(search_term: ""check"").list_all expect(bookmarks.map(&:id)).to eq([bookmark3.id]) end"
2252,"def get_quorum_info(params, request, session) if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end if ISRHEL6 stdout_status, stderr_status, retval = run_cmd( PCSAuth.getSuperuserSession, CMAN_TOOL, ""status"" ) stdout_nodes, stderr_nodes, retval = run_cmd( PCSAuth.getSuperuserSession, CMAN_TOOL, ""nodes"", ""-F"", ""id,type,votes,name"" ) if stderr_status.length > 0 return stderr_status.join elsif stderr_nodes.length > 0 return stderr_nodes.join else return stdout_status.join + ""\n---Votes---\n"" + stdout_nodes.join end else stdout, stderr, retval = run_cmd( PCSAuth.getSuperuserSession, COROSYNC_QUORUMTOOL, ""-p"", ""-s"" ) # retval is 0 on success if node is not in partition with quorum # retval is 1 on error OR on success if node has quorum if stderr.length > 0 return stderr.join else return stdout.join end end end",True,Ruby,get_quorum_info,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""allows searching bookmarkables by fields in other tables"" do bookmarks = bookmark_query(search_term: ""bookmarkk"").list_all expect(bookmarks.map(&:id)).to eq([bookmark5.id]) end"
2253,"def update_cluster_settings(params, request, session) properties = params['config'] to_update = [] current = getAllSettings(session) # We need to be able to set cluster properties also from older version GUI. # This code handles proper processing of checkboxes. # === backward compatibility layer start === params['hidden'].each { |prop, val| next if prop == 'hidden_input' unless properties.include?(prop) properties[prop] = val to_update << prop end } # === backward compatibility layer end === properties.each { |prop, val| val.strip! if not current.include?(prop) and val != '' # add to_update << prop elsif current.include?(prop) and val == '' # remove to_update << prop elsif current.include?(prop) and current[prop] != val # update to_update << prop end } if to_update.count { |x| x.downcase == 'enable-acl' } > 0 if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end end if to_update.count { |x| x.downcase != 'enable-acl' } > 0 if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end end if to_update.empty? $logger.info('No properties to update') else cmd_args = [] to_update.each { |prop| cmd_args << ""#{prop.downcase}=#{properties[prop]}"" } stdout, stderr, retval = run_cmd(session, PCS, 'property', 'set', *cmd_args) if retval != 0 return [400, stderr.join('').gsub(', (use --force to override)', '')] end end return [200, ""Update Successful""] end",True,Ruby,update_cluster_settings,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def bookmark_query(user: nil, search_term: nil, per_page: nil) BookmarkQuery.new(user: user || self.user, search_term:, per_page:) end"
2255,"def cluster_destroy(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end out, errout, retval = run_cmd(session, PCS, ""cluster"", ""destroy"") if retval == 0 return [200, ""Successfully destroyed cluster""] else return [400, ""Error destroying cluster:\n#{out}\n#{errout}\n#{retval}\n""] end end",True,Ruby,cluster_destroy,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""has a clean protocol for ownership handover"" do sign_in(user) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { a: ""test"" }.to_json, owner: ""abcdefg"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(0) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { b: ""test"" }.to_json, owner: ""hijklmnop"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(1) expect(DraftSequence.current(user, ""abc"")).to eq(1) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 1, data: { c: ""test"" }.to_json, owner: ""hijklmnop"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(2) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 2, data: { c: ""test"" }.to_json, owner: ""abc"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(3) end"
2259,"def node_status(params, request, session) if params[:node] and params[:node] != '' and params[:node] != $cur_node_name and !params[:redirected] return send_request_with_token( session, params[:node], 'status?redirected=1', false, params.select { |k,_| [:version, :operations].include?(k) } ) end if not allowed_for_local_cluster(session, Permissions::READ) return 403, 'Permission denied' end cib_dom = get_cib_dom(session) crm_dom = get_crm_mon_dom(session) status = get_node_status(session, cib_dom) resources = get_resources( cib_dom, crm_dom, (params[:operations] and params[:operations] == '1') ) node = ClusterEntity::Node.load_current_node(session, crm_dom) _,_,not_authorized_nodes = check_gui_status_of_nodes( session, status[:known_nodes], false, 3 ) if not_authorized_nodes.length > 0 node.warning_list << { :message => 'Not authorized against node(s) ' + not_authorized_nodes.join(', '), :type => 'nodes_not_authorized', :node_list => not_authorized_nodes, } end version = params[:version] || '1' if version == '2' status[:node] = node.to_status(version) resource_list = nil if resources resource_list = [] resources.each do |r| resource_list << r.to_status(version) end end status[:resource_list] = resource_list return JSON.generate(status) end resource_list = [] resources.each do |r| resource_list.concat(r.to_status('1')) end cluster_settings = (status[:cluster_settings].empty?) ? {'error' => 'Unable to get configuration settings'} : status[:cluster_settings] node_attr = {} status[:node_attr].each { |node, attrs| node_attr[node] = [] attrs.each { |attr| node_attr[node] << { :key => attr[:name], :value => attr[:value] } } } old_status = { :uptime => node.uptime, :corosync => node.corosync, :pacemaker => node.pacemaker, :cman => node.cman, :corosync_enabled => node.corosync_enabled, :pacemaker_enabled => node.pacemaker_enabled, :pcsd_enabled => node.pcsd_enabled, :corosync_online => status[:corosync_online], :corosync_offline => status[:corosync_offline], :pacemaker_online => status[:pacemaker_online], :pacemaker_offline => status[:pacemaker_offline], :pacemaker_standby => status[:pacemaker_standby], :cluster_name => status[:cluster_name], :resources => resource_list, :groups => status[:groups], :constraints => status[:constraints], :cluster_settings => cluster_settings, :node_id => node.id, :node_attr => node_attr, :fence_levels => status[:fence_levels], :need_ring1_address => status[:need_ring1_address], :is_cman_with_udpu_transport => status[:is_cman_with_udpu_transport], :acls => status[:acls], :username => status[:username] } return JSON.generate(old_status) end",True,Ruby,node_status,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""destroys drafts when required"" do sign_in(user) Draft.set(user, ""xxx"", 0, ""hi"") delete ""/drafts/xxx.json"", params: { sequence: 0 } expect(response.status).to eq(200) expect(Draft.get(user, ""xxx"", 0)).to eq(nil) end"
2260,"def resource_cleanup(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( session, PCS, ""resource"", ""cleanup"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end",True,Ruby,resource_cleanup,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""returns a draft if requested"" do sign_in(user) Draft.set(user, ""hello"", 0, ""test"") get ""/drafts/hello.json"" expect(response.status).to eq(200) expect(response.parsed_body[""draft""]).to eq(""test"") end"
2262,"def add_acl_role_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end retval = add_acl_role(session, params[""name""], params[""description""]) if retval == """" return [200, ""Successfully added ACL role""] else return [ 400, retval.include?(""cib_replace failed"") ? ""Error adding ACL role"" : retval ] end end",True,Ruby,add_acl_role_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""has empty stream after deleting last draft"" do sign_in(user) Draft.set(user, ""xxx"", 0, ""{}"") Draft.clear(user, ""xxx"", 0) get ""/drafts.json"" expect(response.status).to eq(200) expect(response.parsed_body[""drafts""].length).to eq(0) end"
2266,"def set_corosync_conf(params, request, session) if not allowed_for_local_cluster(session, Permissions::FULL) return 403, 'Permission denied' end if params[:corosync_conf] != nil and params[:corosync_conf].strip != """" Cfgsync::CorosyncConf.backup() Cfgsync::CorosyncConf.from_text(params[:corosync_conf]).save() return 200, ""Succeeded"" else $logger.info ""Invalid corosync.conf file"" return 400, ""Failed"" end end",True,Ruby,set_corosync_conf,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""raises an error for out-of-sequence draft setting"" do sign_in(user) seq = DraftSequence.next!(user, ""abc"") Draft.set(user, ""abc"", seq, { b: ""test"" }.to_json) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: seq - 1, data: { a: ""test"" }.to_json, } expect(response.status).to eq(409) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: seq + 1, data: { a: ""test"" }.to_json, } expect(response.status).to eq(409) end"
2267,"def set_permissions_remote(params, request, session) if not allowed_for_local_cluster(session, Permissions::GRANT) return 403, 'Permission denied' end begin data = JSON.parse(params['json_data']) rescue JSON::ParserError return 400, JSON.generate({'status' => 'bad_json'}) end user_set = {} perm_list = [] full_users_new = Set.new perm_deps = Permissions.permissions_dependencies if data['permissions'] data['permissions'].each { |key, perm| name = (perm['name'] || '').strip type = (perm['type'] || '').strip return [400, 'Missing user name'] if '' == name return [400, 'Missing user type'] if '' == type if not Permissions::is_user_type(type) return [400, ""Unknown user type '#{type}'""] end if user_set.key?([name, type]) return [400, ""Duplicate permissions for #{type} #{name}""] end user_set[[name, type]] = true allow = [] if perm['allow'] perm['allow'].each { |perm_allow, enabled| next if ""1"" != enabled if not Permissions::is_permission_type(perm_allow) return [400, ""Unknown permission '#{perm_allow}'""] end if Permissions::FULL == perm_allow full_users_new << [type, name] end allow << perm_allow # Explicitly save dependant permissions. That way if the dependency is # changed in the future it won't revoke permissions which were once # granted. if perm_deps['also_allows'] and perm_deps['also_allows'][perm_allow] allow += perm_deps['also_allows'][perm_allow] end } end perm_list << Permissions::EntityPermissions.new(type, name, allow.uniq()) } end perm_set = Permissions::PermissionsSet.new(perm_list) full_users_old = Set.new pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.permissions_local.entity_permissions_list.each{ |entity_perm| if entity_perm.allow_list.include?(Permissions::FULL) full_users_old << [entity_perm.type, entity_perm.name] end } if full_users_new != full_users_old label = 'Full' Permissions.get_permission_types.each { |perm_type| if Permissions::FULL == perm_type['code'] label = perm_type['label'] break end } if not allowed_for_local_cluster(session, Permissions::FULL) return [ 403, ""Permission denied\nOnly #{SUPERUSER} and users with #{label} ""\ + ""permission can grant or revoke #{label} permission."" ] end end 2.times { pcs_config = PCSConfig.new(Cfgsync::PcsdSettings.from_file('{}').text()) pcs_config.permissions_local = perm_set sync_config = Cfgsync::PcsdSettings.from_text(pcs_config.text()) pushed, _ = Cfgsync::save_sync_new_version( sync_config, get_corosync_nodes(), $cluster_name, true ) return [200, 'Permissions saved'] if pushed } return 400, 'Unable to save permissions' end",True,Ruby,set_permissions_remote,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""cant trivially resolve conflicts without interaction"" do sign_in(user) DraftSequence.next!(user, ""abc"") post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { a: ""test"" }.to_json, owner: ""abcdefg"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(1) end"
2268,"def resource_stop(params, request, session) if not allowed_for_local_cluster(session, Permissions::WRITE) return 403, 'Permission denied' end stdout, stderr, retval = run_cmd( session, PCS, ""resource"", ""disable"", params[:resource] ) if retval == 0 return JSON.generate({""success"" => ""true""}) else return JSON.generate({""error"" => ""true"", ""stdout"" => stdout, ""stderror"" => stderr}) end end",True,Ruby,resource_stop,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""saves a draft"" do sign_in(user) post ""/drafts.json"", params: { draft_key: ""xyz"", data: { my: ""data"" }.to_json, sequence: 0 } expect(response.status).to eq(200) expect(Draft.get(user, ""xyz"", 0)).to eq(%q({""my"":""data""})) end"
2271,"def create_cluster(params, request, session) if not allowed_for_superuser(session) return 403, 'Permission denied' end if set_corosync_conf(params, request, session) cluster_start(params, request, session) else return ""Failed"" end end",True,Ruby,create_cluster,remote.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""returns correct stream length after adding a draft"" do sign_in(user) Draft.set(user, ""xxx"", 0, ""{}"") get ""/drafts.json"" expect(response.status).to eq(200) parsed = response.parsed_body expect(response.parsed_body[""drafts""].length).to eq(1) end"
2273,"def getResourcesGroups(session, get_fence_devices = false, get_all_options = false, get_operations=false ) stdout, stderror, retval = run_cmd( session, CRM_MON, ""--one-shot"", ""-r"", ""--as-xml"" ) if retval != 0 return [],[], retval end crm_output = stdout doc = REXML::Document.new(crm_output.join(""\n"")) resource_list = [] group_list = [] doc.elements.each('crm_mon/resources/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e)) else !get_fence_devices && resource_list.push(Resource.new(e)) end end doc.elements.each('crm_mon/resources/group/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e,e.parent.attributes[""id""])) else !get_fence_devices && resource_list.push(Resource.new(e,e.parent.attributes[""id""])) end end doc.elements.each('crm_mon/resources/clone/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e)) else ms = false if e.parent.attributes[""multi_state""] == ""true"" ms = true end !get_fence_devices && resource_list.push(Resource.new(e, nil, !ms, ms)) end end doc.elements.each('crm_mon/resources/clone/group/resource') do |e| if e.attributes[""resource_agent""] && e.attributes[""resource_agent""].index('stonith:') == 0 get_fence_devices && resource_list.push(Resource.new(e,e.parent.parent.attributes[""id""] + ""/"" + e.parent.attributes[""id""])) else ms = false if e.parent.parent.attributes[""multi_state""] == ""true"" ms = true end !get_fence_devices && resource_list.push(Resource.new(e,e.parent.parent.attributes[""id""] + ""/"" + e.parent.attributes[""id""],!ms, ms)) end end doc.elements.each('crm_mon/resources/group') do |e| group_list.push(e.attributes[""id""]) end resource_list = resource_list.select { |x| not x.orphaned } resource_list = resource_list.sort_by{|a| (a.group ? ""1"" : ""0"").to_s + a.group.to_s + ""-"" + a.id} if get_all_options or get_operations stdout, stderror, retval = run_cmd(session, ""cibadmin"", ""-Q"", ""-l"") cib_output = stdout resources_inst_attr_map = {} resources_meta_attr_map = {} resources_operation_map = {} begin doc = REXML::Document.new(cib_output.join(""\n"")) if get_all_options doc.elements.each('//primitive') do |r| resources_inst_attr_map[r.attributes[""id""]] = {} resources_meta_attr_map[r.attributes[""id""]] = {} r.each_recursive do |ia| if ia.node_type == :element and ia.name == ""nvpair"" if ia.parent.name == ""instance_attributes"" resources_inst_attr_map[r.attributes[""id""]][ia.attributes[""name""]] = ia.attributes[""value""] elsif ia.parent.name == ""meta_attributes"" resources_meta_attr_map[r.attributes[""id""]][ia.attributes[""name""]] = [ia.attributes[""id""],ia.attributes[""value""],ia.parent.parent.attributes[""id""]] end end if [""group"",""clone"",""master""].include?(r.parent.name) r.parent.elements.each('./meta_attributes/nvpair') do |ma| resources_meta_attr_map[r.attributes[""id""]][ma.attributes[""name""]] ||= [] resources_meta_attr_map[r.attributes[""id""]][ma.attributes[""name""]] = [ma.attributes[""id""],ma.attributes[""value""],ma.parent.parent.attributes[""id""]] end end end end resource_list.each {|r| r.options = resources_inst_attr_map[r.id] r.instance_attr = resources_inst_attr_map[r.id] r.meta_attr = resources_meta_attr_map[r.id] } end if get_operations doc.elements.each('//lrm_rsc_op') { |rsc_op| resources_operation_map[rsc_op.parent.attributes['id']] ||= [] resources_operation_map[rsc_op.parent.attributes['id']] << ( ResourceOperation.new(rsc_op) ) } resource_list.each {|r| if resources_operation_map[r.id] r.operations = resources_operation_map[r.id].sort { |a, b| a.call_id <=> b.call_id } end } end rescue REXML::ParseException $logger.info(""ERROR: Parse Exception parsing cibadmin -Q"") end end [resource_list, group_list, 0] end",True,Ruby,getResourcesGroups,resource.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"it ""checks for an conflict on update"" do sign_in(user) post = Fabricate(:post, user: user) post ""/drafts.json"", params: { draft_key: ""topic"", sequence: 0, data: { postId: post.id, originalText: post.raw, action: ""edit"" }.to_json, } expect(response.status).to eq(200) expect(response.parsed_body[""conflict_user""]).to eq(nil) post ""/drafts.json"", params: { draft_key: ""topic"", sequence: 0, data: { postId: post.id, originalText: ""something else"", action: ""edit"" }.to_json, } expect(response.status).to eq(200) expect(response.parsed_body[""conflict_user""][""id""]).to eq(post.last_editor.id) expect(response.parsed_body[""conflict_user""]).to include(""avatar_template"") end"
2274,"def getResourceMetadata(session, resourcepath) options_required = {} options_optional = {} long_desc = """" short_desc = """" resourcepath = Pathname.new(resourcepath).cleanpath.to_s resource_dirs = [ HEARTBEAT_AGENTS_DIR, PACEMAKER_AGENTS_DIR, NAGIOS_METADATA_DIR, ] if not resource_dirs.any? { |allowed| resourcepath.start_with?(allowed) } $logger.error( ""Unable to get metadata of resource agent '#{resourcepath}': "" + 'path not allowed' ) return [options_required, options_optional, [short_desc, long_desc]] end if resourcepath.end_with?('.xml') begin metadata = IO.read(resourcepath) rescue metadata = """" end else ENV['OCF_ROOT'] = OCF_ROOT stdout, stderr, retval = run_cmd(session, resourcepath, 'meta-data') metadata = stdout.join end begin doc = REXML::Document.new(metadata) rescue REXML::ParseException => e $logger.error( ""Unable to parse metadata of resource agent '#{resourcepath}': #{e}"" ) return [options_required, options_optional, [short_desc, long_desc]] end doc.elements.each('resource-agent/longdesc') {|ld| long_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/shortdesc') {|ld| short_desc = ld.text ? ld.text.strip : ld.text } doc.elements.each('resource-agent/parameters/parameter') { |param| temp_array = [] if param.attributes[""required""] == ""1"" if param.elements[""shortdesc""] and param.elements[""shortdesc""].text temp_array << param.elements[""shortdesc""].text.strip else temp_array << """" end if param.elements[""longdesc""] and param.elements[""longdesc""].text temp_array << param.elements[""longdesc""].text.strip else temp_array << """" end options_required[param.attributes[""name""]] = temp_array else if param.elements[""shortdesc""] and param.elements[""shortdesc""].text temp_array << param.elements[""shortdesc""].text.strip else temp_array << """" end if param.elements[""longdesc""] and param.elements[""longdesc""].text temp_array << param.elements[""longdesc""].text.strip else temp_array << """" end options_optional[param.attributes[""name""]] = temp_array end } [options_required, options_optional, [short_desc, long_desc]] end",True,Ruby,getResourceMetadata,resource.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def run_serializer bookmark_list = UserBookmarkList.new(user: user, guardian: Guardian.new(user)) bookmark_list.load UserBookmarkListSerializer.new(bookmark_list) end"
2275,"def getResourceAgents(session) resource_agent_list = {} stdout, stderr, retval = run_cmd(session, PCS, ""resource"", ""list"", ""--nodesc"") if retval != 0 $logger.error(""Error running 'pcs resource list --nodesc"") $logger.error(stdout + stderr) return {} end agents = stdout agents.each { |a| ra = ResourceAgent.new ra.name = a.chomp resource_agent_list[ra.name] = ra } return resource_agent_list end",True,Ruby,getResourceAgents,resource.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def perform_accept_invitation params.require(:id) params.permit( :email, :username, :name, :password, :timezone, :email_token, user_custom_fields: { }, ) invite = Invite.find_by(invite_key: params[:id]) redeeming_user = current_user if invite.present? begin attrs = { ip_address: request.remote_ip, session: session } if redeeming_user attrs[:redeeming_user] = redeeming_user else attrs[:username] = params[:username] attrs[:name] = params[:name] attrs[:password] = params[:password] attrs[:user_custom_fields] = params[:user_custom_fields] # If the invite is not scoped to an email then we allow the # user to provide it themselves if invite.is_invite_link? params.require(:email) attrs[:email] = params[:email] else # Otherwise we always use the email from the invitation. attrs[:email] = invite.email attrs[:email_token] = params[:email_token] if params[:email_token].present? end end user = invite.redeem(**attrs) rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, ActiveRecord::LockWaitTimeout, Invite::UserExists => e return render json: failed_json.merge(message: e.message), status: 412 end if user.blank? return render json: failed_json.merge(message: I18n.t(""invite.not_found_json"")), status: 404 end log_on_user(user) if !redeeming_user && user.active? && user.guardian.can_access_forum? user.update_timezone_if_missing(params[:timezone]) post_process_invite(user) create_topic_invite_notifications(invite, user) topic = invite.topics.first response = {} if user.present? if user.active? && user.guardian.can_access_forum? response[:message] = I18n.t(""invite.existing_user_success"") if redeeming_user if user.guardian.can_see?(topic) response[:redirect_to] = path(topic.relative_url) else response[:redirect_to] = path(""/"") end else response[:message] = if user.active? I18n.t(""activation.approval_required"") else I18n.t(""invite.confirm_email"") end cookies[:destination_url] = path(topic.relative_url) if user.guardian.can_see?(topic) end end render json: success_json.merge(response) else render json: failed_json.merge(message: I18n.t(""invite.not_found_json"")), status: 404 end"
2279,"def testLoginByToken users = [] users << {""username"" => ""user1"", ""token"" => ""token1""} users << {""username"" => ""user2"", ""token"" => ""token2""} users << {""username"" => SUPERUSER, ""token"" => ""tokenS""} password_file = File.open($user_pass_file, File::RDWR|File::CREAT) password_file.truncate(0) password_file.rewind password_file.write(JSON.pretty_generate(users)) password_file.close() session = {} cookies = {} result = PCSAuth.loginByToken(session, cookies) assert_equal(false, result) assert_equal({}, session) session = {} cookies = {'token' => 'tokenX'} result = PCSAuth.loginByToken(session, cookies) assert_equal(false, result) assert_equal({}, session) session = {} cookies = {'token' => 'token1'} result = PCSAuth.loginByToken(session, cookies) assert_equal(true, result) assert_equal( {:username => 'user1', :usergroups => ['group1', 'haclient']}, session ) session = {} cookies = { 'token' => 'token1', 'CIB_user' => 'userX', 'CIB_user_groups' => PCSAuth.cookieUserEncode('groupX') } result = PCSAuth.loginByToken(session, cookies) assert_equal(true, result) assert_equal( {:username => 'user1', :usergroups => ['group1', 'haclient']}, session ) session = {} cookies = {'token' => 'tokenS'} result = PCSAuth.loginByToken(session, cookies) assert_equal(true, result) assert_equal( {:username => SUPERUSER, :usergroups => []}, session ) session = {} cookies = { 'token' => 'tokenS', 'CIB_user' => 'userX', 'CIB_user_groups' => PCSAuth.cookieUserEncode('groupX') } result = PCSAuth.loginByToken(session, cookies) assert_equal(true, result) assert_equal( {:username => 'userX', :usergroups => ['groupX']}, session ) end",True,Ruby,testLoginByToken,test_auth.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,"web UI auth: decouple auth_user from session

Sessions are processed in web UI part only. Pcsd backend does not work
with sessions so it only gets who is logged in and not the whole session.",CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,"def mark_invite_redeemed @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now) if @invited_user_record.present? invite.with_lock(""FOR UPDATE NOWAIT"") do Invite.increment_counter(:redemption_count, invite.id) invite.save! end delete_duplicate_invites end @invited_user_record.present? end"
2293,"def protected! gui_request = ( # these are URLs for web pages request.path == '/' or request.path == '/manage' or request.path == '/permissions' or request.path.match('/managec/.+/main') ) if request.path.start_with?('/remote/') or request.path == '/run_pcs' @auth_user = PCSAuth.loginByToken(cookies) unless @auth_user halt [401, '{""notauthorized"":""true""}'] end else #/managec/* /manage/* /permissions if !gui_request and request.env['HTTP_X_REQUESTED_WITH'] != 'XMLHttpRequest' then # Accept non GUI requests only with header # ""X_REQUESTED_WITH: XMLHttpRequest"". (check if they are send via AJAX). # This prevents CSRF attack. halt [401, '{""notauthorized"":""true""}'] elsif not PCSAuth.isLoggedIn(session) if gui_request session[:pre_login_path] = request.path redirect '/login' else halt [401, '{""notauthorized"":""true""}'] end end end end",True,Ruby,protected!,pcsd.rb,https://github.com/ClusterLabs/pcs,ClusterLabs,Tomas Jelinek,2016-02-15 15:57:36+01:00,web UI auth: add js/ajax login dialog,CWE-384,Session Fixation,"Authenticating a user, or otherwise establishing a new user session, without invalidating any existing session identifier gives an attacker the opportunity to steal authenticated sessions.",https://cwe.mitre.org/data/definitions/384.html,CVE-2016-0721,def all_tags return @tags if defined?(@tags) tags = topic.visible_tags(scope) # Calling method `pluck` or `order` along with `includes` causing N+1 queries tags = ( if SiteSetting.tags_sort_alphabetically tags.sort_by(&:name) else topic_count_column = Tag.topic_count_column(scope) tags.sort_by { |tag| tag.public_send(topic_count_column) }.reverse end ) @tags = tags end
2301,def self.media_type(filename) extension = ::File.extname(filename) Rack::Mime.mime_type(extension) end,True,Ruby,self.media_type,file_handler.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,"def hijack(info: nil, &blk) controller_class = self.class if hijack = request.env[""rack.hijack""] request.env[""discourse.request_tracker.skip""] = true request_tracker = request.env[""discourse.request_tracker""] # in the past unicorn would recycle env, this is not longer the case env = request.env # rack may clean up tempfiles unless we trick it and take control tempfiles = env[Rack::RACK_TEMPFILES] env[Rack::RACK_TEMPFILES] = nil request_copy = ActionDispatch::Request.new(env) transfer_timings = MethodProfiler.transfer scheduled = Concurrent::Promises.resolvable_event begin Scheduler::Defer.later( ""hijack #{params[""controller""]} #{params[""action""]} #{info}"", force: false, &scheduled.method(:resolve) ) rescue WorkQueue::WorkQueueFull return render plain: """", status: 503 end # duplicate headers so other middleware does not mess with it # on the way down the stack original_headers = response.headers.dup io = hijack.call scheduled.on_resolution! do MethodProfiler.start(transfer_timings) begin Thread.current[Logster::Logger::LOGSTER_ENV] = env # do this first to confirm we have a working connection # before doing any work io.write ""HTTP/1.1 "" # this trick avoids double render, also avoids any litter that the controller hooks # place on the response instance = controller_class.new response = ActionDispatch::Response.new instance.response = response instance.request = request_copy original_headers&.each { |k, v| instance.response.headers[k] = v } view_start = Process.clock_gettime(Process::CLOCK_MONOTONIC) begin instance.instance_eval(&blk) rescue => e # TODO we need to reuse our exception handling in ApplicationController Discourse.warn_exception( e, message: ""Failed to process hijacked response correctly"", env: env, ) end view_runtime = Process.clock_gettime(Process::CLOCK_MONOTONIC) - view_start instance.status = 500 unless instance.response_body || response.committed? response.commit! body = response.body headers = response.headers # add cors if needed if cors_origins = env[Discourse::Cors::ORIGINS_ENV] Discourse::Cors.apply_headers(cors_origins, env, headers) end headers[""Content-Type""] ||= response.content_type || ""text/plain"" headers[""Content-Length""] = body.bytesize headers[""Connection""] = ""close"" headers[""Discourse-Logged-Out""] = ""1"" if env[Auth::DefaultCurrentUserProvider::BAD_TOKEN] status_string = Rack::Utils::HTTP_STATUS_CODES[response.status.to_i] || ""Unknown"" io.write ""#{response.status} #{status_string}\r\n"" timings = MethodProfiler.stop if timings && duration = timings[:total_duration] headers[""X-Runtime""] = ""#{""%0.6f"" % duration}"" end headers.each { |name, val| io.write ""#{name}: #{val}\r\n"" } io.write ""\r\n"" io.write body rescue Errno::EPIPE, IOError # happens if client terminated before we responded, ignore io = nil ensure if Rails.configuration.try(:lograge).try(:enabled) if timings db_runtime = 0 db_runtime = timings[:sql][:duration] if timings[:sql] subscriber = Lograge::LogSubscribers::ActionController.new payload = ActiveSupport::HashWithIndifferentAccess.new( controller: self.class.name, action: action_name, params: request.filtered_parameters, headers: request.headers, format: request.format.ref, method: request.request_method, path: request.fullpath, view_runtime: view_runtime * 1000.0, db_runtime: db_runtime * 1000.0, timings: timings, status: response.status, ) event = ActiveSupport::Notifications::Event.new( ""hijack"", Time.now, Time.now + timings[:total_duration], """", payload, ) subscriber.process_action(event) end end MethodProfiler.clear Thread.current[Logster::Logger::LOGSTER_ENV] = nil begin io.close if io rescue StandardError nil end if request_tracker status = begin response.status rescue StandardError 500 end request_tracker.log_request_info(env, [status, headers || {}, []], timings) end tempfiles&.each(&:close!) end end # not leaked out, we use 418 ... I am a teapot to denote that we are hijacked render plain: """", status: 418 else blk.call end end"
2302,"def self.file_info(path) info = { :body => ::File.read(path), :time => ::File.mtime(path).httpdate } info end",True,Ruby,self.file_info,file_handler.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,def length @queue.size end
2306,"def file_path if @request.path_info.end_with?('/') normalized = @request.path_info + 'index.html' else normalized = @request.path_info end @root = File.join Jekbox::DROPBOX_PATH, @request.host File.join @root, '_site', normalized end",True,Ruby,file_path,server.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,"def initialize @async = !Rails.env.test? @queue = WorkQueue::ThreadSafeWrapper.new( WorkQueue::FairQueue.new(500) { WorkQueue::BoundedQueue.new(10) }, ) @mutex = Mutex.new @stats_mutex = Mutex.new @paused = false @thread = nil @reactor = nil @timeout = DEFAULT_TIMEOUT @stats = LruRedux::ThreadSafeCache.new(STATS_CACHE_SIZE) end"
2307,def build_response @file = file_path if File.exist? @file build_file_response else build_404 end build_head if @request.head? end,True,Ruby,build_response,server.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,"def do_work(non_block = false) db, job, desc = @queue.shift(block: !non_block)[:task] start = Process.clock_gettime(Process::CLOCK_MONOTONIC) db ||= RailsMultisite::ConnectionManagement::DEFAULT RailsMultisite::ConnectionManagement.with_connection(db) do begin warning_job = @reactor.queue(@timeout) do Rails.logger.error ""'#{desc}' is still running after #{@timeout} seconds on db #{db}, this process may need to be restarted!"" end if !non_block job.call rescue => ex @stats_mutex.synchronize do stats = @stats[desc] stats[:errors] += 1 if stats end Discourse.handle_job_exception(ex, message: ""Running deferred code '#{desc}'"") ensure warning_job&.cancel end end rescue => ex Discourse.handle_job_exception(ex, message: ""Processing deferred code queue"") ensure ActiveRecord::Base.connection_handler.clear_active_connections! if start @stats_mutex.synchronize do stats = @stats[desc] if stats stats[:finished] += 1 stats[:duration] += Process.clock_gettime(Process::CLOCK_MONOTONIC) - start end end end end"
2311,"it 'should find a normal file' do get 'http://jekbox.example.com/foo.css' expect(last_response.body).to eq ""body {}\n"" end",True,Ruby,'should find a normal file',server_spec.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,def do_all_work do_work(non_block = true) while !@queue.empty? end
2312,"it 'should find the index.html file when a URL without a file is requested' do get 'http://jekbox.example.com' expect(last_response.body).to eq ""The index page\n"" end",True,Ruby,'should find the index.html file when a URL without a file is requested',server_spec.rb,https://github.com/tombh/jekbox,tombh,Thomas Buckley-Houston,2016-02-01 13:08:18+01:00,Ensure that requests ending with a slash and without try looking for an index.html file. And prevent malicious directory traversing,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2016-15019,"def later(desc = nil, db = RailsMultisite::ConnectionManagement.current_db, force: true, &blk) @stats_mutex.synchronize do stats = (@stats[desc] ||= { queued: 0, finished: 0, duration: 0, errors: 0 }) stats[:queued] += 1 end if @async start_thread if !@thread&.alive? && !@paused @queue.push({ key: db, task: [db, blk, desc] }, force: force) else blk.call end end"
2315,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""inspect"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end",True,Ruby,test_jail_classes_should_have_limited_methods,test_jail.rb,https://github.com/svenfuchs/safemode,svenfuchs,Dmitri Dolguikh,2016-04-14 14:03:10+01:00,"Remove `inspect` from allowed methods

The `inspect` method is pretty unsafe, as by default it includes
a lot of data from the object.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-3693,"def one_time_password @otp_username = otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) if current_user&.username == otp_username $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") elsif request.post? log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else # Display the form end else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end"
2316,"def test_jail_classes_should_have_limited_methods expected = [""new"", ""methods"", ""name"", ""inherited"", ""method_added"", ""inspect"", ""allow"", ""allowed?"", ""allowed_methods"", ""init_allowed_methods"", ""<"", # < needed in Rails Object#subclasses_of ""ancestors"", ""=="" # ancestors and == needed in Rails::Generator::Spec#lookup_class ] objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.class.methods.map(&:to_s).sort) end end",True,Ruby,test_jail_classes_should_have_limited_methods,test_jail.rb,https://github.com/svenfuchs/safemode,svenfuchs,Dmitri Dolguikh,2016-04-14 14:03:10+01:00,"Remove `inspect` from allowed methods

The `inspect` method is pretty unsafe, as by default it includes
a lot of data from the object.",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2016-3693,"def one_time_password @otp_username = otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) if current_user&.username == otp_username $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") elsif request.post? log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else # Display the form end else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end"
2321,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""inspect"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end",True,Ruby,test_jail_instances_should_have_limited_methods,test_jail.rb,https://github.com/svenfuchs/safemode,svenfuchs,Dmitri Dolguikh,2016-04-14 14:03:10+01:00,"Remove `inspect` from allowed methods

The `inspect` method is pretty unsafe, as by default it includes
a lot of data from the object.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-3693,"def one_time_password @otp_username = otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) if current_user&.username == otp_username $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") elsif request.post? log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else # Display the form end else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end"
2322,"def test_jail_instances_should_have_limited_methods expected = [""class"", ""inspect"", ""method_missing"", ""methods"", ""respond_to?"", ""respond_to_missing?"", ""to_jail"", ""to_s"", ""instance_variable_get""] expected.delete('respond_to_missing?') if RUBY_VERSION > '1.9.3' # respond_to_missing? is private in rubies above 1.9.3 objects.each do |object| assert_equal expected.sort, reject_pretty_methods(object.to_jail.methods.map(&:to_s).sort) end end",True,Ruby,test_jail_instances_should_have_limited_methods,test_jail.rb,https://github.com/svenfuchs/safemode,svenfuchs,Dmitri Dolguikh,2016-04-14 14:03:10+01:00,"Remove `inspect` from allowed methods

The `inspect` method is pretty unsafe, as by default it includes
a lot of data from the object.",CWE-264,"Permissions, Privileges, and Access Controls","Weaknesses in this category are related to the management of permissions, privileges, and other security features that are used to perform access control.",https://cwe.mitre.org/data/definitions/264.html,CVE-2016-3693,"def one_time_password @otp_username = otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) if current_user&.username == otp_username $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") elsif request.post? log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else # Display the form end else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end"
2324,"def instantiate variant, mac=nil # Filenames must end in a hex representation of a mac address but only if mac is not empty log_halt 403, ""Invalid MAC address: #{mac}"" unless valid_mac?(mac) || mac.nil? log_halt 403, ""Unrecognized pxeboot config type: #{variant}"" unless defined? variant.capitalize eval ""Proxy::TFTP::#{variant.capitalize}.new"" end",True,Ruby,instantiate,tftp_api.rb,https://github.com/theforeman/smart-proxy,theforeman,Dmitri Dolguikh,2016-05-05 16:07:56+01:00,Fixes #14931 - TFTP class instantiating fixed,CWE-284,Improper Access Control,The product does not restrict or incorrectly restricts access to a resource from an unauthorized actor.,https://cwe.mitre.org/data/definitions/284.html,CVE-2016-3728,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] matched_token = EmailToken.confirmable(token) if matched_token&.user&.totp_enabled? if !second_factor_token.present? return render json: { error: I18n.t('login.invalid_second_factor_code') } elsif !matched_token.user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! return render json: { error: I18n.t('login.invalid_second_factor_code') } end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) return render json: login_not_approved elsif payload = login_error_check(user) return render json: payload else log_on_user(user) return render json: success_json end end return render json: { error: I18n.t('email_login.invalid_token') } end"
2327,"def write!(headers) if @orig_disable_profiling != @disable_profiling || @orig_backtrace_level != @backtrace_level || @cookie.nil? settings = {""p"" => ""t"" } settings[""dp""] = ""t"" if @disable_profiling settings[""bt""] = @backtrace_level if @backtrace_level settings_string = settings.map{|k,v| ""#{k}=#{v}""}.join("","") Rack::Utils.set_cookie_header!(headers, COOKIE_NAME, :value => settings_string, :path => '/') end end",True,Ruby,write!,client_settings.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] matched_token = EmailToken.confirmable(token) if matched_token&.user&.totp_enabled? if !second_factor_token.present? return render json: { error: I18n.t('login.invalid_second_factor_code') } elsif !matched_token.user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! return render json: { error: I18n.t('login.invalid_second_factor_code') } end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) return render json: login_not_approved elsif payload = login_error_check(user) return render json: payload else log_on_user(user) return render json: success_json end end return render json: { error: I18n.t('email_login.invalid_token') } end"
2328,"def initialize(env) request = ::Rack::Request.new(env) @cookie = request.cookies[COOKIE_NAME] if @cookie @cookie.split("","").map{|pair| pair.split(""="")}.each do |k,v| @orig_disable_profiling = @disable_profiling = (v=='t') if k == ""dp"" @backtrace_level = v.to_i if k == ""bt"" end end @backtrace_level = nil if !@backtrace_level.nil? && (@backtrace_level == 0 || @backtrace_level > BACKTRACE_NONE) @orig_backtrace_level = @backtrace_level end",True,Ruby,initialize,client_settings.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] matched_token = EmailToken.confirmable(token) if matched_token&.user&.totp_enabled? if !second_factor_token.present? return render json: { error: I18n.t('login.invalid_second_factor_code') } elsif !matched_token.user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! return render json: { error: I18n.t('login.invalid_second_factor_code') } end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) return render json: login_not_approved elsif payload = login_error_check(user) return render json: payload else log_on_user(user) return render json: success_json end end return render json: { error: I18n.t('email_login.invalid_token') } end"
2332,"def discard_cookie!(headers) Rack::Utils.delete_cookie_header!(headers, COOKIE_NAME, :path => '/') end",True,Ruby,discard_cookie!,client_settings.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] matched_token = EmailToken.confirmable(token) if matched_token&.user&.totp_enabled? if !second_factor_token.present? return render json: { error: I18n.t('login.invalid_second_factor_code') } elsif !matched_token.user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! return render json: { error: I18n.t('login.invalid_second_factor_code') } end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) return render json: login_not_approved elsif payload = login_error_check(user) return render json: payload else log_on_user(user) return render json: success_json end end return render json: { error: I18n.t('email_login.invalid_token') } end"
2333,def has_cookie? !@cookie.nil? end,True,Ruby,has_cookie?,client_settings.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2350,"it ""should allow requests that are whitelisted"" do set_cookie(""__profilin=stylin"") get '/whitelisted' last_response.headers['X-MiniProfiler-Ids'].should_not be_nil end",True,Ruby,"""should allow requests that are whitelisted""",mini_profiler_spec.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2354,"it ""re-enabled functionality if whitelisted"" do Rack::MiniProfiler.config.authorization_mode = :whitelist expect(Rack::MiniProfiler).to receive(:request_authorized?) { true }.twice get '/html?pp=enable' last_response.body.should include('/mini-profiler-resources/includes.js') end",True,Ruby,"""re-enabled functionality if whitelisted""",mini_profiler_spec.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2356,"it 'avoids xss attacks' do h = last_response.headers['X-MiniProfiler-Ids'] id = ::JSON.parse(h)[0] get ""/mini-profiler-resources/results?id=%22%3E%3Cqss%3E"" last_response.should_not be_ok last_response.body.should_not =~ /<qss>/ last_response.body.should =~ /&lt;qss&gt;/ end",True,Ruby,'avoids xss attacks',mini_profiler_spec.rb,https://github.com/MiniProfiler/rack-mini-profiler,MiniProfiler,Sam,2016-05-18 17:07:17+10:00,"FEATURE: perform security checks earlier in the pipeline

This avoids needing to discard results and ensures no areas of mini profiler
can execute prior to a request being authorized

authorization token lasts for 30 minutes and is cycled after that",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2016-4442,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) expect(session[:current_user_id]).to eq(nil) end"
2376,"def test_AES_crush 500.times do assert_nothing_raised(""[Bug #2768]"") do # it caused OpenSSL SEGV by uninitialized key OpenSSL::Cipher::AES128.new(""ECB"").update ""."" * 17 end end end",True,Ruby,test_AES_crush,test_cipher.rb,https://github.com/ruby/openssl,ruby,Kazuki Yamaguchi,2016-09-28 14:38:30+09:00,"cipher: don't set dummy encryption key in Cipher#initialize

Remove the encryption key initialization from Cipher#initialize. This
is effectively a revert of r32723 (""Avoid possible SEGV from AES
encryption/decryption"", 2011-07-28).

r32723, which added the key initialization, was a workaround for
Ruby Bug #2768. For some certain ciphers, calling EVP_CipherUpdate()
before setting an encryption key caused segfault. It was not a problem
until OpenSSL implemented GCM mode - the encryption key could be
overridden by repeated calls of EVP_CipherInit_ex(). But, it is not the
case for AES-GCM ciphers. Setting a key, an IV, a key, in this order
causes the IV to be reset to an all-zero IV.

The problem of Bug #2768 persists on the current versions of OpenSSL.
So, make Cipher#update raise an exception if a key is not yet set by the
user. Since encrypting or decrypting without key does not make any
sense, this should not break existing applications.

Users can still call Cipher#key= and Cipher#iv= multiple times with
their own responsibility.

Reference: https://bugs.ruby-lang.org/issues/2768
Reference: https://bugs.ruby-lang.org/issues/8221
Reference: https://github.com/ruby/openssl/issues/49",CWE-326,Inadequate Encryption Strength,"The product stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.",https://cwe.mitre.org/data/definitions/326.html,CVE-2016-7798,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) expect(session[:current_user_id]).to eq(nil) end"
2378,"def initialize(remote_host, remote_port, local_host = nil, local_port = nil) if Thread.current[:private_address_check] && PrivateAddressCheck.resolves_to_private_address?(remote_host) raise PrivateAddressCheck::PrivateConnectionAttemptedError end initialize_without_private_address_check(remote_host, remote_port, local_host, local_port) end",True,Ruby,initialize,tcpsocket_ext.rb,https://github.com/jtdowney/private_address_check,jtdowney,John Downey,2018-05-03 20:05:19-05:00,"Fix TOCTOU bug

This fixes the time of check to time of use (TOCTOU) bug reported by Sajjad
Hashemian.",CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),"The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",https://cwe.mitre.org/data/definitions/362.html,CVE-2018-3759,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) expect(session[:current_user_id]).to eq(nil) end"
2380,"def test_private_address assert_raises PrivateAddressCheck::PrivateConnectionAttemptedError do PrivateAddressCheck.only_public_connections do TCPSocket.new(""localhost"", 80) end end end",True,Ruby,test_private_address,tcpsocket_ext_test.rb,https://github.com/jtdowney/private_address_check,jtdowney,John Downey,2018-05-03 20:05:19-05:00,"Fix TOCTOU bug

This fixes the time of check to time of use (TOCTOU) bug reported by Sajjad
Hashemian.",CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),"The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",https://cwe.mitre.org/data/definitions/362.html,CVE-2018-3759,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) expect(session[:current_user_id]).to eq(nil) end"
2385,"def find(uuid, options = {}) if uuid.nil? || uuid.to_s.empty? raise NotFound, ""can't find a record with nil identifier"" end uri = uuid =~ /^http/ ? uuid : member_path(uuid) begin from_response API.get(uri, {}, options) rescue API::NotFound => e raise NotFound, e.description end end",True,Ruby,find,resource.rb,https://github.com/recurly/recurly-client-ruby,recurly,andrew morton,2017-11-08 16:13:33-07:00,Fix SSRF vulnerability in Resource#find,CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2017-0905,"it 'returns the right response' do post ""/session/email-login"" expect(response.status).to eq(404) end"
2387,def _extend_marshalling(options) @marshalling = !(options[:marshalling] === false) # HACK - TODO delegate to Factory extend Marshalling if @marshalling end,True,Ruby,_extend_marshalling,store.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'returns the right response' do post ""/session/email-login"" expect(response.status).to eq(404) end"
2390,def self.normalize_key_names(options) options = options.dup if options.key?(:key_prefix) && !options.key?(:namespace) options[:namespace] = options.delete(:key_prefix) # RailsSessionStore end options[:raw] = !options[:marshalling] options end,True,Ruby,self.normalize_key_names,factory.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'returns the right response' do post ""/session/email-login"" expect(response.status).to eq(404) end"
2392,"def mget(*keys) options = (keys.pop if keys.last.is_a? Hash) || {} if keys.any? # Marshalling gets extended before Namespace does, so we need to pass options further if singleton_class.ancestors.include? Marshalling super(*keys.map {|key| interpolate(key) }, options) else super(*keys.map {|key| interpolate(key) }) end end end",True,Ruby,mget,namespace.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'returns the right response' do post ""/session/email-login"" expect(response.status).to eq(404) end"
2395,"def _unmarshal(val, options) unmarshal?(val, options) ? Marshal.load(val) : val end",True,Ruby,_unmarshal,serialization.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(500) end"
2397,"def _marshal(val, options) yield marshal?(options) ? Marshal.dump(val) : val end",True,Ruby,_marshal,serialization.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(500) end"
2401,"it ""allows/disable marshalling"" do store = Redis::Store::Factory.create :marshalling => false store.instance_variable_get(:@marshalling).must_equal(false) store.instance_variable_get(:@options)[:raw].must_equal(true) end",True,Ruby,"""allows/disable marshalling""",factory_test.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(500) end"
2404,"def setup @namespace = ""theplaylist"" @store = Redis::Store.new :namespace => @namespace, :marshalling => false # TODO remove mashalling option @client = @store.instance_variable_get(:@client) @rabbit = ""bunny"" @default_store = Redis::Store.new @other_namespace = 'other' @other_store = Redis::Store.new :namespace => @other_namespace end",True,Ruby,setup,namespace_test.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(500) end"
2406,"def setup @store = Redis::Store.new :marshalling => true @rabbit = OpenStruct.new :name => ""bunny"" @white_rabbit = OpenStruct.new :color => ""white"" @store.set ""rabbit"", @rabbit @store.del ""rabbit2"" end",True,Ruby,setup,serialization_test.rb,https://github.com/redis-store/redis-store,redis-store,Tom Scott,2017-08-15 11:46:36-04:00,"Replace marshalling with pluggable serializers

This is in response to a vulnerability warning we received on Friday,
August 11th, 2017. While most users will not be affected by this
change, we recommend that developers of new applications use a different
serializer other than `Marshal`. This, along with the removal of the
`:marshalling` option, will enforce ""sane defaults"" in terms of securely
serializing/de-serializing data.

- Add `:serializer` option and deprecate `:marshalling`. Although you
  will still be able to enable/disable serialization with Marshal using
  `:marshalling` in the 1.x series, this will be removed by 2.0.

- Rename `Redis::Store::Marshalling` to `Redis::Store::Serialization` to
  reflect its new purpose.

Fixes #289",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2017-1000248,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2412,"def test_attr_wrapper assert_equal(""<p strange=*attrs*></p>\n"", render(""%p{ :strange => 'attrs'}"", :attr_wrapper => '*')) assert_equal(""<p escaped='quo\""te'></p>\n"", render(""%p{ :escaped => 'quo\""te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""quo'te\""></p>\n"", render(""%p{ :escaped => 'quo\\'te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""q'uo&#x0022;te\""></p>\n"", render(""%p{ :escaped => 'q\\'uo\""te'}"", :attr_wrapper => '""')) assert_equal(""<?xml version=\""1.0\"" encoding=\""utf-8\"" ?>\n"", render(""!!! XML"", :attr_wrapper => '""', :format => :xhtml)) end",True,Ruby,test_attr_wrapper,engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2416,"def test_html5_data_attributes_without_hyphenation assert_equal(""<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\n"", render(""%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-one_plus_one='2'></div>\n"", render(""%div{:data => {:one_plus_one => 1+1}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-foo='Here&#x0027;s a \""quoteful\"" string.'></div>\n"", render(%{%div{:data => {:foo => %{Here's a ""quoteful"" string.}}}},",True,Ruby,test_html5_data_attributes_without_hyphenation,engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it 'logs in correctly' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ROTP::TOTP.new(user_second_factor.data).now, second_factor_method: UserSecondFactor.methods[:totp] } expect(JSON.parse(response.body)[""success""]).to eq(""OK"") expect(session[:current_user_id]).to eq(user.id) end"
2418,"def test_new_attribute_interpolation assert_equal(""<a href='12'>bar</a>\n"", render('%a(href=""1#{1 + 1}"") bar')) assert_equal(""<a href='2: 2, 3: 3'>bar</a>\n"", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3})) assert_equal(%Q{<a href='1\#{1 + 1}'>bar</a>\n}, render('%a(href=""1\#{1 + 1}"") bar')) end def test_truthy_new_attributes assert_equal(""<a href='href'>bar</a>\n"", render(""%a(href) bar"", :format => :xhtml)) assert_equal(""<a bar='baz' href>bar</a>\n"", render(""%a(href bar='baz') bar"", :format => :html5)) assert_equal(""<a href>bar</a>\n"", render(""%a(href=true) bar"")) assert_equal(""<a>bar</a>\n"", render(""%a(href=false) bar"")) end def test_new_attribute_parsing assert_equal(""<a a2='b2'>bar</a>\n"", render(""%a(a2=b2) bar"", :locals => {:b2 => 'b2'})) assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a=""#{'foo""bar'}"") bar})) #' assert_equal(%Q{<a a=""foo'bar"">bar</a>\n}, render(%q{%a(a=""#{""foo'bar""}"") bar})) #' assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a='foo""bar') bar})) assert_equal(%Q{<a a=""foo'bar"">bar</a>\n}, render(%q{%a(a=""foo'bar"") bar})) assert_equal(""<a a:b='foo'>bar</a>\n"", render(""%a(a:b='foo') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = 'foo' b = 'bar') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = foo b = bar) bar"", :locals => {:foo => 'foo', :bar => 'bar'})) assert_equal(""<a a='foo'>(b='bar')</a>\n"", render(""%a(a='foo')(b='bar')"")) assert_equal(""<a a='foo)bar'>baz</a>\n"", render(""%a(a='foo)bar') baz"")) assert_equal(""<a a='foo'>baz</a>\n"", render(""%a( a = 'foo' ) baz"")) end def test_new_attribute_escaping assert_equal(%Q{<a a='foo "" bar'>bar</a>\n}, render(%q{%a(a=""foo \"" bar"") bar})) assert_equal(%Q{<a a='foo \\"" bar'>bar</a>\n}, render(%q{%a(a=""foo \\\\\"" bar"") bar}))",True,Ruby,test_new_attribute_interpolation,engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved"")) expect(session[:current_user_id]).to eq(nil) end"
2424,"def test_new_attribute_interpolation assert_equal(""<a href='12'>bar</a>\n"", render('%a(href=""1#{1 + 1}"") bar')) assert_equal(""<a href='2: 2, 3: 3'>bar</a>\n"", render(%q{%a(href='2: #{1 + 1}, 3: #{foo}') bar}, :locals => {:foo => 3})) assert_equal(%Q{<a href='1\#{1 + 1}'>bar</a>\n}, render('%a(href=""1\#{1 + 1}"") bar')) end def test_truthy_new_attributes assert_equal(""<a href='href'>bar</a>\n"", render(""%a(href) bar"", :format => :xhtml)) assert_equal(""<a bar='baz' href>bar</a>\n"", render(""%a(href bar='baz') bar"", :format => :html5)) assert_equal(""<a href>bar</a>\n"", render(""%a(href=true) bar"")) assert_equal(""<a>bar</a>\n"", render(""%a(href=false) bar"")) end def test_new_attribute_parsing assert_equal(""<a a2='b2'>bar</a>\n"", render(""%a(a2=b2) bar"", :locals => {:b2 => 'b2'})) assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a=""#{'foo""bar'}"") bar})) #' assert_equal(%Q{<a a=""foo'bar"">bar</a>\n}, render(%q{%a(a=""#{""foo'bar""}"") bar})) #' assert_equal(%Q{<a a='foo""bar'>bar</a>\n}, render(%q{%a(a='foo""bar') bar})) assert_equal(%Q{<a a=""foo'bar"">bar</a>\n}, render(%q{%a(a=""foo'bar"") bar})) assert_equal(""<a a:b='foo'>bar</a>\n"", render(""%a(a:b='foo') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = 'foo' b = 'bar') bar"")) assert_equal(""<a a='foo' b='bar'>bar</a>\n"", render(""%a(a = foo b = bar) bar"", :locals => {:foo => 'foo', :bar => 'bar'})) assert_equal(""<a a='foo'>(b='bar')</a>\n"", render(""%a(a='foo')(b='bar')"")) assert_equal(""<a a='foo)bar'>baz</a>\n"", render(""%a(a='foo)bar') baz"")) assert_equal(""<a a='foo'>baz</a>\n"", render(""%a( a = 'foo' ) baz"")) end def test_new_attribute_escaping assert_equal(%Q{<a a='foo "" bar'>bar</a>\n}, render(%q{%a(a=""foo \"" bar"") bar})) assert_equal(%Q{<a a='foo \\"" bar'>bar</a>\n}, render(%q{%a(a=""foo \\\\\"" bar"") bar}))",True,Ruby,test_new_attribute_interpolation,pretty_engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved"")) expect(session[:current_user_id]).to eq(nil) end"
2431,"def test_html5_data_attributes_without_hyphenation assert_equal(""<div data-author_id='123' data-biz='baz' data-foo='bar'></div>\n"", render(""%div{:data => {:author_id => 123, :foo => 'bar', :biz => 'baz'}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-one_plus_one='2'></div>\n"", render(""%div{:data => {:one_plus_one => 1+1}}"", :hyphenate_data_attrs => false)) assert_equal(""<div data-foo='Here&#x0027;s a \""quoteful\"" string.'></div>\n"", render(%{%div{:data => {:foo => %{Here's a ""quoteful"" string.}}}},",True,Ruby,test_html5_data_attributes_without_hyphenation,pretty_engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it 'returns success' do post ""/session/email-login/#{email_token.token}.json"" expect(JSON.parse(response.body)[""success""]).to eq(""OK"") expect(session[:current_user_id]).to eq(user.id) end"
2432,"def test_attr_wrapper assert_equal(""<p strange=*attrs*></p>\n"", render(""%p{ :strange => 'attrs'}"", :attr_wrapper => '*')) assert_equal(""<p escaped='quo\""te'></p>\n"", render(""%p{ :escaped => 'quo\""te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""quo'te\""></p>\n"", render(""%p{ :escaped => 'quo\\'te'}"", :attr_wrapper => '""')) assert_equal(""<p escaped=\""q'uo&#x0022;te\""></p>\n"", render(""%p{ :escaped => 'q\\'uo\""te'}"", :attr_wrapper => '""')) assert_equal(""<?xml version=\""1.0\"" encoding=\""utf-8\"" ?>\n"", render(""!!! XML"", :attr_wrapper => '""', :format => :xhtml)) end",True,Ruby,test_attr_wrapper,pretty_engine_test.rb,https://github.com/haml/haml,haml,Takashi Kokubun,2017-02-09 00:29:57+09:00,"Always escape `'` in Haml::Helpers.#html_escape.

In some tests, `attr_wrapper` is changed to be ignored.

I'll split its fix to other commis because not Haml::Helpers but
Haml::AttributeBuilder is responsible for that.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-1002201,"it 'returns success' do post ""/session/email-login/#{email_token.token}.json"" expect(JSON.parse(response.body)[""success""]).to eq(""OK"") expect(session[:current_user_id]).to eq(user.id) end"
2438,"def origins(*args, &blk) @origins = args.flatten.collect do |n| case n when Regexp, /^https?:\/\//, 'file://' then n when '*' then @public_resources = true; n else Regexp.compile(""^[a-z][a-z0-9.+-]*:\\\/\\\/#{Regexp.quote(n)}"") end end.flatten",True,Ruby,origins,cors.rb,https://github.com/cyu/rack-cors,cyu,Calvin Yu,2015-10-13 13:28:24-04:00,"Add end string anchor to string origin def

Build regex with end string anchor when string is used to configure
origin

[Fixes #86]",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-11173,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t('email_login.invalid_token') ) end"
2441,"def match_resource(env) path = env[PATH_INFO] origin = env[HTTP_ORIGIN] origin_matched = false all_resources.each do |r| if r.allow_origin?(origin, env) origin_matched = true if found = r.match_resource(path, env) return [found, nil] end end end [nil, origin_matched ? Result::MISS_NO_PATH : Result::MISS_NO_ORIGIN] end",True,Ruby,match_resource,cors.rb,https://github.com/cyu/rack-cors,cyu,Calvin Yu,2019-11-13 22:56:55-05:00,"Unescape and resolve paths before resource checks

Fix scenario where someone could use '../' to access private resources",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2019-18978,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t('email_login.invalid_token') ) end"
2442,"def process_cors(env) resource, error = match_resource(env) if resource Result.hit(env) cors = resource.to_headers(env) cors else Result.miss(env, error) nil end end",True,Ruby,process_cors,cors.rb,https://github.com/cyu/rack-cors,cyu,Calvin Yu,2019-11-13 22:56:55-05:00,"Unescape and resolve paths before resource checks

Fix scenario where someone could use '../' to access private resources",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2019-18978,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t('email_login.invalid_token') ) end"
2445,"def process_preflight(env) result = Result.preflight(env) resource, error = match_resource(env) unless resource result.miss(error) return {} end return resource.process_preflight(env, result) end",True,Ruby,process_preflight,cors.rb,https://github.com/cyu/rack-cors,cyu,Calvin Yu,2019-11-13 22:56:55-05:00,"Unescape and resolve paths before resource checks

Fix scenario where someone could use '../' to access private resources",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2019-18978,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(404) end"
2447,"def call(env) env[HTTP_ORIGIN] ||= env[HTTP_X_ORIGIN] if env[HTTP_X_ORIGIN] add_headers = nil if env[HTTP_ORIGIN] debug(env) do [ 'Incoming Headers:', "" Origin: #{env[HTTP_ORIGIN]}"", "" Access-Control-Request-Method: #{env[HTTP_ACCESS_CONTROL_REQUEST_METHOD]}"", "" Access-Control-Request-Headers: #{env[HTTP_ACCESS_CONTROL_REQUEST_HEADERS]}"" ].join(""\n"") end if env[REQUEST_METHOD] == OPTIONS and env[HTTP_ACCESS_CONTROL_REQUEST_METHOD] headers = process_preflight(env) debug(env) do ""Preflight Headers:\n"" + headers.collect{|kv| "" #{kv.join(': ')}""}.join(""\n"") end return [200, headers, []] else add_headers = process_cors(env) end else Result.miss(env, Result::MISS_NO_ORIGIN) end # This call must be done BEFORE calling the app because for some reason # env[PATH_INFO] gets changed after that and it won't match. (At least # in rails 4.1.6) vary_resource = resource_for_path(env[PATH_INFO]) status, headers, body = @app.call env if add_headers headers = add_headers.merge(headers) debug(env) do add_headers.each_pair do |key, value| if headers.has_key?(key) headers[""X-Rack-CORS-Original-#{key}""] = value end end end end # Vary header should ALWAYS mention Origin if there's ANY chance for the # response to be different depending on the Origin header value. # Better explained here: http://www.fastly.com/blog/best-practices-for-using-the-vary-header/ if vary_resource vary = headers[VARY] cors_vary_headers = if vary_resource.vary_headers && vary_resource.vary_headers.any? vary_resource.vary_headers else DEFAULT_VARY_HEADERS end headers[VARY] = ((vary ? ([vary].flatten.map { |v| v.split(/,\s*/) }.flatten) : []) + cors_vary_headers).uniq.join(', ') end",True,Ruby,call,cors.rb,https://github.com/cyu/rack-cors,cyu,Calvin Yu,2019-11-13 22:56:55-05:00,"Unescape and resolve paths before resource checks

Fix scenario where someone could use '../' to access private resources",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2019-18978,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(404) end"
2454,"it ""does not remove multiple '../' at the beginning"" do expect(File.cleanpath('../../A/B')).to eq '../../A/B' end",True,Ruby,"""does not remove multiple '../' at the beginning""",file_spec.rb,https://github.com/lsegal/yard,lsegal,Loren Segal,2017-11-23 13:34:33-08:00,"Disallow relative paths that start with ../

Fixes a potential arbitrary file read vulnerability in yard server.
Thanks to ztz <ztz@ztz.me> for discovery of this security issue.",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2017-17042,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(404) end"
2455,"it ""passes the initial directory"" do expect(File.cleanpath('C/../../D')).to eq ""../D"" end",True,Ruby,"""passes the initial directory""",file_spec.rb,https://github.com/lsegal/yard,lsegal,Loren Segal,2017-11-23 13:34:33-08:00,"Disallow relative paths that start with ../

Fixes a potential arbitrary file read vulnerability in yard server.
Thanks to ztz <ztz@ztz.me> for discovery of this security issue.",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2017-17042,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(404) end"
2456,"def self.save_url_to_path(url, width, path) cmd = ""phantomjs rasterise.js #{url} #{width} #{path}"" run(cmd) end",True,Ruby,self.save_url_to_path,prepare_page.rb,https://github.com/exciting-io/printer,exciting-io,James Adam,2017-07-08 11:32:01+01:00,"Patch shell injection vulnerability in prepare page

By escaping the URL argument, we prevent arbitrary commands from being
able to be injected there.

Fixes #56",CWE-77,Improper Neutralization of Special Elements used in a Command ('Command Injection'),"The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/77.html,CVE-2017-20156,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username post ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end"
2459,"def attrs_to_s attributes.inject("""") do |res, (name, value)| if value value = (value == true) ? name : Rumble.html_escape(value) res << "" #{name}=\""#{value}\"""" end res end end",True,Ruby,attrs_to_s,rumble.rb,https://github.com/rf-/keynote,rf-,Ryan Fitzgerald,2017-07-22 15:00:52-07:00,"Always escape quotes in attributes; support array attrs

The current behavior is to pass HTML-safe strings through unaltered, but
this can still cause an XSS vulnerability if the string has an unescaped
quote in it:

    https://github.com/rails/rails/commit/4394e9075189ee6031944491aecd64fb269cdf54

I also added support for array attributes, since I noticed Rails does
it when I was copying their escaping code.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-20159,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username post ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end"
2460,"def test_hash_data str = <<-HTML <div data-modal=""true"" data-test=""&quot;test&quot;""></div> HTML assert_rumble str do div data: { modal: true, test: '""test""' } end end",True,Ruby,test_hash_data,rumble_spec.rb,https://github.com/rf-/keynote,rf-,Ryan Fitzgerald,2017-07-22 15:00:52-07:00,"Always escape quotes in attributes; support array attrs

The current behavior is to pass HTML-safe strings through unaltered, but
this can still cause an XSS vulnerability if the string has an unescaped
quote in it:

    https://github.com/rails/rails/commit/4394e9075189ee6031944491aecd64fb269cdf54

I also added support for array attributes, since I noticed Rails does
it when I was copying their escaping code.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2017-20159,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username post ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end"
2462,def show render (params[:page] ||= 'start') end,True,Ruby,show,tour_controller.rb,https://github.com/instedd/pollit,instedd,Gustavo Giráldez,2017-03-02 14:41:22-03:00,Fix possible remote execution code exploit in TourController,NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2017-20179,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username post ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end"
2464,"def write_key_to_disk(key, identity) # Writing is disabled. Don't bother checking any other states. return unless lookup_config_option('learn_public_keys') =~ /^1|y/ publickey_dir = lookup_config_option('publickey_dir') unless publickey_dir Log.info(""Public key sent with request but no publickey_dir defined in configuration. Not writing key to disk."") return end if File.directory?(publickey_dir) if File.exists?(old_keyfile = File.join(publickey_dir, ""#{identity}_pub.pem"")) old_key = File.read(old_keyfile).chomp unless old_key == key unless lookup_config_option('overwrite_stored_keys', 'n') =~ /^1|y/ Log.warn(""Public key sent from '%s' does not match the stored key. Not overwriting."" % identity) else Log.warn(""Public key sent from '%s' does not match the stored key. Overwriting."" % identity) File.open(File.join(publickey_dir, ""#{identity}_pub.pem""), 'w') { |f| f.puts key } end end else Log.debug(""Discovered a new public key for '%s'. Writing to '%s'"" % [identity, publickey_dir]) File.open(File.join(publickey_dir, ""#{identity}_pub.pem""), 'w') { |f| f.puts key } end else raise(""Cannot write public key to '%s'. Directory does not exist."" % publickey_dir) end end",True,Ruby,write_key_to_disk,sshkey.rb,https://github.com/puppetlabs/mcollective-sshkey-security,puppetlabs,Michael Smith,2017-06-29 14:16:04-07:00,"(MCOP-600) Prevent public key overwriting attack via identity

When using two-way automatic public key distribution, each end writes
the others `identity` as a public key file locally. No validation was
done on the `identity`, so it could trigger directory traversal and
allow the attacker to overwrite an unexpected file (like a trusted
public key certificate). Prevent this by verifying identity does not
result in traversing outside the intended distribution directory.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2017-2298,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] matched_token = EmailToken.confirmable(token) if matched_token&.user&.totp_enabled? if !second_factor_token.present? return render json: { error: I18n.t('login.invalid_second_factor_code') } elsif !matched_token.user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! return render json: { error: I18n.t('login.invalid_second_factor_code') } end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) return render json: login_not_approved elsif payload = login_error_check(user) return render json: payload else log_on_user(user) return render json: success_json end end return render json: { error: I18n.t('email_login.invalid_token') } end"
2468,"it 'should not overwrite an existing file if overwrite_stored_key is not set' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') @plugin.stubs(:lookup_config_option).with('overwrite_stored_keys', 'n').returns('n') File.stubs(:directory?).with('ssh/pkd').returns(true) File.stubs(:exists?).with('ssh/pkd/rspec_pub.pem').returns(true) File.stubs(:read).with('ssh/pkd/rspec_pub.pem').returns('ssh-rsa dcba') Log.expects(:warn) File.expects(:open).never @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end",True,Ruby,'should not overwrite an existing file if overwrite_stored_key is not set',sshkey_spec.rb,https://github.com/puppetlabs/mcollective-sshkey-security,puppetlabs,Michael Smith,2017-06-29 14:16:04-07:00,"(MCOP-600) Prevent public key overwriting attack via identity

When using two-way automatic public key distribution, each end writes
the others `identity` as a public key file locally. No validation was
done on the `identity`, so it could trigger directory traversal and
allow the attacker to overwrite an unexpected file (like a trusted
public key certificate). Prevent this by verifying identity does not
result in traversing outside the intended distribution directory.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2017-2298,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2469,"it 'should overwrite the existing public key if overwrite_stored_key is set' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') @plugin.stubs(:lookup_config_option).with('overwrite_stored_keys', 'n').returns('1') File.stubs(:directory?).with('ssh/pkd').returns(true) File.stubs(:exists?).with('ssh/pkd/rspec_pub.pem').returns(true) File.stubs(:read).with('ssh/pkd/rspec_pub.pem').returns('ssh-rsa dcba') file = mock File.expects(:open).with('ssh/pkd/rspec_pub.pem', 'w').yields(file) file.expects(:puts).with('ssh-rsa abcd') Log.expects(:warn) @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end",True,Ruby,'should overwrite the existing public key if overwrite_stored_key is set',sshkey_spec.rb,https://github.com/puppetlabs/mcollective-sshkey-security,puppetlabs,Michael Smith,2017-06-29 14:16:04-07:00,"(MCOP-600) Prevent public key overwriting attack via identity

When using two-way automatic public key distribution, each end writes
the others `identity` as a public key file locally. No validation was
done on the `identity`, so it could trigger directory traversal and
allow the attacker to overwrite an unexpected file (like a trusted
public key certificate). Prevent this by verifying identity does not
result in traversing outside the intended distribution directory.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2017-2298,"it 'logs in correctly' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ROTP::TOTP.new(user_second_factor.data).now, second_factor_method: UserSecondFactor.methods[:totp] } expect(JSON.parse(response.body)[""success""]).to eq(""OK"") expect(session[:current_user_id]).to eq(user.id) end"
2470,"it 'should write the public key to disk if its the first time its been seen' do @plugin.stubs(:lookup_config_option).with('learn_public_keys').returns('1') @plugin.stubs(:lookup_config_option).with('publickey_dir').returns('ssh/pkd') File.stubs(:directory?).with('ssh/pkd').returns(true) File.stubs(:exists?).with('ssh/pkd/rspec_pub.pem').returns(false) file = mock File.expects(:open).with('ssh/pkd/rspec_pub.pem', 'w').yields(file) file.expects(:puts).with('ssh-rsa abcd') @plugin.send(:write_key_to_disk, 'ssh-rsa abcd', 'rspec') end",True,Ruby,'should write the public key to disk if its the first time its been seen',sshkey_spec.rb,https://github.com/puppetlabs/mcollective-sshkey-security,puppetlabs,Michael Smith,2017-06-29 14:16:04-07:00,"(MCOP-600) Prevent public key overwriting attack via identity

When using two-way automatic public key distribution, each end writes
the others `identity` as a public key file locally. No validation was
done on the `identity`, so it could trigger directory traversal and
allow the attacker to overwrite an unexpected file (like a trusted
public key certificate). Prevent this by verifying identity does not
result in traversing outside the intended distribution directory.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2017-2298,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(404) end"
2474,"def params super rescue Rack::Utils::ParameterTypeError, Rack::Utils::InvalidParameterError => e raise BadRequest, ""Invalid query parameters: #{e.message}"" end",True,Ruby,params,base.rb,https://github.com/sinatra/sinatra,sinatra,Kunpei Sakai,2018-05-31 01:05:27+09:00,"escape invalid query params, fixes #1428",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-11627,"it 'returns the right response' do post ""/session/email-login"" expect(response.status).to eq(404) end"
2476,def accepts?(env) session = session env token = session[:csrf] ||= session['_csrf_token'] || random_string safe?(env) || env['HTTP_X_CSRF_TOKEN'] == token || Request.new(env).params[options[:authenticity_param]] == token end,True,Ruby,accepts?,authenticity_token.rb,https://github.com/sinatra/sinatra,sinatra,Zachary Scott,2016-07-26 15:31:31+09:00,"Use secure_compare when checking CSRF token

Since string comparisions may return early we want to use a constant
time comparsion function to protect the CSRF token against timing
attacks. Rack::Utils provides a such function.",CWE-203,Observable Discrepancy,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.",https://cwe.mitre.org/data/definitions/203.html,CVE-2018-1000119,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved"")) expect(session[:current_user_id]).to eq(nil) end"
2478,"def attachment(filename = nil, disposition = :attachment) response['Content-Disposition'] = disposition.to_s.dup return unless filename params = format('; filename=""%s""', File.basename(filename)) response['Content-Disposition'] << params ext = File.extname(filename) content_type(ext) unless response['Content-Type'] || ext.empty? end",True,Ruby,attachment,base.rb,https://github.com/sinatra/sinatra,sinatra,namusyaka,2022-11-23 22:24:02+09:00,"escape filename in the Content-Disposition header

According the multipart form data spec in WHATWG living standard.
Ref: https://html.spec.whatwg.org/#multipart-form-data",CWE-494,Download of Code Without Integrity Check,The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.,https://cwe.mitre.org/data/definitions/494.html,CVE-2022-45442,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}.json"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.invalid_second_factor_code"") ) expect(session[:current_user_id]).to eq(nil) end"
2482,"def ffi_lib(*names) raise LoadError.new(""library names list must not be empty"") if names.empty? lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL ffi_libs = names.map do |name| if name == FFI::CURRENT_PROCESS FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL) else libnames = (name.is_a?(::Array) ? name : [ name ]).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact lib = nil errors = {} libnames.each do |libname| begin orig = libname lib = FFI::DynamicLibrary.open(libname, lib_flags) break if lib rescue Exception => ex ldscript = false if ex.message =~ /(([^ \t()])+\.so([^ \t:()])*):([ \t])*(invalid ELF header|file too short|invalid file format)/ if File.read($1) =~ /(?:GROUP|INPUT) *\( *([^ \)]+)/ libname = $1 ldscript = true end end if ldscript retry else # TODO better library lookup logic libname = libname.to_s unless libname.start_with?(""/"") path = ['/usr/lib/','/usr/local/lib/'].find do |pth| File.exist?(pth + libname) end if path libname = path + libname retry end end libr = (orig == libname ? orig : ""#{orig} #{libname}"") errors[libr] = ex end end end if lib.nil? raise LoadError.new(errors.values.join("".\n"")) end # return the found lib lib end end @ffi_libs = ffi_libs end",True,Ruby,ffi_lib,library.rb,https://github.com/ffi/ffi,ffi,Lars Kanis,2018-06-01 22:18:25+02:00,"Don't treat Symbol args different to Strings in ffi_lib

Symbols were sent directly to FFI::DynamicLibrary.open in the first
attempt, resulting in a TypeError, so that only the mangled library
name was actually loaded.

This moves conversion to String to the front, so that subsequent
calls can assume Strings only.",CWE-426,Untrusted Search Path,The product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control.,https://cwe.mitre.org/data/definitions/426.html,CVE-2018-1000201,"it 'returns success' do post ""/session/email-login/#{email_token.token}.json"" expect(JSON.parse(response.body)[""success""]).to eq(""OK"") expect(session[:current_user_id]).to eq(user.id) end"
2483,"def self.map_library_name(lib) # Mangle the library name to reflect the native library naming conventions lib = lib.to_s unless lib.kind_of?(String) lib = Library::LIBC if lib == 'c' if lib && File.basename(lib) == lib lib = Platform::LIBPREFIX + lib unless lib =~ /^#{Platform::LIBPREFIX}/ r = Platform::IS_GNU ? ""\\.so($|\\.[1234567890]+)"" : ""\\.#{Platform::LIBSUFFIX}$"" lib += "".#{Platform::LIBSUFFIX}"" unless lib =~ /#{r}/ end lib end",True,Ruby,self.map_library_name,library.rb,https://github.com/ffi/ffi,ffi,Lars Kanis,2018-06-01 22:18:25+02:00,"Don't treat Symbol args different to Strings in ffi_lib

Symbols were sent directly to FFI::DynamicLibrary.open in the first
attempt, resulting in a TypeError, so that only the mangled library
name was actually loaded.

This moves conversion to String to the front, so that subsequent
calls can assume Strings only.",CWE-426,Untrusted Search Path,The product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control.,https://cwe.mitre.org/data/definitions/426.html,CVE-2018-1000201,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t('email_login.invalid_token') ) end"
2485,"def ffi_lib(*names) raise LoadError.new(""library names list must not be empty"") if names.empty? lib_flags = defined?(@ffi_lib_flags) ? @ffi_lib_flags : FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL ffi_libs = names.map do |name| if name == FFI::CURRENT_PROCESS FFI::DynamicLibrary.open(nil, FFI::DynamicLibrary::RTLD_LAZY | FFI::DynamicLibrary::RTLD_LOCAL) else libnames = (name.is_a?(::Array) ? name : [ name ]).map(&:to_s).map { |n| [ n, FFI.map_library_name(n) ].uniq }.flatten.compact lib = nil errors = {} libnames.each do |libname| begin orig = libname lib = FFI::DynamicLibrary.open(libname, lib_flags) break if lib rescue Exception => ex ldscript = false if ex.message =~ /(([^ \t()])+\.so([^ \t:()])*):([ \t])*(invalid ELF header|file too short|invalid file format)/ if File.read($1) =~ /(?:GROUP|INPUT) *\( *([^ \)]+)/ libname = $1 ldscript = true end end if ldscript retry else # TODO better library lookup logic unless libname.start_with?(""/"") path = ['/usr/lib/','/usr/local/lib/'].find do |pth| File.exist?(pth + libname) end if path libname = path + libname retry end end libr = (orig == libname ? orig : ""#{orig} #{libname}"") errors[libr] = ex end end end if lib.nil? raise LoadError.new(errors.values.join("".\n"")) end # return the found lib lib end end @ffi_libs = ffi_libs end",True,Ruby,ffi_lib,library.rb,https://github.com/ffi/ffi,ffi,Lars Kanis,2018-06-01 22:31:40+02:00,"Don't search in hardcoded paths on Windows

Native Windows apps don't use ""/usr"" path to store system dlls.
It's even more harm than good to search through these directories,
since they are used in Cygwin and it can lead to accidentaly loading
Cygwin DLLs into native Windows apps.

Hardcoded paths are disabled for MINGW and MSWIN environments only.
They are still present on Cygwin and MSYS2, because these POSIX-API
based environments don't use LoadLibrary() but dl_open() to load DLLs.",CWE-426,Untrusted Search Path,The product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control.,https://cwe.mitre.org/data/definitions/426.html,CVE-2018-1000201,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(500) end"
2486,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_templates( [""recaptcha.html""], autoescape=True )[0]",True,Ruby,read_config,captcha.py,https://github.com/matrix-org/synapse,matrix-org,GitHub,2021-01-27 10:59:50-05:00,"Clean-up the template loading code. (#9200)

* Enables autoescape by default for HTML files.
* Adds a new read_template method for reading a single template.
* Some logic clean-up.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-21332,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) post ""/session/email-login/#{email_token.token}.json"" expect(response.status).to eq(200) expect(JSON.parse(response.body)[""error""]).to eq( I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) expect(session[:current_user_id]).to eq(nil) end"
2487,"def read_config(self, config, **kwargs): self.recaptcha_private_key = config.get(""recaptcha_private_key"") self.recaptcha_public_key = config.get(""recaptcha_public_key"") self.enable_registration_captcha = config.get( ""enable_registration_captcha"", False ) self.recaptcha_siteverify_api = config.get( ""recaptcha_siteverify_api"", ""https://www.recaptcha.net/recaptcha/api/siteverify"", ) self.recaptcha_template = self.read_templates( [""recaptcha.html""], autoescape=True )[0]",True,Ruby,read_config,captcha.py,https://github.com/matrix-org/synapse,matrix-org,GitHub,2021-01-27 10:59:50-05:00,"Clean-up the template loading code. (#9200)

* Enables autoescape by default for HTML files.
* Adds a new read_template method for reading a single template.
* Some logic clean-up.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-21333,"def one_time_password @otp_username = otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) if current_user&.username == otp_username $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") elsif request.post? log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else # Display the form end else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end"
2494,it 'should escape the content of removed `plaintext` elements' do Sanitize.fragment('<plaintext>hello! <script>alert(0)</script>') .must_equal 'hello! &lt;script&gt;alert(0)&lt;/script&gt;' end,True,Ruby,'should escape the content of removed `plaintext` elements',test_clean_element.rb,https://github.com/rgrove/sanitize,rgrove,Ryan Grove,2020-06-15 17:27:27-07:00,"Fix sanitization bypass in HTML foreign content

https://github.com/rgrove/sanitize/security/advisories/GHSA-p4x4-rw2p-8j8m",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2020-4054,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username post ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end"
2496,it 'should escape the content of removed `xmp` elements' do Sanitize.fragment('<xmp>hello! <script>alert(0)</script></xmp>') .must_equal 'hello! &lt;script&gt;alert(0)&lt;/script&gt;' end,True,Ruby,'should escape the content of removed `xmp` elements',test_clean_element.rb,https://github.com/rgrove/sanitize,rgrove,Ryan Grove,2020-06-15 17:27:27-07:00,"Fix sanitization bypass in HTML foreign content

https://github.com/rgrove/sanitize/security/advisories/GHSA-p4x4-rw2p-8j8m",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2020-4054,"def self.publish_unread(post) return unless post.topic.regular? # TODO at high scale we are going to have to defer this, # perhaps cut down to users that are around in the last 7 days as well tags = nil tag_ids = nil if include_tags_in_report? tag_ids, tags = post.topic.tags.pluck(:id, :name).transpose end scope = TopicUser .tracking(post.topic_id) .includes(user: :user_stat) group_ids = if post.post_type == Post.types[:whisper] [Group::AUTO_GROUPS[:staff]] else post.topic.category && post.topic.category.secure_group_ids end if group_ids.present? scope = scope .joins(""INNER JOIN group_users gu ON gu.user_id = topic_users.user_id"") .where(""gu.group_id IN (?)"", group_ids) end scope .select([:user_id, :last_read_post_number, :notification_level]) .each do |tu| payload = { last_read_post_number: tu.last_read_post_number, highest_post_number: post.post_number, updated_at: post.topic.updated_at, created_at: post.created_at, category_id: post.topic.category_id, notification_level: tu.notification_level, archetype: post.topic.archetype, first_unread_at: tu.user.user_stat.first_unread_at, unread_not_too_old: true } if tags payload[:tags] = tags payload[:topic_tag_ids] = tag_ids end message = { topic_id: post.topic_id, message_type: UNREAD_MESSAGE_TYPE, payload: payload } MessageBus.publish(self.unread_channel_key(tu.user_id), message.as_json, user_ids: [tu.user_id] ) end end"
2498,"def call(env) node = env[:node] return if node.type != Nokogiri::XML::Node::ELEMENT_NODE || env[:is_whitelisted] name = env[:node_name] # Delete any element that isn't in the config whitelist, unless the node has # already been deleted from the document. # # It's important that we not try to reparent the children of a node that has # already been deleted, since that seems to trigger a memory leak in # Nokogiri. unless @elements.include?(name) || node.parent.nil? # Elements like br, div, p, etc. need to be replaced with whitespace in # order to preserve readability. if @whitespace_elements.include?(name) node.add_previous_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:before].to_s, node.document)) unless node.children.empty? node.add_next_sibling(Nokogiri::XML::Text.new(@whitespace_elements[name][:after].to_s, node.document)) end end unless @remove_all_contents || @remove_element_contents.include?(name) node.add_previous_sibling(node.children) end node.unlink return end attr_whitelist = @attributes[name] || @attributes[:all] if attr_whitelist.nil? # Delete all attributes from elements with no whitelisted attributes. node.attribute_nodes.each {|attr| attr.unlink } else allow_data_attributes = attr_whitelist.include?(:data) # Delete any attribute that isn't allowed on this element. node.attribute_nodes.each do |attr| attr_name = attr.name.downcase if attr_whitelist.include?(attr_name) # The attribute is whitelisted. # Remove any attributes that use unacceptable protocols. if @protocols.include?(name) && @protocols[name].include?(attr_name) attr_protocols = @protocols[name][attr_name] if attr.value =~ REGEX_PROTOCOL attr.unlink unless attr_protocols.include?($1.downcase) else attr.unlink unless attr_protocols.include?(:relative) end end else # The attribute isn't whitelisted. if allow_data_attributes && attr_name.start_with?('data-') # Arbitrary data attributes are allowed. Verify that the attribute # is a valid data attribute. attr.unlink unless attr_name =~ REGEX_DATA_ATTR else # Either the attribute isn't a data attribute, or arbitrary data # attributes aren't allowed. Remove the attribute. attr.unlink end end end end # Add required attributes. if @add_attributes.include?(name) @add_attributes[name].each {|key, val| node[key] = val } end end",True,Ruby,call,clean_element.rb,https://github.com/rgrove/sanitize,rgrove,Ryan Grove,2018-03-19 19:24:33-07:00,"fix: Prevent code injection due to improper escaping in libxml2 >= 2.9.2

When Sanitize <= 4.6.2 is used in combination with libxml2 >= 2.9.2, a
specially crafted HTML fragment can cause libxml2 to generate improperly
escaped output, allowing non-whitelisted attributes to be used on
whitelisted elements.

Sanitize now performs additional escaping on affected attributes to
prevent this.

Many thanks to the Shopify Application Security Team for responsibly
reporting this issue.

Fixes #176",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2018-3740,"it ""generates the correct messages for a secure topic"" do Jobs.run_immediately! UserActionManager.enable admin = Fabricate(:user) admin.grant_admin! cat = Fabricate(:category) cat.set_permissions(admins: :full) cat.save created_post = nil messages = MessageBus.track_publish do created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create _reply = PostCreator.new(admin, raw: ""this is my test reply 123 testing"", topic_id: created_post.topic_id).create end messages.filter! { |m| m.channel != ""/distributed_hash"" } channels = messages.map { |m| m.channel }.sort # 2 for topic, one to notify of new topic another for tracking state expect(channels).to eq( [ ""/new"", ""/u/#{admin.username}"", ""/u/#{admin.username}"", ""/unread/#{admin.id}"", ""/unread/#{admin.id}"", ""/latest"", ""/latest"", ""/topic/#{created_post.topic_id}"", ""/topic/#{created_post.topic_id}"", ""/user"", ""/user"", ""/user"" ].sort ) admin_ids = [Group[:admins].id] expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false) end"
2502,"it 'should not choke on valueless attributes' do @s.fragment('foo <a href>foo</a> bar') .must_equal 'foo <a href="""" rel=""nofollow"">foo</a> bar' end",True,Ruby,'should not choke on valueless attributes',test_clean_element.rb,https://github.com/rgrove/sanitize,rgrove,Ryan Grove,2018-03-19 19:24:33-07:00,"fix: Prevent code injection due to improper escaping in libxml2 >= 2.9.2

When Sanitize <= 4.6.2 is used in combination with libxml2 >= 2.9.2, a
specially crafted HTML fragment can cause libxml2 to generate improperly
escaped output, allowing non-whitelisted attributes to be used on
whitelisted elements.

Sanitize now performs additional escaping on affected attributes to
prevent this.

Many thanks to the Shopify Application Security Team for responsibly
reporting this issue.

Fixes #176",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2018-3740,"def bulk_unread_topic_ids topic_query = TopicQuery.new(current_user) if inbox = params[:private_message_inbox] filter = private_message_filter(topic_query, inbox) topic_query.options[:limit] = false topic_query .filter_private_messages_unread(current_user, filter) .distinct(false) .pluck(:id) else topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == ""true"" if params[:category_id] if params[:include_subcategories] topics = topics.where(<<~SQL, category_id: params[:category_id]) category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR category_id = :category_id SQL else topics = topics.where('category_id = ?', params[:category_id]) end end if params[:tag_name].present? topics = topics.joins(:tags).where(""tags.name"": params[:tag_name]) end topics.pluck(:id) end end"
2509,"it 'removes existing content types' do subject.content_type :xls, 'application/vnd.ms-excel' subject.get :excel do 'some binary content' end get '/excel.json' expect(last_response.status).to eq(406) expect(last_response.body).to eq(""The requested format 'txt' is not supported."") end",True,Ruby,'removes existing content types',api_spec.rb,https://github.com/ruby-grape/grape,ruby-grape,Daniel Doubrovkine (dB.) @dblockdotorg,2018-05-25 21:07:45-04:00,"When returning an HTML error, make sure it's safe (#1763)

* When calling into an API specifying a crafted format that is HTML,
the returned error renders the HTML back to the user, causing a potential XSS
issue.  For example:

http://example.com/api/endpoint?format=%3Cscript%3Ealert(document.cookie)%3C/script%3E

Renders as html:

The requested format '<script>alert(document.cookie)</script>' is not supported.

When an error generates html back to the user, make sure it's properly escaped.

Fixes issue #1762

* Add changelog entry

* Use a method that also works in rails3

* Add spec formatting for older rails/activesupport version",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3769,"def private_message_reset_new topic_query = TopicQuery.new(current_user, limit: false) if params[:topic_ids].present? unless Array === params[:topic_ids] raise Discourse::InvalidParameters.new( ""Expecting topic_ids to contain a list of topic ids"" ) end topic_scope = topic_query .private_messages_for(current_user, :all) .where(""topics.id IN (?)"", params[:topic_ids].map(&:to_i)) else params.require(:inbox) inbox = params[:inbox].to_s filter = private_message_filter(topic_query, inbox) topic_scope = topic_query.filter_private_message_new(current_user, filter) end topic_ids = TopicsBulkAction.new( current_user, topic_scope.distinct(false).pluck(:id), type: ""dismiss_topics"" ).perform! render json: success_json.merge(topic_ids: topic_ids) end"
2510,"it 'returns json error' do subject.content_type :json, 'application/json' subject.default_error_formatter :json subject.get '/something' do 'foo' end get '/something' expect(last_response.status).to eq(406) expect(last_response.body).to eq(""{\""error\"":\""The requested format 'txt' is not supported.\""}"") end",True,Ruby,'returns json error',api_spec.rb,https://github.com/ruby-grape/grape,ruby-grape,Daniel Doubrovkine (dB.) @dblockdotorg,2018-05-25 21:07:45-04:00,"When returning an HTML error, make sure it's safe (#1763)

* When calling into an API specifying a crafted format that is HTML,
the returned error renders the HTML back to the user, causing a potential XSS
issue.  For example:

http://example.com/api/endpoint?format=%3Cscript%3Ealert(document.cookie)%3C/script%3E

Renders as html:

The requested format '<script>alert(document.cookie)</script>' is not supported.

When an error generates html back to the user, make sure it's properly escaped.

Fixes issue #1762

* Add changelog entry

* Use a method that also works in rails3

* Add spec formatting for older rails/activesupport version",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3769,"def filter_archived(list, user, archived: true) # Executing an extra query instead of a sub-query because it is more # efficient for the PG planner. Caution should be used when changing the # query here as it can easily lead to an inefficient query. group_ids = group_with_messages_ids(user) list = list.joins(<<~SQL) LEFT JOIN group_archived_messages gm ON gm.topic_id = topics.id #{group_ids.present? ? ""AND gm.group_id IN (#{group_ids.join("","")})"" : """"} LEFT JOIN user_archived_messages um ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id SQL list = if archived list.where(""um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL"") else list.where(""um.user_id IS NULL AND gm.topic_id IS NULL"") end list end"
2512,"it 'is possible to return hash errors in jsonapi format' do get '/' expect(['{""error"":""rain!"",""detail"":""missing widget""}', '{""detail"":""missing widget"",""error"":""rain!""}']).to include(last_response.body) end",True,Ruby,'is possible to return hash errors in jsonapi format',exception_spec.rb,https://github.com/ruby-grape/grape,ruby-grape,Daniel Doubrovkine (dB.) @dblockdotorg,2018-05-25 21:07:45-04:00,"When returning an HTML error, make sure it's safe (#1763)

* When calling into an API specifying a crafted format that is HTML,
the returned error renders the HTML back to the user, causing a potential XSS
issue.  For example:

http://example.com/api/endpoint?format=%3Cscript%3Ealert(document.cookie)%3C/script%3E

Renders as html:

The requested format '<script>alert(document.cookie)</script>' is not supported.

When an error generates html back to the user, make sure it's properly escaped.

Fixes issue #1762

* Add changelog entry

* Use a method that also works in rails3

* Add spec formatting for older rails/activesupport version",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3769,"def private_messages_for(user, type) options = @options options.reverse_merge!(per_page: per_page_setting) result = Topic.includes(:allowed_users) result = result.includes(:tags) if SiteSetting.tagging_enabled if type == :group result = result.joins( ""INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')"" ) unless user.admin? result = result.joins(""INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}"") end elsif type == :user result = result.where(""topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})"") elsif type == :all group_ids = group_with_messages_ids(user) result = result.joins(<<~SQL) LEFT JOIN topic_allowed_users tau ON tau.topic_id = topics.id AND tau.user_id = #{user.id.to_i} LEFT JOIN topic_allowed_groups tag ON tag.topic_id = topics.id #{group_ids.present? ? ""AND tag.group_id IN (#{group_ids.join("","")})"" : """"} SQL result = result .where(""tag.topic_id IS NOT NULL OR tau.topic_id IS NOT NULL"") .distinct end result = result.joins(""LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})"") .order(""topics.bumped_at DESC"") .private_messages result = result.limit(options[:per_page]) unless options[:limit] == false result = result.visible if options[:visible] || @user.nil? || @user.regular? if options[:page] offset = options[:page].to_i * options[:per_page] result = result.offset(offset) if offset > 0 end result end"
2513,"it 'is possible to return errors in jsonapi format' do get '/' expect(last_response.body).to eq('{""error"":""rain!""}') end",True,Ruby,'is possible to return errors in jsonapi format',exception_spec.rb,https://github.com/ruby-grape/grape,ruby-grape,Daniel Doubrovkine (dB.) @dblockdotorg,2018-05-25 21:07:45-04:00,"When returning an HTML error, make sure it's safe (#1763)

* When calling into an API specifying a crafted format that is HTML,
the returned error renders the HTML back to the user, causing a potential XSS
issue.  For example:

http://example.com/api/endpoint?format=%3Cscript%3Ealert(document.cookie)%3C/script%3E

Renders as html:

The requested format '<script>alert(document.cookie)</script>' is not supported.

When an error generates html back to the user, make sure it's properly escaped.

Fixes issue #1762

* Add changelog entry

* Use a method that also works in rails3

* Add spec formatting for older rails/activesupport version",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3769,"it 'does not include user or group archived messages' do UserArchivedMessage.archive!(user.id, group_message) UserArchivedMessage.archive!(user.id, private_message) topics = TopicQuery.new(nil).list_private_messages_all(user).topics expect(topics).to eq([]) GroupArchivedMessage.archive!(group.id, group_message) topics = TopicQuery.new(nil).list_private_messages_all(user_2).topics expect(topics).to contain_exactly(private_message) end"
2516,"it 'is possible to specify a custom formatter' do get '/' expect(last_response.body).to eq('{:custom_formatter=>""rain!""}') end",True,Ruby,'is possible to specify a custom formatter',exception_spec.rb,https://github.com/ruby-grape/grape,ruby-grape,Daniel Doubrovkine (dB.) @dblockdotorg,2018-05-25 21:07:45-04:00,"When returning an HTML error, make sure it's safe (#1763)

* When calling into an API specifying a crafted format that is HTML,
the returned error renders the HTML back to the user, causing a potential XSS
issue.  For example:

http://example.com/api/endpoint?format=%3Cscript%3Ealert(document.cookie)%3C/script%3E

Renders as html:

The requested format '<script>alert(document.cookie)</script>' is not supported.

When an error generates html back to the user, make sure it's properly escaped.

Fixes issue #1762

* Add changelog entry

* Use a method that also works in rails3

* Add spec formatting for older rails/activesupport version",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2018-3769,"it 'returns a list of all private messages that has been archived' do UserArchivedMessage.archive!(user_2.id, private_message) GroupArchivedMessage.archive!(group.id, group_message) topics = TopicQuery.new(nil).list_private_messages_all_archive(user_2).topics expect(topics).to contain_exactly(private_message, group_message) end"
2523,"def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder) compressed_file_path.gsub(extension, '') end",True,Ruby,build_entry_path,gzip.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def bulk_unread_topic_ids topic_query = TopicQuery.new(current_user) if inbox = params[:private_message_inbox] filter = private_message_filter(topic_query, inbox) topic_query.options[:limit] = false topics = topic_query.filter_private_messages_unread(current_user, filter) else topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == ""true"" if params[:category_id] if params[:include_subcategories] topics = topics.where(<<~SQL, category_id: params[:category_id]) category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR category_id = :category_id SQL else topics = topics.where('category_id = ?', params[:category_id]) end end if params[:tag_name].present? topics = topics.joins(:tags).where(""tags.name"": params[:tag_name]) end end topics.pluck(:id) end"
2526,"def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false) @strategies.reverse.reduce(compressed_file_path) do |to_decompress, strategy| last_extension = strategy.extension strategy.decompress(dest_path, to_decompress, max_size, allow_non_root_folder: allow_non_root_folder) to_decompress.gsub(last_extension, '') end end",True,Ruby,decompress,pipeline.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def private_message_reset_new topic_query = TopicQuery.new(current_user, limit: false) if params[:topic_ids].present? unless Array === params[:topic_ids] raise Discourse::InvalidParameters.new( ""Expecting topic_ids to contain a list of topic ids"" ) end topic_scope = topic_query .private_messages_for(current_user, :all) .where(""topics.id IN (?)"", params[:topic_ids].map(&:to_i)) else params.require(:inbox) inbox = params[:inbox].to_s filter = private_message_filter(topic_query, inbox) topic_scope = topic_query.filter_private_message_new(current_user, filter) end topic_ids = TopicsBulkAction.new( current_user, topic_scope.pluck(:id), type: ""dismiss_topics"" ).perform! render json: success_json.merge(topic_ids: topic_ids) end"
2527,"def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false) sanitized_compressed_file_path = sanitize_path(compressed_file_path) get_compressed_file_stream(sanitized_compressed_file_path) do |compressed_file| available_size = calculate_available_size(max_size) entries_of(compressed_file).each do |entry| entry_path = build_entry_path( compressed_file, sanitize_path(dest_path), sanitized_compressed_file_path, entry, allow_non_root_folder ) if is_file?(entry) remaining_size = extract_file(entry, entry_path, available_size) available_size = remaining_size else extract_folder(entry, entry_path) end end end end",True,Ruby,decompress,strategy.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def private_messages_for(user, type) options = @options options.reverse_merge!(per_page: per_page_setting) result = Topic.includes(:allowed_users) result = result.includes(:tags) if SiteSetting.tagging_enabled if type == :group result = result.joins( ""INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')"" ) unless user.admin? result = result.joins(""INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}"") end elsif type == :user result = result.where(""topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})"") elsif type == :all group_ids = group_with_messages_ids(user) result = if group_ids.present? result.where(<<~SQL) topics.id IN ( SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i} UNION ALL SELECT topic_id FROM topic_allowed_groups WHERE group_id IN (#{group_ids.join("","")}) ) SQL else result.joins(<<~SQL) INNER JOIN topic_allowed_users tau ON tau.topic_id = topics.id AND tau.user_id = #{user.id.to_i} SQL end end result = result.joins(""LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})"") .order(""topics.bumped_at DESC"") .private_messages result = result.limit(options[:per_page]) unless options[:limit] == false result = result.visible if options[:visible] || @user.nil? || @user.regular? if options[:page] offset = options[:page].to_i * options[:per_page] result = result.offset(offset) if offset > 0 end result end"
2529,"def strip_directory(from, to, relative: false) sanitized_from = sanitize_path(from) rescue nil sanitized_to = sanitize_path(to) rescue nil return unless sanitized_from && sanitized_to glob_path = relative ? ""#{sanitized_from}/*/*"" : ""#{sanitized_from}/**"" FileUtils.mv(Dir.glob(glob_path), sanitized_to) if File.directory?(sanitized_from) end",True,Ruby,strip_directory,strategy.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def filter_archived(list, user, archived: true) # Executing an extra query instead of a sub-query because it is more # efficient for the PG planner. Caution should be used when changing the # query here as it can easily lead to an inefficient query. group_ids = group_with_messages_ids(user) if group_ids.present? list = list.joins(<<~SQL) LEFT JOIN group_archived_messages gm ON gm.topic_id = topics.id AND gm.group_id IN (#{group_ids.join("","")}) LEFT JOIN user_archived_messages um ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id SQL if archived list.where(""um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL"") else list.where(""um.user_id IS NULL AND gm.topic_id IS NULL"") end else list = list.joins(<<~SQL) LEFT JOIN user_archived_messages um ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id SQL list.where(""um.user_id IS #{archived ? ""NOT NULL"" : ""NULL""}"") end end"
2532,"def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder) File.join(dest_path, entry.full_name).tap do |entry_path| FileUtils.mkdir_p(File.dirname(entry_path)) end end",True,Ruby,build_entry_path,tar.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"it 'should return the right response for a single option' do DiscoursePoll::Poll.vote( user, post_with_multiple_poll.id, DiscoursePoll::DEFAULT_POLL_NAME, [option_a, option_b] ) get ""/polls/voters.json"", params: { post_id: post_with_multiple_poll.id, poll_name: DiscoursePoll::DEFAULT_POLL_NAME, option_id: option_b } expect(response.status).to eq(200) poll = response.parsed_body[""voters""] expect(poll[option_a]).to eq(nil) option = poll[option_b] expect(option.length).to eq(1) expect(option.first[""id""]).to eq(user.id) expect(option.first[""username""]).to eq(user.username) end"
2534,"def build_entry_path(compressed_file, dest_path, compressed_file_path, entry, allow_non_root_folder) folder_name = compressed_file_path.split('/').last.gsub('.zip', '') root = root_folder_present?(compressed_file, allow_non_root_folder) ? '' : ""#{folder_name}/"" File.join(dest_path, ""#{root}#{entry.name}"").tap do |entry_path| FileUtils.mkdir_p(File.dirname(entry_path)) end end",True,Ruby,build_entry_path,zip.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def search_ids users = Set.new # 1. exact username matches if @term.present? exact_matches = scoped_users.where(username_lower: @term) # don't pollute mentions with users who haven't shown up in over a year exact_matches = exact_matches.where('last_seen_at > ?', 1.year.ago) if @topic_id || @category_id exact_matches .limit(@limit) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 2. in topic if @topic_id in_topic = filtered_by_term_users .where('users.id IN (SELECT user_id FROM posts WHERE topic_id = ? AND post_type = ?)', @topic_id, Post.types[:regular]) if @searching_user.present? in_topic = in_topic.where('users.id <> ?', @searching_user.id) end in_topic .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 3. in category secure_category_id = if @category_id DB.query_single(<<~SQL, @category_id).first SELECT id FROM categories WHERE read_restricted AND id = ? SQL elsif @topic_id DB.query_single(<<~SQL, @topic_id).first SELECT id FROM categories WHERE read_restricted AND id IN (SELECT category_id FROM topics WHERE id = ?) SQL end if secure_category_id category_groups = Group.where(<<~SQL, secure_category_id, MAX_SIZE_PRIORITY_MENTION) groups.id IN ( SELECT group_id FROM category_groups JOIN groups g ON group_id = g.id WHERE category_id = ? AND user_count < ? ) SQL if @searching_user.present? category_groups = category_groups.members_visible_groups(@searching_user) end in_category = filtered_by_term_users .where(<<~SQL, category_groups.pluck(:id)) users.id IN ( SELECT gu.user_id FROM group_users gu WHERE group_id IN (?) LIMIT 200 ) SQL if @searching_user.present? in_category = in_category.where('users.id <> ?', @searching_user.id) end in_category .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 4. global matches if @term.present? filtered_by_term_users .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end # 5. last seen users (for search auto-suggestions) if @last_seen_users scoped_users .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end users.to_a end"
2536,"def root_folder_present?(filenames, allow_non_root_folder) filenames.map { |p| p.name.split('/').first }.uniq.size == 1 || allow_non_root_folder end",True,Ruby,root_folder_present?,zip.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,def restrict_user_fields?(user) (user.trust_level == TrustLevel[0] && anonymous?) || !can_see_profile?(user) end
2539,"def import! FileUtils.mkdir(@temp_folder) available_size = SiteSetting.decompressed_theme_max_file_size_mb Compression::Engine.engine_for(@original_filename).tap do |engine| engine.decompress(@temp_folder, @filename, available_size) engine.strip_directory(@temp_folder, @temp_folder, relative: true) end rescue RuntimeError raise RemoteTheme::ImportError, I18n.t(""themes.import_error.unpack_failed"") rescue Compression::Zip::ExtractFailed raise RemoteTheme::ImportError, I18n.t(""themes.import_error.file_too_big"") end",True,Ruby,import!,zip_importer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def perform_accept_invitation params.require(:id) params.permit(:email, :username, :name, :password, :timezone, :email_token, user_custom_fields: {}) invite = Invite.find_by(invite_key: params[:id]) if invite.present? begin attrs = { username: params[:username], name: params[:name], password: params[:password], user_custom_fields: params[:user_custom_fields], ip_address: request.remote_ip, session: session } if invite.is_invite_link? params.require(:email) attrs[:email] = params[:email] else attrs[:email] = invite.email attrs[:email_token] = params[:email_token] if params[:email_token].present? end user = invite.redeem(**attrs) rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e return render json: failed_json.merge(message: e.message), status: 412 end if user.blank? return render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404 end log_on_user(user) if user.active? && user.guardian.can_access_forum? user.update_timezone_if_missing(params[:timezone]) post_process_invite(user) create_topic_invite_notifications(invite, user) topic = invite.topics.first response = {} if user.present? if user.active? && user.guardian.can_access_forum? if user.guardian.can_see?(topic) response[:redirect_to] = path(topic.relative_url) else response[:redirect_to] = path(""/"") end else response[:message] = if user.active? I18n.t('activation.approval_required') else I18n.t('invite.confirm_email') end if user.guardian.can_see?(topic) cookies[:destination_url] = path(topic.relative_url) end end end render json: success_json.merge(response) else render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404 end"
2545,"def read_file(relative_path) File.read(""#{@temp_folder}/#{relative_path}"") end",True,Ruby,read_file,engine_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def resolve if @uri && @uri.port == 80 && FinalDestination.is_https_domain?(@uri.hostname) @uri.scheme = ""https"" @uri = URI(@uri.to_s) end if @limit < 0 @status = :too_many_redirects log(:warn, ""FinalDestination could not resolve URL (too many redirects): #{@uri}"") if @verbose return nil end unless validate_uri @status = :invalid_address log(:warn, ""FinalDestination could not resolve URL (invalid URI): #{@uri}"") if @verbose return nil end @ignored.each do |host| if @uri&.hostname&.match?(host) @status = :resolved return @uri end end if Oneboxer.cached_response_body_exists?(@uri.to_s) @status = :resolved return @uri end headers = request_headers middlewares = Excon.defaults[:middlewares] middlewares << Excon::Middleware::Decompress if @http_verb == :get request_start_time = Time.now response_body = +"""" request_validator = lambda do |chunk, _remaining_bytes, _total_bytes| response_body << chunk raise Excon::Errors::ExpectationFailed.new(""response size too big: #{@uri.to_s}"") if response_body.bytesize > MAX_REQUEST_SIZE_BYTES raise Excon::Errors::ExpectationFailed.new(""connect timeout reached: #{@uri.to_s}"") if Time.now - request_start_time > MAX_REQUEST_TIME_SECONDS end response = Excon.public_send(@http_verb, @uri.to_s, read_timeout: timeout, connect_timeout: timeout, headers: headers, middlewares: middlewares, response_block: request_validator ) location = nil response_headers = nil response_status = response.status.to_i case response.status when 200 # Cache body of successful `get` requests if @http_verb == :get if Oneboxer.cache_response_body?(@uri) Oneboxer.cache_response_body(@uri.to_s, response_body) end end if @follow_canonical next_url = fetch_canonical_url(response_body) if next_url.to_s.present? && next_url != @uri @follow_canonical = false @uri = next_url @http_verb = http_verb(@force_get_hosts, @follow_canonical) return resolve end end @content_type = response.headers['Content-Type'] if response.headers.has_key?('Content-Type') @status = :resolved return @uri when 103, 400, 405, 406, 409, 500, 501 response_status, small_headers = small_get(request_headers) if response_status == 200 @status = :resolved return @uri end response_headers = {} if cookie_val = small_headers['set-cookie'] response_headers[:cookies] = cookie_val end if location_val = small_headers['location'] response_headers[:location] = location_val.join end end"
2547,"it 'decompress the folder and inspect files correctly' do engine = described_class.engine_for(@compressed_path) engine.decompress(@temp_folder, ""#{@temp_folder}/#{@folder_name}.zip"", available_size) expect(read_file(""test/hello.txt"")).to eq(""hello world"") expect(read_file(""test/a/inner"")).to eq(""hello world inner"") end",True,Ruby,'decompress the folder and inspect files correctly',engine_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def category_preferences_export return enum_for(:category_preferences_export) unless block_given? CategoryUser .where(user_id: @current_user.id) .includes(:category) .merge(Category.secured(guardian)) .each do |cu| yield [ cu.category_id, piped_category_name(cu.category_id, cu.category), NotificationLevels.all[cu.notification_level], cu.last_seen_at ] end end"
2548,"it ""exports the theme correctly"" do package file = 'discourse-header-icons.zip' Dir.chdir(dir) do available_size = SiteSetting.decompressed_theme_max_file_size_mb Compression::Zip.new.decompress(dir, file, available_size, allow_non_root_folder: true) `rm #{file}` folders = Dir.glob(""**/*"").reject { |f| File.file?(f) } expect(folders).to contain_exactly(""assets"", ""common"", ""locales"", ""mobile"") files = Dir.glob(""**/*"").reject { |f| File.directory?(f) } expect(files).to contain_exactly(""about.json"", ""assets/logo.png"", ""assets/other_logo.png"", ""common/body_tag.html"", ""locales/en.yml"", ""mobile/mobile.scss"", ""settings.yml"") expect(JSON.parse(File.read('about.json')).deep_symbolize_keys).to eq( ""name"": ""Header Icons"", ""about_url"": ""abouturl"", ""license_url"": ""licenseurl"", ""component"": false, ""assets"": { ""logo"": ""assets/logo.png"", ""other_logo"": ""assets/other_logo.png"" }, ""authors"": ""David Taylor"", ""minimum_discourse_version"": ""1.0.0"", ""maximum_discourse_version"": ""3.0.0.beta1"", ""theme_version"": ""1.0"", ""color_schemes"": { ""Orphan Color Scheme"": { ""header_primary"": ""F0F0F0"", ""header_background"": ""1E1E1E"", ""tertiary"": ""858585"" }, ""Theme Color Scheme"": { ""header_primary"": ""F0F0F0"", ""header_background"": ""1E1E1E"", ""tertiary"": ""858585"" } }, ""modifiers"": {}, ""learn_more"": ""https://meta.discourse.org/t/beginners-guide-to-using-discourse-themes/91966"" ) expect(File.read(""common/body_tag.html"")).to eq(""<b>testtheme1</b>"") expect(File.read(""mobile/mobile.scss"")).to eq(""body {background-color: $background_color; font-size: $font-size}"") expect(File.read(""settings.yml"")).to eq(""somesetting: #{rand_hex}"") expect(File.read(""locales/en.yml"")).to eq({ en: { key: ""value"" } }.deep_stringify_keys.to_yaml) theme.update!(name: ""Discourse Header Icons"") exporter = ThemeStore::ZipExporter.new(theme) filename = exporter.package_filename exporter.cleanup! expect(filename).to end_with ""/discourse-header-icons.zip"" end end",True,Ruby,"""exports the theme correctly""",zip_exporter_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-09-29 20:00:38+02:00,"SECURITY: Prevent arbitrary file write when decompressing files (#18421)

* SECURITY: Prevent arbitrary file write when decompressing files
* FIX: Allow decompressing files into symlinked directories

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>
Co-authored-by: Gerhard Schlager <gerhard.schlager@discourse.org>",CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-36066,"def get_user_archive_fields(user_archive) user_archive_array = [] topic_data = user_archive.topic user_archive = user_archive.as_json topic_data = Topic.with_deleted.includes(:category).find_by(id: user_archive['topic_id']) if topic_data.nil? return user_archive_array if topic_data.nil? categories = piped_category_name(topic_data.category_id, topic_data.category) is_pm = topic_data.archetype == ""private_message"" ? I18n.t(""csv_export.boolean_yes"") : I18n.t(""csv_export.boolean_no"") url = ""#{Discourse.base_url}/t/#{topic_data.slug}/#{topic_data.id}/#{user_archive['post_number']}"" topic_hash = { ""post"" => user_archive['raw'], ""topic_title"" => topic_data.title, ""categories"" => categories, ""is_pm"" => is_pm, ""url"" => url } user_archive.merge!(topic_hash) HEADER_ATTRS_FOR['user_archive'].each do |attr| user_archive_array.push(user_archive[attr]) end user_archive_array end"
2550,"def validate_invitiation!(sso) invite_key = secure_session[""invite-key""] return if invite_key.blank? invite = Invite.find_by(invite_key: invite_key) if invite.blank? raise Invite::ValidationFailed.new(I18n.t(""invite.not_found"", base_url: Discourse.base_url)) end if invite.redeemable? if !invite.is_invite_link? && sso.email != invite.email raise Invite::ValidationFailed.new(I18n.t(""invite.not_matching_email"")) end elsif invite.expired? raise Invite::ValidationFailed.new(I18n.t('invite.expired', base_url: Discourse.base_url)) elsif invite.redeemed? raise Invite::ValidationFailed.new(I18n.t('invite.not_found_template', site_name: SiteSetting.title, base_url: Discourse.base_url)) end invite end",True,Ruby,validate_invitiation!,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def piped_category_name(category_id, category) return ""#{category_id}"" if category_id && !category return ""-"" if !guardian.can_see_category?(category) categories = [category.name] while category.parent_category_id && category = category.parent_category categories << category.name end categories.reverse.join(""|"") end"
2552,def is_invite_link? email.blank? end,True,Ruby,is_invite_link?,invite.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def sso_login raise Discourse::NotFound unless SiteSetting.enable_discourse_connect raise Discourse::ReadOnly if @readonly_mode && !staff_writes_only_mode? params.require(:sso) params.require(:sig) begin sso = DiscourseConnect.parse(request.query_string, secure_session: secure_session) rescue DiscourseConnect::ParseError => e connect_verbose_warn { ""Verbose SSO log: Signature parse error\n\n#{e.message}\n\n#{sso&.diagnostics}"" } # Do NOT pass the error text to the client, it would give them the correct signature return render_sso_error(text: I18n.t(""discourse_connect.login_error""), status: 422) end if !sso.nonce_valid? connect_verbose_warn { ""Verbose SSO log: #{sso.nonce_error}\n\n#{sso.diagnostics}"" } return render_sso_error(text: I18n.t(""discourse_connect.timeout_expired""), status: 419) end if ScreenedIpAddress.should_block?(request.remote_ip) connect_verbose_warn { ""Verbose SSO log: IP address is blocked #{request.remote_ip}\n\n#{sso.diagnostics}"" } return render_sso_error(text: I18n.t(""discourse_connect.unknown_error""), status: 500) end return_path = sso.return_path sso.expire_nonce! begin invite = validate_invitiation!(sso) if user = sso.lookup_or_create_user(request.remote_ip) raise Discourse::ReadOnly if staff_writes_only_mode? && !user&.staff? if user.suspended? render_sso_error(text: failed_to_login(user)[:error], status: 403) return end if SiteSetting.must_approve_users? && !user.approved? if invite.present? && user.invited_user.blank? redeem_invitation(invite, sso) end if SiteSetting.discourse_connect_not_approved_url.present? redirect_to SiteSetting.discourse_connect_not_approved_url, allow_other_host: true else render_sso_error(text: I18n.t(""discourse_connect.account_not_approved""), status: 403) end return # we only want to redeem the invite if # the user has not already redeemed an invite # (covers the same SSO user visiting an invite link) elsif invite.present? && user.invited_user.blank? redeem_invitation(invite, sso) # we directly call user.activate here instead of going # through the UserActivator path because we assume the account # is valid from the SSO provider's POV and do not need to # send an activation email to the user user.activate login_sso_user(sso, user) topic = invite.topics.first return_path = topic.present? ? path(topic.relative_url) : path(""/"") elsif !user.active? activation = UserActivator.new(user, request, session, cookies) activation.finish session[""user_created_message""] = activation.message return redirect_to(users_account_created_path) else login_sso_user(sso, user) end # If it's not a relative URL check the host if return_path !~ /^\/[^\/]/ begin uri = URI(return_path) if (uri.hostname == Discourse.current_hostname) return_path = uri.to_s elsif !SiteSetting.discourse_connect_allows_all_return_paths return_path = path(""/"") end rescue return_path = path(""/"") end end # this can be done more surgically with a regex # but it the edge case of never supporting redirects back to # any url with `/session/sso` in it anywhere is reasonable if return_path.include?(path(""/session/sso"")) return_path = path(""/"") end redirect_to return_path, allow_other_host: true else render_sso_error(text: I18n.t(""discourse_connect.not_found""), status: 500) end rescue ActiveRecord::RecordInvalid => e connect_verbose_warn { <<~TEXT } Verbose SSO log: Record was invalid: #{e.record.class.name} #{e.record.id} #{e.record.errors.to_h} Attributes: #{e.record.attributes.slice(*DiscourseConnectBase::ACCESSORS.map(&:to_s))} SSO Diagnostics: #{sso.diagnostics} TEXT text = nil # If there's a problem with the email we can explain that if (e.record.is_a?(User) && e.record.errors[:primary_email].present?) if e.record.email.blank? text = I18n.t(""discourse_connect.no_email"") else text = I18n.t(""discourse_connect.email_error"", email: ERB::Util.html_escape(e.record.email)) end end render_sso_error(text: text || I18n.t(""discourse_connect.unknown_error""), status: 500) rescue DiscourseConnect::BlankExternalId render_sso_error(text: I18n.t(""discourse_connect.blank_id_error""), status: 500) rescue Invite::ValidationFailed => e render_sso_error(text: e.message, status: 400) rescue Invite::RedemptionFailed => e render_sso_error(text: I18n.t(""discourse_connect.invite_redeem_failed""), status: 412) rescue Invite::UserExists => e render_sso_error(text: e.message, status: 412) rescue => e message = +""Failed to create or lookup user: #{e}."" message << "" "" message << "" #{sso.diagnostics}"" message << "" "" message << "" #{e.backtrace.join(""\n"")}"" Rails.logger.error(message) render_sso_error(text: I18n.t(""discourse_connect.unknown_error""), status: 500) end end"
2553,"def redeem( email: nil, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil, redeeming_user: nil ) return if !redeemable? email = self.email if email.blank? && !is_invite_link? InviteRedeemer.new( invite: self, email: email, username: username, name: name, password: password, user_custom_fields: user_custom_fields, ip_address: ip_address, session: session, email_token: email_token, redeeming_user: redeeming_user ).redeem end",True,Ruby,redeem,invite.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil) if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email) available_username = username else available_username = UserNameSuggester.suggest(email) end if email.present? && invite.domain.present? username, domain = email.split('@') if domain.present? && invite.domain != domain raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end end user = User.where(staged: true).with_email(email.strip.downcase).first user.unstage! if user user ||= User.new user.attributes = { email: email, username: available_username, name: name || available_username, active: false, trust_level: SiteSetting.default_invitee_trust_level, ip_address: ip_address, registration_ip_address: ip_address } if SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email) ReviewableUser.set_approved_fields!(user, Discourse.system_user) end user_fields = UserField.all if user_custom_fields.present? && user_fields.present? field_params = user_custom_fields || {} fields = user.custom_fields user_fields.each do |f| field_val = field_params[f.id.to_s] fields[""#{User::USER_FIELD_PREFIX}#{f.id}""] = field_val[0...UserField.max_length] unless field_val.blank? end user.custom_fields = fields end user.moderator = true if invite.moderator? && invite.invited_by.staff? if password user.password = password user.password_required! end authenticator = UserAuthenticator.new(user, session, require_password: false) if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end authenticator.start if authenticator.email_valid? && !authenticator.authenticated? raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end user.save! authenticator.finish if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup]) user.activate end User.find(user.id) end"
2558,"def can_redeem_invite? return false if !invite.redeemable? # Invite has already been redeemed by anyone. if !invite.is_invite_link? && InvitedUser.exists?(invite_id: invite.id) return false end # Email will not be present if we are claiming an invite link, which # does not have an email or domain scope on the invitation. if email.present? || redeeming_user.present? email_to_check = redeeming_user&.email || email if invite.email.present? && !invite.email_matches?(email_to_check) raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.not_matching_email')) end if invite.domain.present? && !invite.domain_matches?(email_to_check) raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end end # Anon user is trying to redeem an invitation, if an existing user already # redeemed it then we cannot redeem now. redeeming_user ||= User.where(admin: false, staged: false).find_by_email(email) if redeeming_user.present? && InvitedUser.exists?(user_id: redeeming_user.id, invite_id: invite.id) return false end true end",True,Ruby,can_redeem_invite?,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def build_actions(actions, guardian, args) return unless pending? if guardian.can_approve?(target) actions.add(:approve_user) do |a| a.icon = 'user-plus' a.label = ""reviewables.actions.approve_user.title"" end end delete_user_actions(actions, require_reject_reason: !is_a_suspect_user?) end"
2560,"def add_to_private_topics_if_invited topic_ids = Topic.where(archetype: Archetype::private_message).includes(:invites).where(invites: { email: email }).pluck(:id) topic_ids.each do |id| TopicAllowedUser.create!(user_id: invited_user.id, topic_id: id) unless TopicAllowedUser.exists?(user_id: invited_user.id, topic_id: id) end end",True,Ruby,add_to_private_topics_if_invited,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""should be created correctly"" do invite = Fabricate(:invite, email: 'walter.white@email.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(false) expect(user.active).to eq(false) end"
2561,"def notify_invitee if inviter = invite.invited_by inviter.notifications.create!( notification_type: Notification.types[:invitee_accepted], data: { display_username: invited_user.username }.to_json ) end end",True,Ruby,notify_invitee,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""can set password"" do user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(false) end"
2563,"def initialize( invite: nil, email: nil, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil, redeeming_user: nil) @invite = invite @email = email @username = username @name = name @password = password @user_custom_fields = user_custom_fields @ip_address = ip_address @session = session @email_token = email_token @redeeming_user = redeeming_user end",True,Ruby,initialize,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""should redeem the invite if invited by non staff and approve if staff not required to approve"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(false) end"
2565,"def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil) if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email) available_username = username else available_username = UserNameSuggester.suggest(email) end user = User.where(staged: true).with_email(email.strip.downcase).first user.unstage! if user user ||= User.new user.attributes = { email: email, username: available_username, name: name || available_username, active: false, trust_level: SiteSetting.default_invitee_trust_level, ip_address: ip_address, registration_ip_address: ip_address } if (!SiteSetting.must_approve_users && SiteSetting.invite_only) || (SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email)) ReviewableUser.set_approved_fields!(user, Discourse.system_user) end user_fields = UserField.all if user_custom_fields.present? && user_fields.present? field_params = user_custom_fields || {} fields = user.custom_fields user_fields.each do |f| field_val = field_params[f.id.to_s] fields[""#{User::USER_FIELD_PREFIX}#{f.id}""] = field_val[0...UserField.max_length] unless field_val.blank? end user.custom_fields = fields end user.moderator = true if invite.moderator? && invite.invited_by.staff? if password user.password = password user.password_required! end authenticator = UserAuthenticator.new(user, session, require_password: false) if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end authenticator.start if authenticator.email_valid? && !authenticator.authenticated? raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end user.save! authenticator.finish if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token user.activate end User.find(user.id) end",True,Ruby,self.create_user_from_invite,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""should unstage user"" do staged_user = Fabricate(:staged, email: 'staged@account.com', active: true, username: 'staged1', name: 'Stage Name') invite = Fabricate(:invite, email: 'staged@account.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.id).to eq(staged_user.id) expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.staged).to eq(false) expect(user.email).to eq('staged@account.com') expect(user.approved).to eq(false) end"
2570,"it ""adds user to group"" do group = Fabricate(:group, grant_trust_level: 2) InvitedGroup.create(group_id: group.id, invite_id: invite.id) group.add_owner(invite.invited_by) user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user.group_users.count).to eq(4) expect(user.trust_level).to eq(2) end",True,Ruby,"""adds user to group""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""does not activate user invited via links"" do invite = Fabricate(:invite, email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:not_required]) user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(false) expect(user.active).to eq(false) end"
2571,"it ""raises an error if the email does not match the invite email"" do redeemer = InviteRedeemer.new(invite: invite, email: ""blah@test.com"", username: username, name: name) expect { redeemer.redeem }.to raise_error(ActiveRecord::RecordNotSaved, I18n.t(""invite.not_matching_email"")) end",True,Ruby,"""raises an error if the email does not match the invite email""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""can set the password and ip_address"" do password = 's3cure5tpasSw0rD' ip_address = '192.168.1.1' invite = Fabricate(:invite, email: 'walter.white@email.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: password, ip_address: ip_address) expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(false) expect(user.ip_address).to eq(ip_address) expect(user.registration_ip_address).to eq(ip_address) end"
2579,"it ""should redeem the invite and approve the user when user email is in auto_approve_email_domains setting"" do SiteSetting.auto_approve_email_domains = ""example.com"" user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.approved).to eq(true) expect(user.approved_by).to eq(Discourse.system_user) end",True,Ruby,"""should redeem the invite and approve the user when user email is in auto_approve_email_domains setting""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""activates user invited via email with a token"" do invite = Fabricate(:invite, invited_by: Fabricate(:admin), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent]) user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: invite.email_token) expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(false) expect(user.active).to eq(true) end"
2580,"it ""should redeem the invite if invited by non staff and approve if staff not required to approve"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(false) end",True,Ruby,"""should redeem the invite if invited by non staff and approve if staff not required to approve""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil) if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email) available_username = username else available_username = UserNameSuggester.suggest(email) end if email.present? && invite.domain.present? username, domain = email.split('@') if domain.present? && invite.domain != domain raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end end user = User.where(staged: true).with_email(email.strip.downcase).first user.unstage! if user user ||= User.new user.attributes = { email: email, username: available_username, name: name || available_username, active: false, trust_level: SiteSetting.default_invitee_trust_level, ip_address: ip_address, registration_ip_address: ip_address } if (!SiteSetting.must_approve_users && SiteSetting.invite_only) || (SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email)) ReviewableUser.set_approved_fields!(user, Discourse.system_user) end user_fields = UserField.all if user_custom_fields.present? && user_fields.present? field_params = user_custom_fields || {} fields = user.custom_fields user_fields.each do |f| field_val = field_params[f.id.to_s] fields[""#{User::USER_FIELD_PREFIX}#{f.id}""] = field_val[0...UserField.max_length] unless field_val.blank? end user.custom_fields = fields end user.moderator = true if invite.moderator? && invite.invited_by.staff? if password user.password = password user.password_required! end authenticator = UserAuthenticator.new(user, session, require_password: false) if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end authenticator.start if authenticator.email_valid? && !authenticator.authenticated? raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end user.save! authenticator.finish if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token user.activate end User.find(user.id) end"
2582,"it ""can set custom fields"" do required_field = Fabricate(:user_field) optional_field = Fabricate(:user_field, required: false) user_fields = { required_field.id.to_s => 'value1', optional_field.id.to_s => 'value2' } user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password, user_custom_fields: user_fields).redeem expect(user).to be_present expect(user.custom_fields[""user_field_#{required_field.id}""]).to eq('value1') expect(user.custom_fields[""user_field_#{optional_field.id}""]).to eq('value2') end",True,Ruby,"""can set custom fields""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def self.open(path_or_url, ext = nil, options = {}) options, ext = ext, nil if ext.is_a?(Hash) uri = URI(path_or_url.to_s) ext ||= File.extname(uri.path) ext.sub!(/:.*/, '') # hack for filenames or URLs that include a colon if uri.is_a?(URI::HTTP) || uri.is_a?(URI::FTP) uri.open(options) { |file| read(file, ext) } else File.open(uri.to_s, ""rb"", options) { |file| read(file, ext) } end end"
2583,"it ""adds an entry to the group logs when the invited user is added to a group"" do group = Fabricate(:group) InvitedGroup.create(group_id: group.id, invite_id: invite.id) group.add_owner(invite.invited_by) GroupHistory.destroy_all user = InviteRedeemer.new( invite: invite, email: invite.email, username: username, name: name, password: password ).redeem expect(group.reload.usernames.split("","")).to include(user.username) expect(GroupHistory.exists?( target_user_id: user.id, acting_user: invite.invited_by.id, group_id: group.id, action: GroupHistory.actions[:add_user_to_group] )).to eq(true) end",True,Ruby,"""adds an entry to the group logs when the invited user is added to a group""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def decode_compact_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false) unless input.count('.') + 1 == NUM_OF_SEGMENTS raise InvalidFormat.new(""Invalid JWE Format. JWE should include #{NUM_OF_SEGMENTS} segments."") end jwe = new _header_json_, jwe.jwe_encrypted_key, jwe.iv, jwe.cipher_text, jwe.authentication_tag = input.split('.', NUM_OF_SEGMENTS).collect do |segment| begin Base64.urlsafe_decode64 segment rescue ArgumentError raise DecryptionFailed end end jwe.auth_data = input.split('.').first jwe.header = JSON.parse(_header_json_).with_indifferent_access unless private_key_or_secret == :skip_decryption jwe.decrypt! private_key_or_secret, algorithms, encryption_methods end jwe end"
2585,"it ""should redeem an invite but not approve the user when invite is created by a staff user"" do inviter = invite.invited_by inviter.update!(admin: true) user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(user.approved).to eq(false) expect(inviter.notifications.count).to eq(1) end",True,Ruby,"""should redeem an invite but not approve the user when invite is created by a staff user""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def decode_compact_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false) unless input.count('.') + 1 == NUM_OF_SEGMENTS raise InvalidFormat.new(""Invalid JWS Format. JWS should include #{NUM_OF_SEGMENTS} segments."") end header, claims, signature = input.split('.', NUM_OF_SEGMENTS).collect do |segment| Base64.urlsafe_decode64 segment.to_s end header = JSON.parse(header).with_indifferent_access if allow_blank_payload && claims == '' claims = nil else claims = JSON.parse(claims).with_indifferent_access end jws = new claims jws.header = header jws.signature = signature jws.signature_base_string = input.split('.')[0, NUM_OF_SEGMENTS - 1].join('.') jws.verify! public_key_or_secret, algorithms unless public_key_or_secret == :skip_verification jws end"
2586,"it ""can set password"" do user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(false) end",True,Ruby,"""can set password""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def set_member_and_redirect(member) set_member member Member::ActivityLog.create( cur_site: @cur_site, cur_member: member, activity_type: ""login"", remote_addr: remote_addr, user_agent: request.user_agent) ref = @cur_node.make_trusted_full_url(params[:ref] || flash[:ref]) ref = @cur_node.redirect_full_url if ref.blank? ref = @cur_site.full_url if ref.blank? flash.discard(:ref) redirect_to ref end"
2587,"it ""should redeem the invite but not approve the user when invite is created by a regular user"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(user.approved).to eq(false) expect(inviter.notifications.count).to eq(1) end",True,Ruby,"""should redeem the invite but not approve the user when invite is created by a regular user""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def login_success if params[:ref].blank? redirect_to default_logged_in_path elsif params[:ref] =~ /^\/[^\/]/ redirect_to params[:ref] else render ""sns/login/redirect"" end end"
2591,"it ""only allows one user to be created per invite"" do user = invite_redeemer.redeem invite.reload user.email = ""john@example.com"" user.save! another_invite_redeemer = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name) another_user = another_invite_redeemer.redeem expect(another_user).to eq(nil) end",True,Ruby,"""only allows one user to be created per invite""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def update if @application.update(application_params) flash[:notice] = I18n.t(:notice, scope: i18n_scope(:update)) respond_to do |format| format.html { redirect_to oauth_application_url(@application) } format.json { render json: @application, as_owner: true } end else respond_to do |format| format.html { render :edit } format.json do errors = @application.errors.full_messages render json: { errors: errors }, status: :unprocessable_entity end end end end"
2592,"it ""should correctly update the invite redeemed_at date"" do SiteSetting.invite_expiry_days = 2 invite.update!(created_at: 10.days.ago) inviter = invite.invited_by inviter.admin = true user = invite_redeemer.redeem invite.reload expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(invite.invited_users.first).to be_present end",True,Ruby,"""should correctly update the invite redeemed_at date""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def show respond_to do |format| format.html format.json { render json: @application, as_owner: true } end end"
2593,"it ""does not add user to group if inviter does not have permissions"" do group = Fabricate(:group, grant_trust_level: 2) InvitedGroup.create(group_id: group.id, invite_id: invite.id) user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user.group_users.count).to eq(0) end",True,Ruby,"""does not add user to group if inviter does not have permissions""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def create @application = Doorkeeper.config.application_model.new(application_params) if @application.save flash[:notice] = I18n.t(:notice, scope: %i[doorkeeper flash applications create]) flash[:application_secret] = @application.plaintext_secret respond_to do |format| format.html { redirect_to oauth_application_url(@application) } format.json { render json: @application, as_owner: true } end else respond_to do |format| format.html { render :new } format.json do errors = @application.errors.full_messages render json: { errors: errors }, status: :unprocessable_entity end end end end"
2595,"it ""should delete invite if invited_by user has been removed"" do invite.invited_by.destroy! expect { invite.reload }.to raise_error(ActiveRecord::RecordNotFound) end",True,Ruby,"""should delete invite if invited_by user has been removed""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def index @applications = Doorkeeper.config.application_model.authorized_for(current_resource_owner) respond_to do |format| format.html format.json { render json: @applications, current_resource_owner: current_resource_owner } end end"
2602,"it 'redirects to the first topic the user was invited to and creates the topic notification' do topic = Fabricate(:topic) TopicInvite.create!(invite: invite, topic: topic) put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(200) expect(response.parsed_body['redirect_to']).to eq(topic.relative_url) expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1) end",True,Ruby,'redirects to the first topic the user was invited to and creates the topic notification',invites_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def as_json(options = {}) # if application belongs to some owner we need to check if it's the same as # the one passed in the options or check if we render the client as an owner if (respond_to?(:owner) && owner && owner == options[:current_resource_owner]) || options[:as_owner] # Owners can see all the client attributes, fallback to ActiveModel serialization super else # if application has no owner or it's owner doesn't match one from the options # we render only minimum set of attributes that could be exposed to a public only = extract_serializable_attributes(options) super(options.merge(only: only)) end end"
2603,"it ""does not try to log in the user automatically"" do expect do put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } end.not_to change { UserAuthToken.count } expect(response.status).to eq(200) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success"")) end",True,Ruby,"""does not try to log in the user automatically""",invites_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"it ""respects custom options"" do expect(app.as_json(except: :id)).not_to include(""id"") expect(app.as_json(only: %i[name created_at secret])) .to match( ""name"" => app.name, ""created_at"" => an_instance_of(String), ) end"
2605,"it ""errors if the user's email domain doesn't match the invite domain"" do user.update!(email: ""blah@test.com"") invite.update!(email: nil, domain: ""example.com"") put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(412) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.domain_not_allowed"")) end",True,Ruby,"""errors if the user's email domain doesn't match the invite domain""",invites_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def handle_meta(message, local, &callback) method = method_for(message) unless method response = make_response(message) response['error'] = Faye::Error.channel_forbidden(message['channel']) response['successful'] = false return callback.call([response]) end __send__(method, message, local) do |responses| responses = [responses].flatten responses.each { |r| advize(r, message['connectionType']) } callback.call(responses) end end"
2611,"it 'redeems the invitation and creates the invite accepted notification' do put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(200) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success"")) invite.reload expect(invite.invited_users.first.user).to eq(user) expect(invite.redeemed?).to be_truthy expect( Notification.exists?( user: invite.invited_by, notification_type: Notification.types[:invitee_accepted] ) ).to eq(true) end",True,Ruby,'redeems the invitation and creates the invite accepted notification',invites_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def authenticate(*credentials, &block) raise ArgumentError, 'at least 2 arguments required' if credentials.size < 2 if credentials[0].blank? return authentication_response(return_value: false, failure: :invalid_login, &block) end if @sorcery_config.downcase_username_before_authenticating credentials[0].downcase! end user = sorcery_adapter.find_by_credentials(credentials) unless user return authentication_response(failure: :invalid_login, &block) end set_encryption_attributes if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication? return authentication_response(user: user, failure: :inactive, &block) end @sorcery_config.before_authenticate.each do |callback| success, reason = user.send(callback) unless success return authentication_response(user: user, failure: reason, &block) end end unless user.valid_password?(credentials[1]) return authentication_response(user: user, failure: :invalid_password, &block) end authentication_response(user: user, return_value: user, &block) end"
2614,"it ""errors if the user's email doesn't match the invite email"" do user.update!(email: ""blah@test.com"") put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key } expect(response.status).to eq(412) expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.not_matching_email"")) end",True,Ruby,"""errors if the user's email doesn't match the invite email""",invites_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-14 12:02:06+10:00,"SECURITY: Prevent email from being nil in InviteRedeemer (#19004)

This commit adds some protections in InviteRedeemer to ensure that email
can never be nil, which could cause issues with inviting the invited
person to private topics since there was an incorrect inner join.

If the email is nil and the invite is scoped to an email, we just use
that invite.email unconditionally.  If a redeeming_user (an existing
user) is passed in when redeeming an email, we use their email to
override the passed in email.  Otherwise we just use the passed in
email.  We now raise an error after all this if the email is still nil.
This commit also adds some tests to catch the private topic fix, and
some general improvements and comments around the invite code.

This commit also includes a migration to delete TopicAllowedUser records
for users who were mistakenly added to topics as part of the invite
redemption process.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-39385,"def handle_request(client, lines, requests) env = client.env io = client.io # io may be a MiniSSL::Socket return false if closed_socket?(io) normalize_env env, client env[PUMA_SOCKET] = io if env[HTTPS_KEY] && io.peercert env[PUMA_PEERCERT] = io.peercert end env[HIJACK_P] = true env[HIJACK] = client body = client.body head = env[REQUEST_METHOD] == HEAD env[RACK_INPUT] = body env[RACK_URL_SCHEME] ||= default_server_port(env) == PORT_443 ? HTTPS : HTTP if @early_hints env[EARLY_HINTS] = lambda { |headers| begin fast_write io, str_early_hints(headers) rescue ConnectionError => e @log_writer.debug_error e # noop, if we lost the socket we just won't send the early hints end } end req_env_post_parse env # A rack extension. If the app writes #call'ables to this # array, we will invoke them when the request is done. # after_reply = env[RACK_AFTER_REPLY] = [] begin begin status, headers, res_body = @thread_pool.with_force_shutdown do @app.call(env) end return :async if client.hijacked status = status.to_i if status == -1 unless headers.empty? and res_body == [] raise ""async response must have empty headers and body"" end return :async end rescue ThreadPool::ForceShutdown => e @log_writer.unknown_error e, client, ""Rack app"" @log_writer.log ""Detected force shutdown of a thread"" status, headers, res_body = lowlevel_error(e, env, 503) rescue Exception => e @log_writer.unknown_error e, client, ""Rack app"" status, headers, res_body = lowlevel_error(e, env, 500) end res_info = {} res_info[:content_length] = nil res_info[:no_body] = head res_info[:content_length] = if res_body.kind_of? Array and res_body.size == 1 res_body[0].bytesize else nil end cork_socket io str_headers(env, status, headers, res_info, lines, requests, client) line_ending = LINE_END content_length = res_info[:content_length] if res_body && !res_body.respond_to?(:each) response_hijack = res_body else response_hijack = res_info[:response_hijack] end if res_info[:no_body] if content_length and status != 204 lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending end lines << LINE_END fast_write io, lines.to_s return res_info[:keep_alive] end if content_length lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending chunked = false elsif !response_hijack and res_info[:allow_chunked] lines << TRANSFER_ENCODING_CHUNKED chunked = true end lines << line_ending fast_write io, lines.to_s if response_hijack response_hijack.call io return :async end begin res_body.each do |part| next if part.bytesize.zero? if chunked fast_write io, (part.bytesize.to_s(16) << line_ending) fast_write io, part # part may have different encoding fast_write io, line_ending else fast_write io, part end io.flush end if chunked fast_write io, CLOSE_CHUNKED io.flush end rescue SystemCallError, IOError raise ConnectionError, ""Connection error detected during write"" end ensure begin uncork_socket io body.close client.tempfile.unlink if client.tempfile ensure # Whatever happens, we MUST call `close` on the response body. # Otherwise Rack::BodyProxy callbacks may not fire and lead to various state leaks res_body.close if res_body.respond_to? :close end after_reply.each { |o| o.call } end"
2617,"def index user = if params[:username] && !params[:recent] user_record = User.find_by(username: params[:username].to_s) raise Discourse::NotFound if !user_record user_record else current_user end guardian.ensure_can_see_notifications!(user) if notification_types = params[:filter_by_types]&.split("","").presence notification_types.map! do |type| Notification.types[type.to_sym] || ( raise Discourse::InvalidParameters.new(""invalid notification type: #{type}"") ) end end if params[:recent].present? limit = (params[:limit] || 15).to_i limit = 50 if limit > 50 include_reviewables = false if SiteSetting.enable_experimental_sidebar_hamburger notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types) # notification_types is blank for the ""all notifications"" user menu tab include_reviewables = notification_types.blank? && guardian.can_see_review_queue? else notifications = Notification.recent_report(current_user, limit, notification_types) end if notifications.present? && !(params.has_key?(:silent) || @readonly_mode) if changed = current_user.bump_last_seen_notification! current_user.reload current_user.publish_notifications_state end end if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables current_user_id = current_user.id Scheduler::Defer.later ""bump last seen reviewable for user"" do # we lookup current_user again in the background thread to avoid # concurrency issues where the user object returned by the # current_user controller method is changed by the time the deferred # block is executed User.find_by(id: current_user_id)&.bump_last_seen_reviewable! end end json = { notifications: serialize_data(notifications, NotificationSerializer), seen_notification_id: current_user.seen_notification_id } if include_reviewables json[:pending_reviewables] = Reviewable.basic_serializers_for_list( Reviewable.user_menu_list_for(current_user), current_user ).as_json end render_json_dump(json) else offset = params[:offset].to_i notifications = Notification.where(user_id: user.id) .visible .includes(:topic) .order(created_at: :desc) notifications = notifications.where(read: true) if params[:filter] == ""read"" notifications = notifications.where(read: false) if params[:filter] == ""unread"" total_rows = notifications.dup.count notifications = notifications.offset(offset).limit(60) render_json_dump(notifications: serialize_data(notifications, NotificationSerializer), total_rows_notifications: total_rows, seen_notification_id: user.seen_notification_id, load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter])) end end",True,Ruby,index,notifications_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-28 10:41:57+10:00,"SECURITY: Hide notifications for inaccessible topics (#19208)

Filter notifications the user cannot see anymore
via guardian.can_see_topic_ids",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-41944,"def setup_body @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond) if @env[HTTP_EXPECT] == CONTINUE # TODO allow a hook here to check the headers before # going forward @io << HTTP_11_100 @io.flush end @read_header = false body = @parser.body te = @env[TRANSFER_ENCODING2] if te te_lwr = te.downcase if te.include? ',' te_ary = te_lwr.split ',' te_count = te_ary.count CHUNKED te_valid = te_ary[0..-2].all? { |e| ALLOWED_TRANSFER_ENCODING.include? e } if te_ary.last == CHUNKED && te_count == 1 && te_valid @env.delete TRANSFER_ENCODING2 return setup_chunked_body body elsif te_count >= 1 raise HttpParserError , ""#{TE_ERR_MSG}, multiple chunked: '#{te}'"" elsif !te_valid raise HttpParserError501, ""#{TE_ERR_MSG}, unknown value: '#{te}'"" end elsif te_lwr == CHUNKED @env.delete TRANSFER_ENCODING2 return setup_chunked_body body elsif ALLOWED_TRANSFER_ENCODING.include? te_lwr raise HttpParserError , ""#{TE_ERR_MSG}, single value must be chunked: '#{te}'"" else raise HttpParserError501 , ""#{TE_ERR_MSG}, unknown value: '#{te}'"" end end @chunked_body = false cl = @env[CONTENT_LENGTH] if cl # cannot contain characters that are not \d, or be empty if CONTENT_LENGTH_VALUE_INVALID.match?(cl) || cl.empty? raise HttpParserError, ""Invalid Content-Length: #{cl.inspect}"" end else @buffer = body.empty? ? nil : body @body = EmptyBody set_ready return true end remain = cl.to_i - body.bytesize if remain <= 0 @body = StringIO.new(body) @buffer = nil set_ready return true end if remain > MAX_BODY @body = Tempfile.new(Const::PUMA_TMP_BASE) @body.unlink @body.binmode @tempfile = @body else # The body[0,0] trick is to get an empty string in the same # encoding as body. @body = StringIO.new body[0,0] end @body.write body @body_remain = remain false end"
2620,"def validate_message_length(message) return if message.length <= WEBHOOK_MAX_MESSAGE_LENGTH raise Discourse::InvalidParameters.new( ""Body cannot be over #{WEBHOOK_MAX_MESSAGE_LENGTH} characters"", ) end",True,Ruby,validate_message_length,incoming_chat_webhooks_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-28 10:48:30+10:00,"SECURITY: Limit chat message char length (#19207)

Only allow maximum of 6000 characters for chat messages when they
are created or edited. A hidden setting can control this limit,
6000 is the default.

There is also a migration here to truncate any existing messages to
6000 characters if the message is already over that and if the
chat_messages table exists. We also set cooked_version to NULL
for those messages so we can identify them for rebake.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2022-41921,"def decode_chunk(chunk) if @partial_part_left > 0 if @partial_part_left <= chunk.size if @partial_part_left > 2 write_chunk(chunk[0..(@partial_part_left-3)]) # skip the \r\n end chunk = chunk[@partial_part_left..-1] @partial_part_left = 0 else if @partial_part_left > 2 if @partial_part_left == chunk.size + 1 # Don't include the last \r write_chunk(chunk[0..(@partial_part_left-3)]) else # don't include the last \r\n write_chunk(chunk) end end @partial_part_left -= chunk.size return false end end if @prev_chunk.empty? io = StringIO.new(chunk) else io = StringIO.new(@prev_chunk+chunk) @prev_chunk = """" end while !io.eof? line = io.gets if line.end_with?(CHUNK_VALID_ENDING) # Puma doesn't process chunk extensions, but should parse if they're # present, which is the reason for the semicolon regex chunk_hex = line.strip[/\A[^;]+/] if CHUNK_SIZE_INVALID.match? chunk_hex raise HttpParserError, ""Invalid chunk size: '#{chunk_hex}'"" end len = chunk_hex.to_i(16) if len == 0 @in_last_chunk = true @body.rewind rest = io.read if rest.bytesize < CHUNK_VALID_ENDING_SIZE @buffer = nil @partial_part_left = CHUNK_VALID_ENDING_SIZE - rest.bytesize return false else # if the next character is a CRLF, set buffer to everything after that CRLF start_of_rest = if rest.start_with?(CHUNK_VALID_ENDING) CHUNK_VALID_ENDING_SIZE else # we have started a trailer section, which we do not support. skip it! rest.index(CHUNK_VALID_ENDING*2) + CHUNK_VALID_ENDING_SIZE*2 end @buffer = rest[start_of_rest..-1] @buffer = nil if @buffer.empty? set_ready return true end end len += 2 part = io.read(len) unless part @partial_part_left = len next end got = part.size case when got == len # proper chunked segment must end with ""\r\n"" if part.end_with? CHUNK_VALID_ENDING write_chunk(part[0..-3]) # to skip the ending \r\n else raise HttpParserError, ""Chunk size mismatch"" end when got <= len - 2 write_chunk(part) @partial_part_left = len - part.size when got == len - 1 # edge where we get just \r but not \n write_chunk(part[0..-2]) @partial_part_left = len - part.size end else @prev_chunk = line return false end"
2627,"it ""publishes a DiscourseEvent for updated messages"" do chat_message = create_chat_message(user1, ""This will be changed"", public_chat_channel) events = DiscourseEvent.track_events { Chat::ChatMessageUpdater.update( guardian: guardian, chat_message: chat_message, new_content: ""Change to this!"", ) } expect(events.map { _1[:event_name] }).to include(:chat_message_edited) end",True,Ruby,"""publishes a DiscourseEvent for updated messages""",chat_message_updater_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-28 10:48:30+10:00,"SECURITY: Limit chat message char length (#19207)

Only allow maximum of 6000 characters for chat messages when they
are created or edited. A hidden setting can control this limit,
6000 is the default.

There is also a migration here to truncate any existing messages to
6000 characters if the message is already over that and if the
chat_messages table exists. We also set cooked_version to NULL
for those messages so we can identify them for rebake.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2022-41921,"def test_large_chunked_request body = nil content_length = nil server_run { |env| body = env['rack.input'].read content_length = env['CONTENT_LENGTH'] [200, {}, [""""]] } header = ""GET / HTTP/1.1\r\nConnection: close\r\nContent-Length: 200\r\nTransfer-Encoding: chunked\r\n\r\n"" chunk_header_size = 6 # 4fb8\r\n # Current implementation reads one chunk of CHUNK_SIZE, then more chunks of size 4096. # We want a chunk to split exactly after ""#{request_body}\r"", before the ""\n"". edge_case_size = Puma::Const::CHUNK_SIZE + 4096 - header.size - chunk_header_size - 1 margin = 0 # 0 for only testing this specific case, increase to test more surrounding sizes (-margin..margin).each do |i| size = edge_case_size + i request_body = '.' * size request = ""#{header}#{size.to_s(16)}\r\n#{request_body}\r\n0\r\n\r\n"" data = send_http_and_read request assert_equal ""HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 0\r\n\r\n"", data assert_equal size, Integer(content_length) assert_equal request_body, body end end"
2629,"it ""errors if a user other than the message user is trying to edit the message"" do og_message = ""This won't be changed!"" chat_message = create_chat_message(user1, og_message, public_chat_channel) new_message = ""2 short"" updater = Chat::ChatMessageUpdater.update( guardian: Guardian.new(Fabricate(:user)), chat_message: chat_message, new_content: new_message, ) expect(updater.failed?).to eq(true) expect(updater.error).to match(Discourse::InvalidAccess) end",True,Ruby,"""errors if a user other than the message user is trying to edit the message""",chat_message_updater_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-11-28 10:48:30+10:00,"SECURITY: Limit chat message char length (#19207)

Only allow maximum of 6000 characters for chat messages when they
are created or edited. A hidden setting can control this limit,
6000 is the default.

There is also a migration here to truncate any existing messages to
6000 characters if the message is already over that and if the
chat_messages table exists. We also set cooked_version to NULL
for those messages so we can identify them for rebake.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2022-41921,"def handle_request(req, lines) @requests_count +=1 env = req.env client = req.io return false if closed_socket?(client) normalize_env env, req env[PUMA_SOCKET] = client if env[HTTPS_KEY] && client.peercert env[PUMA_PEERCERT] = client.peercert end env[HIJACK_P] = true env[HIJACK] = req body = req.body head = env[REQUEST_METHOD] == HEAD env[RACK_INPUT] = body env[RACK_URL_SCHEME] = default_server_port(env) == PORT_443 ? HTTPS : HTTP if @early_hints env[EARLY_HINTS] = lambda { |headers| begin fast_write client, ""HTTP/1.1 103 Early Hints\r\n"".freeze headers.each_pair do |k, vs| if vs.respond_to?(:to_s) && !vs.to_s.empty? vs.to_s.split(NEWLINE).each do |v| next if possible_header_injection?(v) fast_write client, ""#{k}: #{v}\r\n"" end else fast_write client, ""#{k}: #{vs}\r\n"" end end fast_write client, ""\r\n"".freeze rescue ConnectionError # noop, if we lost the socket we just won't send the early hints end } end # A rack extension. If the app writes #call'ables to this # array, we will invoke them when the request is done. # after_reply = env[RACK_AFTER_REPLY] = [] begin begin status, headers, res_body = @app.call(env) return :async if req.hijacked status = status.to_i if status == -1 unless headers.empty? and res_body == [] raise ""async response must have empty headers and body"" end return :async end rescue ThreadPool::ForceShutdown => e @events.log ""Detected force shutdown of a thread, returning 503"" @events.unknown_error self, e, ""Rack app"" status = 503 headers = {} res_body = [""Request was internally terminated early\n""] rescue Exception => e @events.unknown_error self, e, ""Rack app"", env status, headers, res_body = lowlevel_error(e, env) end content_length = nil no_body = head if res_body.kind_of? Array and res_body.size == 1 content_length = res_body[0].bytesize end cork_socket client line_ending = LINE_END colon = COLON http_11 = if env[HTTP_VERSION] == HTTP_11 allow_chunked = true keep_alive = env.fetch(HTTP_CONNECTION, """").downcase != CLOSE include_keepalive_header = false # An optimization. The most common response is 200, so we can # reply with the proper 200 status without having to compute # the response header. # if status == 200 lines << HTTP_11_200 else lines.append ""HTTP/1.1 "", status.to_s, "" "", fetch_status_code(status), line_ending no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status] end true else allow_chunked = false keep_alive = env.fetch(HTTP_CONNECTION, """").downcase == KEEP_ALIVE include_keepalive_header = keep_alive # Same optimization as above for HTTP/1.1 # if status == 200 lines << HTTP_10_200 else lines.append ""HTTP/1.0 "", status.to_s, "" "", fetch_status_code(status), line_ending no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status] end false end response_hijack = nil headers.each do |k, vs| case k.downcase when CONTENT_LENGTH2 next if possible_header_injection?(vs) content_length = vs next when TRANSFER_ENCODING allow_chunked = false content_length = nil when HIJACK response_hijack = vs next end if vs.respond_to?(:to_s) && !vs.to_s.empty? vs.to_s.split(NEWLINE).each do |v| next if possible_header_injection?(v) lines.append k, colon, v, line_ending end else lines.append k, colon, line_ending end end"
2654,"def show(for_card: false) return redirect_to path('/login') if SiteSetting.hide_user_profiles_from_public && !current_user @user = fetch_user_from_params( include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts) ) user_serializer = nil if guardian.can_see_profile?(@user) serializer_class = for_card ? UserCardSerializer : UserSerializer user_serializer = serializer_class.new(@user, scope: guardian, root: 'user') topic_id = params[:include_post_count_for].to_i if topic_id != 0 user_serializer.topic_post_count = { topic_id => Post.secured(guardian).where(topic_id: topic_id, user_id: @user.id).count } end else user_serializer = HiddenProfileSerializer.new(@user, scope: guardian, root: 'user') end if !params[:skip_track_visit] && (@user != current_user) track_visit_to_user_profile end # This is a hack to get around a Rails issue where values with periods aren't handled correctly # when used as part of a route. if params[:external_id] && params[:external_id].ends_with?('.json') return render_json_dump(user_serializer) end respond_to do |format| format.html do @restrict_fields = guardian.restrict_user_fields?(@user) store_preloaded(""user_#{@user.username}"", MultiJson.dump(user_serializer)) render :show end format.json do render_json_dump(user_serializer) end end end",True,Ruby,show,users_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-05 06:08:19+08:00,"SECURITY: Don't expose user post counts to users who can't see the topic (#19728)

Co-authored-by: Penar Musaraj <pmusaraj@gmail.com>

Co-authored-by: Daniel Waterworth <me@danielwaterworth.com>
Co-authored-by: Penar Musaraj <pmusaraj@gmail.com>",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-22453,"def email_verify_send raise Exceptions::UnprocessableEntity, 'No email!' if !params[:email] user = User.find_by(email: params[:email].downcase) if !user || user.verified == true # result is always positive to avoid leaking of existing user accounts render json: { message: 'ok' }, status: :ok return end Token.create(action: 'Signup', user_id: user.id) result = User.signup_new_token(user) if result && result[:token] user = result[:user] NotificationFactory::Mailer.notification( template: 'signup', user: user, objects: result ) # only if system is in develop mode, send token back to browser for browser tests if Setting.get('developer_mode') == true render json: { message: 'ok', token: result[:token].name }, status: :ok return end # token sent to user, send ok to browser render json: { message: 'ok' }, status: :ok return end # unable to generate token render json: { message: 'failed' }, status: :ok end"
2657,"def self.validate(record, attribute, value, range) if !value.nil? value = get_sanitized_value(value) record.errors.add attribute, (I18n.t('errors.messages.too_short', count: range.begin)) if value.length < range.begin record.errors.add attribute, (I18n.t('errors.messages.too_long_validation', max: range.end, length: value.length)) if value.length > range.end else record.errors.add attribute, (I18n.t('errors.messages.blank')) end",True,Ruby,self.validate,stripped_length_validator.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-05 06:08:43+08:00,"SECURITY: Check the length of raw post body (#19733)

Co-authored-by: Jarek Radosz <jradosz@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-23549,"def password_policy(password) if Setting.get('password_min_size').to_i > password.length return ['Invalid password, it must be at least %s characters long!', Setting.get('password_min_size')] end if Setting.get('password_need_digit').to_i == 1 && password !~ /\d/ return ['Invalid password, it must contain at least 1 digit!'] end if Setting.get('password_min_2_lower_2_upper_characters').to_i == 1 && ( password !~ /[A-Z].*[A-Z]/ || password !~ /[a-z].*[a-z]/ ) return ['Invalid password, it must contain at least 2 lowercase and 2 uppercase characters!'] end true end"
2662,"it ""can be updated"" do user = post_user token = user.email_tokens.first put ""/u/update-activation-email.json"", params: { email: 'updatedemail@example.com' } expect(response.status).to eq(200) user.reload expect(user.email).to eq('updatedemail@example.com') expect(user.email_tokens.where(email: 'updatedemail@example.com', expired: false)).to be_present token.reload expect(token.expired?).to eq(true) end",True,Ruby,"""can be updated""",users_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-05 06:08:55+08:00,"SECURITY: Delete email tokens when a user's email is changed or deleted (#19735)

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>",CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2022-46177,"def self.password_reset_via_token(token, password) # check token user = by_reset_token(token) return if !user # reset password user.update!(password: password, verified: true) # delete token Token.find_by(action: 'PasswordReset', name: token).destroy user end"
2663,"it ""can destroy associated email tokens"" do new_email = 'new.n.cool@example.com' updater = EmailUpdater.new(guardian: user1.guardian, user: user1) expect { updater.change_to(new_email) } .to change { user1.email_tokens.count }.by(1) expect { delete ""/u/#{user1.username}/preferences/email.json"", params: { email: new_email } } .to change { user1.email_tokens.count }.by(-1) expect(user1.email_tokens.first.email).to eq(user1.email) end",True,Ruby,"""can destroy associated email tokens""",users_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-05 06:08:55+08:00,"SECURITY: Delete email tokens when a user's email is changed or deleted (#19735)

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>",CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2022-46177,"def valid?(user, password) return false if user.blank? if PasswordHash.legacy?(user.password, password) update_password(user, password) return true end password_verified = PasswordHash.verified?(user.password, password) raise Exceptions::NotAuthorized, 'Please verify your account before you can login!' if !user.verified && user.source == 'signup' && password_verified password_verified end"
2666,"def set_draft if params[:data].present? ChatDraft.find_or_initialize_by(user: current_user, chat_channel_id: @chat_channel.id).update( data: params[:data], ) else ChatDraft.where(user: current_user, chat_channel_id: @chat_channel.id).destroy_all end render json: success_json end",True,Ruby,set_draft,chat_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-25 13:50:10+02:00,"SECURITY: Limit chat drafts length and preloaded count (#19987)

Only allow maximum of `50_000` characters for chat drafts. A hidden `max_chat_draft_length` setting can control this limit. A migration is also provided to delete any abusive draft in the database.

The number of drafts loaded on current user has also been limited and ordered by most recent update.

Note that spec files moved are not directly related to the fix.

Co-authored-by: Joffrey JAFFEUX <j.jaffeux@gmail.com>
Co-authored-by: Régis Hanol <regis@hanol.fr>",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-22740,"def check_default_at_signup_permissions return true if !default_at_signup forbidden_permissions = permissions.reject(&:allow_signup) return true if forbidden_permissions.blank? raise Exceptions::UnprocessableEntity, ""Cannot set default at signup when role has #{forbidden_permissions.join(', ')} permissions."" end"
2691,"def self.local_upload_html(url) additional_controls = if SiteSetting.disable_onebox_media_download_controls ""controlslist='nodownload'"" else """" end case File.extname(URI(url).path || """") when VIDEO_REGEX <<~HTML <div class=""onebox video-onebox""> <video #{additional_controls} width=""100%"" height=""100%"" controls=""""> <source src='#{url}'> <a href='#{url}'>#{url}</a> </video> </div> HTML when AUDIO_REGEX ""<audio #{additional_controls} controls><source src='#{url}'><a href='#{url}'>#{url}</a></audio>"" end end",True,Ruby,self.local_upload_html,oneboxer.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-25 19:17:21+02:00,"SECURITY: Prevent XSS in local oneboxes (#20008)

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-25172,"it 'does ticket create with agent and articles' do params = { title: 'a new ticket #1', group: 'Users', customer_id: customer.id, article: { body: 'some body', } } authenticated_as(agent) post '/api/v1/tickets', params: params, as: :json expect(response).to have_http_status(:created) params = { ticket_id: json_response['id'], content_type: 'text/plain', # or text/html body: 'some body', type: 'note', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) ticket = Ticket.find(json_response['ticket_id']) expect(ticket.articles.count).to eq(2) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) params = { ticket_id: json_response['ticket_id'], content_type: 'text/html', # or text/html body: 'some body <img src=""data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO 9TXL0Y4OHwAAAABJRU5ErkJggg=="" alt=""Red dot"" />', type: 'note', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).not_to match(/some body <img src=""cid:.+?/) expect(json_response['body']).to match(%r{some body <img src=""/api/v1/ticket_attachment/.+?"" alt=""Red dot""}) expect(json_response['content_type']).to eq('text/html') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(ticket.articles.count).to eq(3) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) expect(ticket.articles[2].attachments.count).to eq(1) expect(ticket.articles[2].attachments[0]['id']).to be_truthy expect(ticket.articles[2].attachments[0]['filename']).to eq('image1.png') expect(ticket.articles[2].attachments[0]['size']).to eq('21') expect(ticket.articles[2].attachments[0]['preferences']['Mime-Type']).to eq('image/png') expect(ticket.articles[2].attachments[0]['preferences']['Content-Disposition']).to eq('inline') expect(ticket.articles[2].attachments[0]['preferences']['Content-ID']).to match(/@zammad.example.com/) params = { ticket_id: json_response['ticket_id'], content_type: 'text/html', # or text/html body: 'some body', type: 'note', attachments: [ { 'filename' => 'some_file.txt', 'data' => 'dGVzdCAxMjM=', 'mime-type' => 'text/plain' }, ], } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/html') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(ticket.articles.count).to eq(4) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) expect(ticket.articles[2].attachments.count).to eq(1) expect(ticket.articles[3].attachments.count).to eq(1) get ""/api/v1/ticket_articles/#{json_response['id']}?expand=true"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['attachments'].count).to eq(1) expect(json_response['attachments'][0]['id']).to be_truthy expect(json_response['attachments'][0]['filename']).to eq('some_file.txt') expect(json_response['attachments'][0]['size']).to eq('8') expect(json_response['attachments'][0]['preferences']['Mime-Type']).to eq('text/plain') params = { ticket_id: json_response['ticket_id'], content_type: 'text/plain', body: 'some body', type: 'note', internal: false, preferences: { some_key1: 123, highlight: '123', }, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['internal']).to eq(false) expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['preferences']['some_key1']).to eq(123) expect(json_response['preferences']['highlight']).to eq('123') expect(ticket.articles.count).to eq(5) params = { body: 'some body 2', internal: true, preferences: { some_key2: 'abc', highlight: '234', }, } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).not_to eq('some body 2') expect(json_response['internal']).to eq(true) expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['preferences']['some_key1']).to eq(123) expect(json_response['preferences']['some_key2']).not_to eq('abc') expect(json_response['preferences']['highlight']).to eq('234') end"
2692,"def self.each_onebox_link(doc, extra_paths: []) onebox_links = doc.css(""a.#{ONEBOX_CSS_CLASS}"", *extra_paths) if onebox_links.present? onebox_links.each { |link| yield(link[""href""], link) if link[""href""].present? } end doc end HTML5_BLOCK_ELEMENTS ||= %w[ address article aside blockquote canvas center dd div dl dt fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 header hgroup hr li main nav noscript ol output p pre section table tfoot ul video ] def self.apply(string_or_doc, extra_paths: nil) doc = string_or_doc doc = Loofah.fragment(doc) if doc.is_a?(String) changed = false each_onebox_link(doc, extra_paths: extra_paths) do |url, element| onebox, _ = yield(url, element) next if onebox.blank? parsed_onebox = Loofah.fragment(onebox) next if parsed_onebox.children.blank? changed = true parent = element.parent if parent&.node_name&.downcase == ""p"" && parsed_onebox.children.any? { |child| HTML5_BLOCK_ELEMENTS.include?(child.node_name.downcase) } siblings = parent.children element_idx = siblings.find_index(element) before_idx = first_significant_element_index(siblings, element_idx - 1, -1) after_idx = first_significant_element_index(siblings, element_idx + 1, +1) if before_idx < 0 && after_idx >= siblings.size parent.replace parsed_onebox elsif before_idx < 0 parent.children = siblings[after_idx..siblings.size] parent.add_previous_sibling(parsed_onebox) elsif after_idx >= siblings.size parent.children = siblings[0..before_idx] parent.add_next_sibling(parsed_onebox) else parent_rest = parent.dup parent.children = siblings[0..before_idx] parent_rest.children = siblings[after_idx..siblings.size] parent.add_next_sibling(parent_rest) parent.add_next_sibling(parsed_onebox) end else element.replace parsed_onebox end end Result.new(doc, changed) end def self.first_significant_element_index(elements, index, step) while index >= 0 && index < elements.size && ( elements[index].node_name.downcase == ""br"" || ( elements[index].node_name.downcase == ""text"" && elements[index].to_html.strip.blank? ) ) index = index + step end index end def self.is_previewing?(user_id) Discourse.redis.get(preview_key(user_id)) == ""1"" end def self.preview_onebox!(user_id) Discourse.redis.setex(preview_key(user_id), 1.minute, ""1"") end def self.onebox_previewed!(user_id) Discourse.redis.del(preview_key(user_id)) end def self.engine(url) Onebox::Matcher.new( url, { allowed_iframe_regexes: Onebox::Engine.origins_to_regexes(allowed_iframe_origins) }, ).oneboxed end def self.recently_failed?(url) Discourse.cache.read(onebox_failed_cache_key(url)).present? end def self.cache_failed!(url) Discourse.cache.write(onebox_failed_cache_key(url), true, expires_in: 1.hour) end private def self.preview_key(user_id) ""onebox:preview:#{user_id}"" end def self.blank_onebox { preview: """", onebox: """" } end def self.onebox_cache_key(url) ""onebox__#{url}"" end def self.onebox_failed_cache_key(url) ""onebox_failed__#{url}"" end def self.onebox_raw(url, opts = {}) url = UrlHelper.normalized_encode(url).to_s local_onebox(url, opts) || external_onebox(url) rescue => e # no point warning here, just cause we have an issue oneboxing a url # we can later hunt for failed oneboxes by searching logs if needed Rails.logger.info(""Failed to onebox #{url} #{e} #{e.backtrace}"") # return a blank hash, so rest of the code works blank_onebox end def self.local_onebox(url, opts = {}) return unless route = Discourse.route_for(url) html = case route[:controller] when ""uploads"" local_upload_html(url) when ""topics"" local_topic_html(url, route, opts) when ""users"" local_user_html(url, route) when ""list"" local_category_html(url, route) else if handler = local_handlers[route[:controller]] handler.call(url, route) end end html = html.presence || ""<a href='#{URI(url).to_s}'>#{URI(url).to_s}</a>"" { onebox: html, preview: html } end",True,Ruby,self.each_onebox_link,oneboxer.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-25 19:17:21+02:00,"SECURITY: Prevent XSS in local oneboxes (#20008)

Co-authored-by: OsamaSayegh <asooomaasoooma90@gmail.com>",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-25172,"it 'does ticket with correct ticket id (02.05)' do ticket = create( :ticket, title: 'ticket with corret ticket id', group: ticket_group, customer_id: customer.id, ) authenticated_as(admin) get ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq('ticket with corret ticket id') expect(json_response['customer_id']).to eq(ticket.customer_id) expect(json_response['updated_by_id']).to eq(1) expect(json_response['created_by_id']).to eq(1) params = { title: 'ticket with corret ticket id - 2', customer_id: agent.id, } put ""/api/v1/tickets/#{ticket.id}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq('ticket with corret ticket id - 2') expect(json_response['customer_id']).to eq(agent.id) expect(json_response['updated_by_id']).to eq(admin.id) expect(json_response['created_by_id']).to eq(1) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq('Tickets Admin') expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(false) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) params = { subject: 'new subject', internal: true, } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq('Tickets Admin') expect(json_response['subject']).not_to eq('new subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:ok) params = { ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Admin via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(false) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) delete ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) end"
2696,"def self.tag_counts_json(tags, guardian) show_pm_tags = guardian.can_tag_pms? target_tags = Tag.where(id: tags.map(&:target_tag_id).compact.uniq).select(:id, :name) tags .map do |t| topic_count = t.public_send(Tag.topic_count_column(guardian)) next if topic_count == 0 && t.pm_topic_count > 0 && !show_pm_tags { id: t.name, text: t.name, name: t.name, description: t.description, count: topic_count, pm_count: show_pm_tags ? t.pm_topic_count : 0, target_tag: t.target_tag_id ? target_tags.find { |x| x.id == t.target_tag_id }&.name : nil, } end .compact end",True,Ruby,self.tag_counts_json,tags_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-31 12:08:23+08:00,"SECURITY: Hide PM count for tags by default (#20061)

Currently `Topic#pm_topic_count` is a count of all personal messages tagged for a given tag. As a result, any user with access to PM tags can poll a sensitive tag to determine if a new personal message has been created using that tag even if the user does not have access to the personal message. We classify this as a minor leak in sensitive information.

With this commit, `Topic#pm_topic_count` is hidden from users by default unless the `display_personal_messages_tag_counts` site setting is enabled.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-23935,"it 'does ticket with correct ticket id (02.04)' do title = ""ticket with corret ticket id testagent#{rand(999_999_999)}"" ticket = create( :ticket, title: title, group: ticket_group, customer_id: customer.id, preferences: { some_key1: 123, }, ) authenticated_as(agent) get ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq(title) expect(json_response['customer_id']).to eq(ticket.customer_id) expect(json_response['updated_by_id']).to eq(1) expect(json_response['created_by_id']).to eq(1) expect(json_response['preferences']['some_key1']).to eq(123) params = { title: ""#{title} - 2"", customer_id: agent.id, preferences: { some_key2: 'abc', }, } put ""/api/v1/tickets/#{ticket.id}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq(""#{title} - 2"") expect(json_response['customer_id']).to eq(agent.id) expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(1) expect(json_response['preferences']['some_key1']).to eq(123) expect(json_response['preferences']['some_key2']).to eq('abc') params = { ticket_id: ticket.id, subject: 'some subject', body: 'some body', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) article_json_response = json_response expect(article_json_response).to be_a_kind_of(Hash) expect(article_json_response['ticket_id']).to eq(ticket.id) expect(article_json_response['from']).to eq('Tickets Agent') expect(article_json_response['subject']).to eq('some subject') expect(article_json_response['body']).to eq('some body') expect(article_json_response['content_type']).to eq('text/plain') expect(article_json_response['internal']).to eq(false) expect(article_json_response['created_by_id']).to eq(agent.id) expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) Scheduler.worker(true) get ""/api/v1/tickets/search?query=#{CGI.escape(title)}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['tickets'][0]).to eq(ticket.id) expect(json_response['tickets_count']).to eq(1) params = { condition: { 'ticket.title' => { operator: 'contains', value: title, }, }, } post '/api/v1/tickets/search', params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['tickets'][0]).to eq(ticket.id) expect(json_response['tickets_count']).to eq(1) delete ""/api/v1/ticket_articles/#{article_json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:ok) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', internal: true, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Agent via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) params = { subject: 'new subject', } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Agent via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).not_to eq('new subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', internal: false, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response['internal']).to eq(false) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) expect(json_response).to be_a_kind_of(Hash) expect(json_response['error']).to eq('Not authorized (communication articles cannot be deleted)!') delete ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) expect(json_response).to be_a_kind_of(Hash) expect(json_response['error']).to eq('Not authorized (admin permission required)!') end"
2699,"it ""shows topic tags and pm tags"" do get ""/tags.json"" tags = response.parsed_body[""tags""] expect(tags.length).to eq(2) serialized_tag = tags.find { |t| t[""id""] == topic_tag.name } expect(serialized_tag[""count""]).to eq(2) expect(serialized_tag[""pm_count""]).to eq(0) serialized_tag = tags.find { |t| t[""id""] == test_tag.name } expect(serialized_tag[""count""]).to eq(0) expect(serialized_tag[""pm_count""]).to eq(1) end",True,Ruby,"""shows topic tags and pm tags""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-31 12:08:23+08:00,"SECURITY: Hide PM count for tags by default (#20061)

Currently `Topic#pm_topic_count` is a count of all personal messages tagged for a given tag. As a result, any user with access to PM tags can poll a sensitive tag to determine if a new personal message has been created using that tag even if the user does not have access to the personal message. We classify this as a minor leak in sensitive information.

With this commit, `Topic#pm_topic_count` is hidden from users by default unless the `display_personal_messages_tag_counts` site setting is enabled.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-23935,"def access?(query) ticket = Ticket.lookup(id: record.ticket_id) return false if record.internal == true && !TicketPolicy.new(user, ticket).agent_read_access? Pundit.authorize(user, ticket, query) end"
2701,"it ""retrieves all tags as a staff user"" do sign_in(admin) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] expect(tags[0][""name""]).to eq(test_tag.name) expect(tags[0][""count""]).to eq(0) expect(tags[0][""pm_count""]).to eq(0) expect(tags[1][""name""]).to eq(topic_tag.name) expect(tags[1][""count""]).to eq(1) expect(tags[1][""pm_count""]).to eq(0) end",True,Ruby,"""retrieves all tags as a staff user""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-31 12:08:23+08:00,"SECURITY: Hide PM count for tags by default (#20061)

Currently `Topic#pm_topic_count` is a count of all personal messages tagged for a given tag. As a result, any user with access to PM tags can poll a sensitive tag to determine if a new personal message has been created using that tag even if the user does not have access to the personal message. We classify this as a minor leak in sensitive information.

With this commit, `Topic#pm_topic_count` is hidden from users by default unless the `display_personal_messages_tag_counts` site setting is enabled.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-23935,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif !Rack::Utils.secure_compare(signature, generate_signature(string)) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end"
2702,"it ""returns the right tags and categories tags for admin user"" do category.update!(tags: [test_tag]) sign_in(admin) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] expect(tags.length).to eq(2) expect(tags[0][""name""]).to eq(test_tag.name) expect(tags[0][""text""]).to eq(test_tag.name) expect(tags[0][""description""]).to eq(test_tag.description) expect(tags[0][""count""]).to eq(0) expect(tags[0][""pm_count""]).to eq(0) expect(tags[0][""target_tag""]).to eq(nil) expect(tags[1][""name""]).to eq(topic_tag.name) categories = response.parsed_body[""extras""][""categories""] expect(categories[0][""id""]).to eq(category.id) expect(categories[0][""tags""].length).to eq(1) expect(categories[0][""tags""][0][""name""]).to eq(test_tag.name) expect(categories[0][""tags""][0][""text""]).to eq(test_tag.name) expect(categories[0][""tags""][0][""description""]).to eq(test_tag.description) expect(categories[0][""tags""][0][""count""]).to eq(0) expect(categories[0][""tags""][0][""pm_count""]).to eq(0) expect(categories[0][""tags""][0][""target_tag""]).to eq(nil) end",True,Ruby,"""returns the right tags and categories tags for admin user""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-31 12:08:23+08:00,"SECURITY: Hide PM count for tags by default (#20061)

Currently `Topic#pm_topic_count` is a count of all personal messages tagged for a given tag. As a result, any user with access to PM tags can poll a sensitive tag to determine if a new personal message has been created using that tag even if the user does not have access to the personal message. We classify this as a minor leak in sensitive information.

With this commit, `Topic#pm_topic_count` is hidden from users by default unless the `display_personal_messages_tag_counts` site setting is enabled.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-23935,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif !Rack::Utils.secure_compare(signature, generate_signature(string)) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end"
2703,"it ""only retrieve tags that have been used in public topics for non-staff user"" do sign_in(user) get ""/tags.json"" expect(response.status).to eq(200) tags = response.parsed_body[""tags""] expect(tags.length).to eq(1) expect(tags[0][""name""]).to eq(topic_tag.name) expect(tags[0][""count""]).to eq(1) expect(tags[0][""pm_count""]).to eq(0) end",True,Ruby,"""only retrieve tags that have been used in public topics for non-staff user""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2023-01-31 12:08:23+08:00,"SECURITY: Hide PM count for tags by default (#20061)

Currently `Topic#pm_topic_count` is a count of all personal messages tagged for a given tag. As a result, any user with access to PM tags can poll a sensitive tag to determine if a new personal message has been created using that tag even if the user does not have access to the personal message. We classify this as a minor leak in sensitive information.

With this commit, `Topic#pm_topic_count` is hidden from users by default unless the `display_personal_messages_tag_counts` site setting is enabled.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-23935,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif !Rack::Utils.secure_compare(signature, generate_signature(string)) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end"
2709,"def perform_show_response if request.head? head :ok return end topic_view_serializer = TopicViewSerializer.new( @topic_view, scope: guardian, root: false, include_raw: !!params[:include_raw], exclude_suggested_and_related: !!params[:replies_to_post_number] || !!params[:filter_upwards_post_id] || !!params[:filter_top_level_replies], ) respond_to do |format| format.html do @tags = SiteSetting.tagging_enabled ? @topic_view.topic.tags : [] @breadcrumbs = helpers.categories_breadcrumb(@topic_view.topic) || [] @description_meta = @topic_view.topic.excerpt.present? ? @topic_view.topic.excerpt : @topic_view.summary store_preloaded(""topic_#{@topic_view.topic.id}"", MultiJson.dump(topic_view_serializer)) render :show end format.json { render_json_dump(topic_view_serializer) } end end",True,Ruby,perform_show_response,topics_controller.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-02-23 17:22:20+01:00,"SECURITY: Show only visible tags in metadata

Currently, the topic metadata show both public and private
tags whereas only visible ones should be exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-25819,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif !Rack::Utils.secure_compare(signature, generate_signature(string)) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end"
2710,def tags @topic.tags.map(&:name) end,True,Ruby,tags,topic_view.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-02-23 17:22:20+01:00,"SECURITY: Show only visible tags in metadata

Currently, the topic metadata show both public and private
tags whereas only visible ones should be exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-25819,"def rs256_decode_key(kid) jwks_x5c = jwks_key(:x5c, kid) if jwks_x5c.nil? raise OmniAuth::Auth0::TokenValidationError.new(""Could not find a public key for Key ID (kid) '#{kid}'"") end jwks_public_cert(jwks_x5c.first) end"
2711,"def page_title title = @topic.title if @post_number > 1 title += "" - "" post = @topic.posts.find_by(post_number: @post_number) author = post&.user if author && @guardian.can_see_post?(post) title += I18n.t( ""inline_oneboxer.topic_page_title_post_number_by_user"", post_number: @post_number, username: author.username, ) else title += I18n.t(""inline_oneboxer.topic_page_title_post_number"", post_number: @post_number) end end if SiteSetting.topic_page_title_includes_category if @topic.category_id != SiteSetting.uncategorized_category_id && @topic.category_id && @topic.category title += "" - #{@topic.category.name}"" elsif SiteSetting.tagging_enabled && @topic.tags.exists? title += "" - #{@topic.tags.order(""tags.#{Tag.topic_count_column(@guardian)} DESC"").first.name}"" end end title end",True,Ruby,page_title,topic_view.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-02-23 17:22:20+01:00,"SECURITY: Show only visible tags in metadata

Currently, the topic metadata show both public and private
tags whereas only visible ones should be exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-25819,"def verify_signature(jwt) head = token_head(jwt) # Make sure the algorithm is supported and get the decode key. if head[:alg] == 'RS256' key, alg = [rs256_decode_key(head[:kid]), head[:alg]] elsif head[:alg] == 'HS256' key, alg = [@client_secret, head[:alg]] else raise OmniAuth::Auth0::TokenValidationError.new(""Signature algorithm of #{head[:alg]} is not supported. Expected the ID token to be signed with RS256 or HS256"") end # Call decode to verify the signature JWT.decode(jwt, key, true, decode_opts(alg)) return key, alg end"
2712,"def find_topic(topic_or_topic_id) return topic_or_topic_id if topic_or_topic_id.is_a?(Topic) # with_deleted covered in #check_and_raise_exceptions Topic.with_deleted.includes(:category, :tags).find_by(id: topic_or_topic_id) end",True,Ruby,find_topic,topic_view.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-02-23 17:22:20+01:00,"SECURITY: Show only visible tags in metadata

Currently, the topic metadata show both public and private
tags whereas only visible ones should be exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-25819,"it 'should return nil if the key ID is invalid' do expect(jwt_validator.jwks_key(:alg, ""#{valid_jwks_kid}_invalid"")).to eq(nil) end"
2717,"it ""returns the tags names"" do expect(topic_view_tags).to match tags.map(&:name) end",True,Ruby,"""returns the tags names""",topic_view_spec.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-02-23 17:22:20+01:00,"SECURITY: Show only visible tags in metadata

Currently, the topic metadata show both public and private
tags whereas only visible ones should be exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2023-25819,"def make_hs256_token(payload = nil, secret = nil) payload = { sub: 'abc123' } if payload.nil? secret = client_secret if secret.nil? JWT.encode payload, secret, 'HS256' end"
2721,"def refresh_disk_space log ""Refreshing disk stats..."" @store.reset_cache rescue => ex log ""Something went wrong while refreshing disk stats."", ex end",True,Ruby,refresh_disk_space,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"it 'should return a key' do expect(jwt_validator.jwks_key(:alg, valid_jwks_kid)).to eq('RS256') end"
2726,"def run ensure_no_operation_is_running ensure_we_have_a_user log ""[STARTED]"" log ""'#{@user.username}' has started the backup!"" mark_backup_as_running listen_for_shutdown_signal ensure_directory_exists(@tmp_directory) ensure_directory_exists(@archive_directory) update_metadata dump_public_schema log ""Finalizing backup..."" @with_uploads ? create_archive : move_dump_backup upload_archive after_create_hook rescue SystemExit log ""Backup process was cancelled!"" rescue Exception => ex log ""EXCEPTION: "" + ex.message log ex.backtrace.join(""\n"") @success = false else @success = true @backup_filename ensure delete_old clean_up notify_user log ""Finished!"" publish_completion(@success) end",True,Ruby,run,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"def make_rs256_token(payload = nil, kid = nil) payload = { sub: 'abc123' } if payload.nil? kid = valid_jwks_kid if kid.nil? JWT.encode payload, rsa_private_key, 'RS256', kid: kid end"
2727,"def delete_old return if Rails.env.development? log ""Deleting old backups..."" @store.delete_old rescue => ex log ""Something went wrong while deleting old backups."", ex end",True,Ruby,delete_old,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"it 'should return an x5c key' do expect(jwt_validator.jwks_key(:x5c, valid_jwks_kid).length).to eq(1) end"
2730,"def clean_up log ""Cleaning stuff up..."" delete_uploaded_archive remove_tar_leftovers mark_backup_as_not_running refresh_disk_space end",True,Ruby,clean_up,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"it 'should verify a standard RS256 token' do domain = 'example.org' sub = 'abc123' payload = { sub: sub, exp: future_timecode, iss: ""https://#{domain}/"", iat: past_timecode, aud: client_id } token = make_rs256_token(payload) verified_token = make_jwt_validator(opt_domain: domain).verify(token) expect(verified_token['sub']).to eq(sub) end"
2732,"def upload_archive return unless @store.remote? log ""Uploading archive..."" content_type = MiniMime.lookup_by_filename(@backup_filename).content_type archive_path = File.join(@archive_directory, @backup_filename) @store.upload_file(@backup_filename, archive_path, content_type) end",True,Ruby,upload_archive,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"it 'should return nil if there is not key' do expect(jwt_validator.jwks_key(:auth0, valid_jwks_kid)).to eq(nil) end"
2733,"def publish_completion(success) if success log(""[SUCCESS]"") DiscourseEvent.trigger(:backup_complete, logs: @logs, ticket: @ticket) else log(""[FAILED]"") DiscourseEvent.trigger(:backup_failed, logs: @logs, ticket: @ticket) end end",True,Ruby,publish_completion,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,def spree_current_user return nil unless doorkeeper_token return @spree_current_user if @spree_current_user doorkeeper_authorize! @spree_current_user ||= Spree.user_class.find_by(id: doorkeeper_token.resource_owner_id) end
2734,"def notify_user return if @success && @user.id == Discourse::SYSTEM_USER_ID log ""Notifying '#{@user.username}' of the end of the backup..."" status = @success ? :backup_succeeded : :backup_failed logs = Discourse::Utils.logs_markdown(@logs, user: @user) post = SystemMessage.create_from_system_user(@user, status, logs: logs) post.topic.invite_group(@user, Group[:admins]) if @user.id == Discourse::SYSTEM_USER_ID rescue => ex log ""Something went wrong while notifying user."", ex end",True,Ruby,notify_user,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"def read_body(socket, block) return unless socket if tc = self['transfer-encoding'] case tc when /\Achunked\z/io then read_chunked(socket, block) else raise HTTPStatus::NotImplemented, ""Transfer-Encoding: #{tc}."" end elsif self['content-length'] || @remaining_size @remaining_size ||= self['content-length'].to_i while @remaining_size > 0 sz = [@buffer_size, @remaining_size].min break unless buf = read_data(socket, sz) @remaining_size -= buf.bytesize block.call(buf) end if @remaining_size > 0 && @socket.eof? raise HTTPStatus::BadRequest, ""invalid body size."" end elsif BODY_CONTAINABLE_METHODS.member?(@request_method) && !@socket.eof raise HTTPStatus::LengthRequired end"
2736,"def delete_uploaded_archive return unless @store.remote? archive_path = File.join(@archive_directory, @backup_filename) if File.exist?(archive_path) log ""Removing archive from local storage..."" File.delete(archive_path) end rescue => ex log ""Something went wrong while deleting uploaded archive from local storage."", ex end",True,Ruby,delete_uploaded_archive,backuper.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"def parse(socket=nil) @socket = socket begin @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : [] @addr = socket.respond_to?(:addr) ? socket.addr : [] rescue Errno::ENOTCONN raise HTTPStatus::EOFError end read_request_line(socket) if @http_version.major > 0 read_header(socket) @header['cookie'].each{|cookie| @cookies += Cookie::parse(cookie) } @accept = HTTPUtils.parse_qvalues(self['accept']) @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset']) @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding']) @accept_language = HTTPUtils.parse_qvalues(self['accept-language']) end return if @request_method == ""CONNECT"" return if @unparsed_uri == ""*"" begin setup_forwarded_info @request_uri = parse_uri(@unparsed_uri) @path = HTTPUtils::unescape(@request_uri.path) @path = HTTPUtils::normalize_path(@path) @host = @request_uri.host @port = @request_uri.port @query_string = @request_uri.query @script_name = """" @path_info = @path.dup rescue raise HTTPStatus::BadRequest, ""bad URI `#{@unparsed_uri}'."" end if /\Aclose\z/io =~ self[""connection""] @keep_alive = false elsif /\Akeep-alive\z/io =~ self[""connection""] @keep_alive = true elsif @http_version < ""1.1"" @keep_alive = false else @keep_alive = true end end"
2737,"it ""returns a non-empty parameterized title when site title contains unicode"" do SiteSetting.title = ""Ɣ"" backuper = BackupRestore::Backuper.new(Discourse.system_user.id) expect(backuper.send(:get_parameterized_title)).to eq(""discourse"") end",True,Ruby,"""returns a non-empty parameterized title when site title contains unicode""",backuper_spec.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"def self.dump(object) dumped_json = MultiJson.dump object, mode: :compat, escape_mode: :xss_safe, time_format: :ruby escape(dumped_json) end"
2739,"it ""returns a valid parameterized site title"" do SiteSetting.title = ""Coding Horror"" backuper = BackupRestore::Backuper.new(Discourse.system_user.id) expect(backuper.send(:get_parameterized_title)).to eq(""coding-horror"") end",True,Ruby,"""returns a valid parameterized site title""",backuper_spec.rb,https://github.com/discourse/discourse,discourse,Loïc Guitaut,2023-03-16 16:09:22+01:00,SECURITY: Rate limit the creation of backups,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-28107,"def RelaxNG(string_or_io, options = ParseOptions::DEFAULT_SCHEMA) RelaxNG.new(string_or_io, options) end"
2745,"def self.ip_allowed?(ip) ip = ip.is_a?(IPAddr) ? ip : IPAddr.new(ip) if ip_in_ranges?(ip, blocked_ip_blocks) || ip_in_ranges?(ip, standard_private_ranges) return false end true end",True,Ruby,self.ip_allowed?,ssrf_detector.rb,https://github.com/discourse/discourse,discourse,Blake Erickson,2023-03-16 15:27:09-06:00,"SECURITY: SSRF protection bypass with IPv4-mapped IPv6 addresses

As part of this commit, we've also expanded our list of private IP
ranges based on
https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
and https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2023-28111,"def Schema(string_or_io, options = ParseOptions::DEFAULT_SCHEMA) Schema.new(string_or_io, options) end"
2746,"def self.standard_private_ranges @private_ranges ||= [ IPAddr.new(""0.0.0.0/8""), IPAddr.new(""127.0.0.1""), IPAddr.new(""172.16.0.0/12""), IPAddr.new(""192.168.0.0/16""), IPAddr.new(""10.0.0.0/8""), IPAddr.new(""::1""), IPAddr.new(""fc00::/7""), IPAddr.new(""fe80::/10""), ] end",True,Ruby,self.standard_private_ranges,ssrf_detector.rb,https://github.com/discourse/discourse,discourse,Blake Erickson,2023-03-16 15:27:09-06:00,"SECURITY: SSRF protection bypass with IPv4-mapped IPv6 addresses

As part of this commit, we've also expanded our list of private IP
ranges based on
https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
and https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2023-28111,"def self.new string_or_io, options = ParseOptions::DEFAULT_SCHEMA from_document(Nokogiri::XML(string_or_io), options) end"
2749,"it ""returns false for standard internal IPs"" do expect(subject.ip_allowed?(""172.31.100.31"")).to eq(false) expect(subject.ip_allowed?(""fd02:77fa:ffea::f"")).to eq(false) end",True,Ruby,"""returns false for standard internal IPs""",ssrf_detector_spec.rb,https://github.com/discourse/discourse,discourse,Blake Erickson,2023-03-16 15:27:09-06:00,"SECURITY: SSRF protection bypass with IPv4-mapped IPv6 addresses

As part of this commit, we've also expanded our list of private IP
ranges based on
https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
and https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2023-28111,"def parse_memory(data, encoding = ""UTF-8"") raise TypeError unless String === data return if data.empty? ctx = ParserContext.memory(data, encoding) yield ctx if block_given? ctx.parse_with(self) end"
2752,"def get_size(url) return @size_cache[url] if @size_cache.has_key?(url) absolute_url = url absolute_url = Discourse.base_url_no_prefix + absolute_url if absolute_url =~ %r{\A/[^/]} return unless absolute_url # FastImage fails when there's no scheme absolute_url = SiteSetting.scheme + "":"" + absolute_url if absolute_url.start_with?(""//"") # we can't direct FastImage to our secure-uploads url because it bounces # anonymous requests with a 404 error if url && Upload.secure_uploads_url?(url) absolute_url = Upload.signed_url_from_secure_uploads_url(absolute_url) end return unless is_valid_image_url?(absolute_url) upload = Upload.get_from_url(absolute_url) if upload && upload.width && upload.width > 0 @size_cache[url] = [upload.width, upload.height] else @size_cache[url] = FastImage.size(absolute_url) end rescue Zlib::BufError, URI::Error, OpenSSL::SSL::SSLError # FastImage.size raises BufError for some gifs, leave it. end",True,Ruby,get_size,cooked_processor_mixin.rb,https://github.com/discourse/discourse,discourse,Blake Erickson,2023-03-16 15:27:09-06:00,SECURITY: Add FinalDestination::FastImage that's SSRF safe,CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2023-28112,def test_parse_memory_nil assert_raises(TypeError) do @parser.parse_memory(nil) end end
2772,def self.google_tag_manager_nonce(env) env[:discourse_content_security_policy_nonce] ||= SecureRandom.hex end,True,Ruby,self.google_tag_manager_nonce,application_helper.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,def email id_info['email'] end
2773,"def policy(theme_id = nil, env: {}, base_url: Discourse.base_url, path_info: ""/"") new.build(theme_id, env: env, base_url: base_url, path_info: path_info) end",True,Ruby,policy,content_security_policy.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def link(link, title, content) attributes = [ (""href=\""#{link}\"""" if link), (""title=\""#{title}\"""" if title), (""target=\""_blank\"" rel=\""noopener\"""" if link.match?(PROTOCOL_MATCHER)), ] ""<a #{attributes.compact.join("" "")}>#{content}</a>"" end"
2774,"def build(theme_id, env: {}, base_url:, path_info: ""/"") builder = Builder.new(base_url: base_url, env: env) Extension.theme_extensions(theme_id).each { |extension| builder << extension } Extension.plugin_extensions.each { |extension| builder << extension } builder << Extension.site_setting_extension builder << Extension.path_specific_extension(path_info) builder.build end",True,Ruby,build,content_security_policy.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def text(key, options = {}) options = html_safe_options(options) text = I18n.t(key, **{ scope: self.translation_scope, default: ""!#{key}!"", cascade: true, }.merge(options)).strip interpolation_options = { cascade: true }.merge(options) # Interpolate any keypaths (e.g., `!some.lookup.path/key!`) found in the text. while text.match?(KEYPATH_MATCHER) do text = text.gsub(KEYPATH_MATCHER) { |match| I18n.t($1, **interpolation_options) } end text = smartify(text) if options.fetch(:smart, true) text.html_safe end"
2778,"def initialize(base_url:, env: {}) @directives = Default.new(base_url: base_url, env: env).directives @base_url = base_url end",True,Ruby,initialize,builder.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def placeholder(filename) css_class = InlineSvg.configuration.svg_not_found_css_class not_found_message = ""'#{ERB::Util.html_escape_once(filename)}' #{extension_hint(filename)}"" if css_class.nil? return ""<svg><!-- SVG file not found: #{not_found_message}--></svg>"".html_safe else return ""<svg class='#{css_class}'><!-- SVG file not found: #{not_found_message}--></svg>"".html_safe end end"
2780,"def initialize(base_url:, env: {}) @base_url = base_url @env = env @directives = {}.tap do |directives| directives[:upgrade_insecure_requests] = [] if SiteSetting.force_https directives[:base_uri] = [:self] directives[:object_src] = [:none] directives[:script_src] = script_src directives[:worker_src] = worker_src directives[ :report_uri ] = report_uri if SiteSetting.content_security_policy_collect_reports directives[:frame_ancestors] = frame_ancestors if restrict_embed? directives[:manifest_src] = [""'self'""] end end",True,Ruby,initialize,default.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,def opposite_direction direction == :asc ? :desc : :asc end
2781,"def script_src [ ""#{base_url}/logs/"", ""#{base_url}/sidekiq/"", ""#{base_url}/mini-profiler-resources/"", *script_assets, ].tap do |sources| sources << :report_sample if SiteSetting.content_security_policy_collect_reports sources << :unsafe_eval if Rails.env.development? # TODO remove this once we have proper source maps in dev # Support Ember CLI Live reload if Rails.env.development? sources << ""#{base_url}/ember-cli-live-reload.js"" sources << ""#{base_url}/_lr/"" end # we need analytics.js still as gtag/js is a script wrapper for it if SiteSetting.ga_universal_tracking_code.present? sources << ""https://www.google-analytics.com/analytics.js"" end if SiteSetting.ga_universal_tracking_code.present? && SiteSetting.ga_version == ""v4_gtag"" sources << ""https://www.googletagmanager.com/gtag/js"" end if SiteSetting.gtm_container_id.present? sources << ""https://www.googletagmanager.com/gtm.js"" sources << ""'nonce-#{ApplicationHelper.google_tag_manager_nonce(@env)}'"" end sources << ""'#{SplashScreenHelper.fingerprint}'"" if SiteSetting.splash_screen end end",True,Ruby,script_src,default.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def initialize(attribute = nil, direction = nil) @attribute = attribute @direction = sanitize_direction(direction) end"
2782,"def call(env) request = Rack::Request.new(env) _, headers, _ = response = @app.call(env) return response unless html_response?(headers) # The EnforceHostname middleware ensures request.host_with_port can be trusted protocol = (SiteSetting.force_https || request.ssl?) ? ""https://"" : ""http://"" base_url = protocol + request.host_with_port + Discourse.base_path theme_id = env[:resolved_theme_id] headers[""Content-Security-Policy""] = policy( theme_id, env: env, base_url: base_url, path_info: env[""PATH_INFO""], ) if SiteSetting.content_security_policy headers[""Content-Security-Policy-Report-Only""] = policy( theme_id, env: env, base_url: base_url, path_info: env[""PATH_INFO""], ) if SiteSetting.content_security_policy_report_only response end",True,Ruby,call,middleware.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def test_post uri = URI('http://localhost:6470/makeme') req = Net::HTTP::Post.new(uri) # Set the headers the way we want them. req['Accept-Encoding'] = '*' req['Accept'] = 'application/json' req['User-Agent'] = 'Ruby' res = Net::HTTP.start(uri.hostname, uri.port) { |h| h.request(req) } assert_equal(Net::HTTPNoContent, res.class) end"
2784,def cacheable? !!(!has_auth_cookie? && get? && no_cache_bypass) end,True,Ruby,cacheable?,anonymous_cache.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def test_put uri = URI('http://localhost:6470/makeme') req = Net::HTTP::Put.new(uri) # Set the headers the way we want them. req['Accept-Encoding'] = '*' req['Accept'] = 'application/json' req['User-Agent'] = 'Ruby' req.body = 'hello' res = Net::HTTP.start(uri.hostname, uri.port) { |h| h.request(req) } assert_equal(Net::HTTPCreated, res.class) assert_equal('hello', res.body) end"
2791,"it ""allowlists Google Tag Manager when integrated"" do SiteSetting.gtm_container_id = ""GTM-ABCDEF"" script_srcs = parse(policy)[""script-src""] expect(script_srcs).to include(""https://www.googletagmanager.com/gtm.js"") expect(script_srcs.to_s).to include(""nonce-"") end",True,Ruby,"""allowlists Google Tag Manager when integrated""",content_security_policy_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,detectExtension(mimeType) { if (!mimeType) { return defaultExtension; } let parts = (mimeType || '').toLowerCase().trim().split('/'); let rootType = parts.shift().trim(); let subType = parts.join('/').trim(); if (mimeTypes.has(rootType + '/' + subType)) { let value = mimeTypes.get(rootType + '/' + subType); if (Array.isArray(value)) { return value[0]; } return value; } switch (rootType) { case 'text': return 'txt'; default: return 'bin'; } }
2797,"it ""doesn't reuse CSP nonces between requests"" do SiteSetting.content_security_policy = true SiteSetting.gtm_container_id = ""GTM-ABCDEF"" get ""/latest"" expect(response.headers).to include(""Content-Security-Policy"") script_src = parse(response.headers[""Content-Security-Policy""])[""script-src""] first_nonce = extract_nonce_from_script_src(script_src) gtm_meta_tag = Nokogiri::HTML5.fragment(response.body).css(""#data-google-tag-manager"").first expect(gtm_meta_tag[""data-nonce""]).to eq(first_nonce) get ""/latest"" expect(response.headers).to include(""Content-Security-Policy"") script_src = parse(response.headers[""Content-Security-Policy""])[""script-src""] second_nonce = extract_nonce_from_script_src(script_src) expect(first_nonce).not_to eq(second_nonce) gtm_meta_tag = Nokogiri::HTML5.fragment(response.body).css(""#data-google-tag-manager"").first expect(gtm_meta_tag[""data-nonce""]).to eq(second_nonce) end",True,Ruby,"""doesn't reuse CSP nonces between requests""",application_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"detectMimeType(filename) { if (!filename) { return defaultMimeType; } let parsed = path.parse(filename); let extension = (parsed.ext.substr(1) || parsed.name || '').split('?').shift().trim().toLowerCase(); let value = defaultMimeType; if (extensions.has(extension)) { value = extensions.get(extension); } if (Array.isArray(value)) { return value[0]; } return value; },"
2798,"it ""when GTM is enabled it adds the same nonce to the policy and the GTM tag"" do SiteSetting.content_security_policy = true SiteSetting.gtm_container_id = ""GTM-ABCDEF"" get ""/latest"" expect(response.headers).to include(""Content-Security-Policy"") script_src = parse(response.headers[""Content-Security-Policy""])[""script-src""] nonce = extract_nonce_from_script_src(script_src) gtm_meta_tag = Nokogiri::HTML5.fragment(response.body).css(""#data-google-tag-manager"").first expect(gtm_meta_tag[""data-nonce""]).to eq(nonce) end",True,Ruby,"""when GTM is enabled it adds the same nonce to the policy and the GTM tag""",application_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:44+01:00,SECURITY: Don't reuse CSP nonce between anonymous requests,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-37467,"def within_bounding_box(sw_lat, sw_lng, ne_lat, ne_lng, lat_attr, lon_attr) spans = ""#{lat_attr} BETWEEN #{sw_lat.to_f} AND #{ne_lat.to_f} AND "" # handle box that spans 180 longitude if sw_lng.to_f > ne_lng.to_f spans + ""(#{lon_attr} BETWEEN #{sw_lng.to_f} AND 180 OR "" + ""#{lon_attr} BETWEEN -180 AND #{ne_lng.to_f})"" else spans + ""#{lon_attr} BETWEEN #{sw_lng.to_f} AND #{ne_lng.to_f}"" end end"
2800,"def index offset = (params[:offset] || 0).to_i limit = (params[:limit] || 50).to_i.clamp(1, 50) keys = ApiKey .where(hidden: false) .includes(:user, :api_key_scopes) # Sort revoked keys by revoked_at and active keys by created_at .order(""revoked_at DESC NULLS FIRST, created_at DESC"") .offset(offset) .limit(limit) render_json_dump(keys: serialize_data(keys, ApiKeySerializer), offset: offset, limit: limit) end",True,Ruby,index,api_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def download(url, remote_headers = {}) headers = remote_headers. reverse_merge('User-Agent' => ""CarrierWave/#{CarrierWave::VERSION}"") uri = process_uri(url.to_s) begin if skip_ssrf_protection?(uri) response = OpenURI.open_uri(process_uri(url.to_s), headers) else request = nil response = SsrfFilter.get(uri, headers: headers) do |req| request = req end response.uri = request.uri response.value end rescue StandardError => e raise CarrierWave::DownloadError, ""could not download file: #{e.message}"" end CarrierWave::Downloader::RemoteFile.new(response) end"
2801,"def parse_params(report_params) begin start_date = ( if report_params[:start_date].present? Time.parse(report_params[:start_date]).to_date else 1.days.ago end ).beginning_of_day end_date = ( if report_params[:end_date].present? Time.parse(report_params[:end_date]).to_date else start_date + 30.days end ).end_of_day rescue ArgumentError => e raise Discourse::InvalidParameters.new(e.message) end facets = nil facets = report_params[:facets].map { |s| s.to_s.to_sym } if Array === report_params[:facets] limit = nil if report_params.has_key?(:limit) && report_params[:limit].to_i > 0 limit = report_params[:limit].to_i end filters = nil filters = report_params[:filters] if report_params.has_key?(:filters) { start_date: start_date, end_date: end_date, filters: filters, facets: facets, limit: limit } end",True,Ruby,parse_params,reports_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def filename_from_header return nil unless headers['content-disposition'] match = headers['content-disposition'].match(/filename=(?:""([^""]+)""|([^"";]+))/) return nil unless match match[1].presence || match[2].presence end"
2803,"def index filters = params.slice(*UserHistory.staff_filters + %i[page limit]) page = (params[:page] || 0).to_i page_size = (params[:limit] || 200).to_i.clamp(1, 200) staff_action_logs = UserHistory.staff_action_records(current_user, filters) count = staff_action_logs.count staff_action_logs = staff_action_logs.offset(page * page_size).limit(page_size).to_a load_more_params = params.permit(UserHistory.staff_filters) load_more_params.merge!(page: page + 1, page_size: page_size) render_json_dump( staff_action_logs: serialize_data(staff_action_logs, UserHistorySerializer), total_rows_staff_action_logs: count, load_more_staff_action_logs: admin_staff_action_logs_path(load_more_params), extras: { user_history_actions: staff_available_actions, }, ) end",True,Ruby,index,staff_action_logs_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def filename_from_uri CGI.unescape(File.basename(uri.path)) end
2807,"def index unless SiteSetting.enable_user_directory? raise Discourse::InvalidAccess.new(:enable_user_directory) end period = params.require(:period) period_type = DirectoryItem.period_types[period.to_sym] raise Discourse::InvalidAccess.new(:period_type) unless period_type result = DirectoryItem.where(period_type: period_type).includes(user: :user_custom_fields) if params[:group] group = Group.find_by(name: params[:group]) raise Discourse::InvalidParameters.new(:group) if group.blank? guardian.ensure_can_see!(group) guardian.ensure_can_see_group_members!(group) result = result.includes(user: :groups).where(users: { groups: { id: group.id } }) else result = result.includes(user: :primary_group) end result = apply_exclude_groups_filter(result) if params[:exclude_usernames] result = result .references(:user) .where.not(users: { username: params[:exclude_usernames].split("","") }) end order = params[:order] || DirectoryColumn.automatic_column_names.first dir = params[:asc] ? ""ASC"" : ""DESC"" active_directory_column_names = DirectoryColumn.active_column_names if active_directory_column_names.include?(order.to_sym) result = result.order(""directory_items.#{order} #{dir}, directory_items.id"") elsif params[:order] === ""username"" result = result.order(""users.#{order} #{dir}, directory_items.id"") else # Ordering by user field value user_field = UserField.find_by(name: params[:order]) if user_field result = result .references(:user) .joins( ""LEFT OUTER JOIN user_custom_fields ON user_custom_fields.user_id = users.id AND user_custom_fields.name = 'user_field_#{user_field.id}'"", ) .order( ""user_custom_fields.name = 'user_field_#{user_field.id}' ASC, user_custom_fields.value #{dir}"", ) end end result = result.includes(:user_stat) if period_type == DirectoryItem.period_types[:all] page = params[:page].to_i user_ids = nil if params[:name].present? user_ids = UserSearch.new(params[:name], include_staged_users: true).search.pluck(:id) if user_ids.present? # Add the current user if we have at least one other match user_ids << current_user.id if current_user && result.dup.where(user_id: user_ids).exists? result = result.where(user_id: user_ids) else result = result.where(""false"") end end if params[:username] user_id = User.where(username_lower: params[:username].to_s.downcase).pick(:id) if user_id result = result.where(user_id: user_id) else result = result.where(""false"") end end limit = [params[:limit].to_i, PAGE_SIZE].min if params[:limit].to_i > 0 limit ||= PAGE_SIZE result_count = result.count result = result.limit(limit).offset(limit * page).to_a more_params = params.slice(:period, :order, :asc, :group, :user_field_ids).permit! more_params[:page] = page + 1 load_more_uri = URI.parse(directory_items_path(more_params)) load_more_directory_items_json = ""#{load_more_uri.path}.json?#{load_more_uri.query}"" # Put yourself at the top of the first page if result.present? && current_user.present? && page == 0 && !params[:group].present? position = result.index { |r| r.user_id == current_user.id } # Don't show the record unless you're not in the top positions already if (position || 10) >= 10 unless @users_in_exclude_groups&.include?(current_user.id) your_item = DirectoryItem.where(period_type: period_type, user_id: current_user.id).first result.insert(0, your_item) if your_item end end end last_updated_at = DirectoryItem.last_updated_at(period_type) serializer_opts = {} if params[:user_field_ids] serializer_opts[:user_custom_field_map] = {} user_field_ids = params[:user_field_ids]&.split(""|"")&.map(&:to_i) user_field_ids.each do |user_field_id| serializer_opts[:user_custom_field_map][ ""#{User::USER_FIELD_PREFIX}#{user_field_id}"" ] = user_field_id end end if params[:plugin_column_ids] serializer_opts[:plugin_column_ids] = params[:plugin_column_ids]&.split(""|"")&.map(&:to_i) end serializer_opts[:attributes] = active_directory_column_names serialized = serialize_data(result, DirectoryItemSerializer, serializer_opts) render_json_dump( directory_items: serialized, meta: { last_updated_at: last_updated_at, total_rows_directory_items: result_count, load_more_directory_items: load_more_directory_items_json, }, ) end",True,Ruby,index,directory_items_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def original_filename filename = filename_from_header || filename_from_uri mime_type = MiniMime.lookup_by_content_type(content_type) unless File.extname(filename).present? || mime_type.blank? filename = ""#{filename}.#{mime_type.extension}"" end filename end"
2808,"def index params.permit(:offset) params.permit(:limit) stream = Draft.stream(user: current_user, offset: params[:offset], limit: params[:limit]) render json: { drafts: stream ? serialize_data(stream, DraftSerializer) : [] } end",True,Ruby,index,drafts_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def initialize(file) case file when String @file = StringIO.new(file) when Net::HTTPResponse @file = StringIO.new(file.body) @content_type = file.content_type @headers = file @uri = file.uri else @file = file @content_type = file.content_type @headers = file.meta @uri = file.base_uri end
2811,"def members group = find_group(:group_id) guardian.ensure_can_see_group_members!(group) limit = (params[:limit] || 50).to_i offset = params[:offset].to_i raise Discourse::InvalidParameters.new(:limit) if limit < 0 || limit > 1000 raise Discourse::InvalidParameters.new(:offset) if offset < 0 dir = (params[:asc] && params[:asc].present?) ? ""ASC"" : ""DESC"" order = ""NOT group_users.owner"" if params[:requesters] guardian.ensure_can_edit!(group) users = group.requesters total = users.count if (filter = params[:filter]).present? filter = filter.split("","") if filter.include?("","") if current_user&.admin users = users.filter_by_username_or_email(filter) else users = users.filter_by_username(filter) end end users = users .select(""users.*, group_requests.reason, group_requests.created_at requested_at"") .order(params[:order] == ""requested_at"" ? ""group_requests.created_at #{dir}"" : """") .order(username_lower: dir) .limit(limit) .offset(offset) return( render json: { members: serialize_data(users, GroupRequesterSerializer), meta: { total: total, limit: limit, offset: offset, }, } ) end if params[:order] && %w[last_posted_at last_seen_at].include?(params[:order]) order = ""#{params[:order]} #{dir} NULLS LAST"" elsif params[:order] == ""added_at"" order = ""group_users.created_at #{dir}"" end users = group.users.human_users total = users.count if (filter = params[:filter]).present? filter = filter.split("","") if filter.include?("","") if current_user&.admin users = users.filter_by_username_or_email(filter) else users = users.filter_by_username(filter) end end users = users .includes(:primary_group) .includes(:user_option) .select(""users.*, group_users.created_at as added_at"") .order(order) .order(username_lower: dir) members = users.limit(limit).offset(offset) owners = users.where(""group_users.owner"") render json: { members: serialize_data(members, GroupUserSerializer), owners: serialize_data(owners, GroupUserSerializer), meta: { total: total, limit: limit, offset: offset, }, } end",True,Ruby,members,groups_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it 'sets file extension based on content-type if missing' do expect(subject.original_filename).to eq ""test.jpeg"" end"
2812,"def index user = if params[:username] && !params[:recent] user_record = User.find_by(username: params[:username].to_s) raise Discourse::NotFound if !user_record user_record else current_user end guardian.ensure_can_see_notifications!(user) if notification_types = params[:filter_by_types]&.split("","").presence notification_types.map! do |type| Notification.types[type.to_sym] || (raise Discourse::InvalidParameters.new(""invalid notification type: #{type}"")) end end if params[:recent].present? limit = (params[:limit] || 15).to_i limit = 50 if limit > 50 include_reviewables = false notifications = Notification.prioritized_list(current_user, count: limit, types: notification_types) # notification_types is blank for the ""all notifications"" user menu tab include_reviewables = notification_types.blank? && guardian.can_see_review_queue? if notifications.present? && !(params.has_key?(:silent) || @readonly_mode) if current_user.bump_last_seen_notification! current_user.reload current_user.publish_notifications_state end end if !params.has_key?(:silent) && params[:bump_last_seen_reviewable] && !@readonly_mode && include_reviewables current_user_id = current_user.id Scheduler::Defer.later ""bump last seen reviewable for user"" do # we lookup current_user again in the background thread to avoid # concurrency issues where the user object returned by the # current_user controller method is changed by the time the deferred # block is executed User.find_by(id: current_user_id)&.bump_last_seen_reviewable! end end notifications = filter_inaccessible_notifications(notifications) json = { notifications: serialize_data(notifications, NotificationSerializer), seen_notification_id: current_user.seen_notification_id, } if include_reviewables json[:pending_reviewables] = Reviewable.basic_serializers_for_list( Reviewable.user_menu_list_for(current_user), current_user, ).as_json end render_json_dump(json) else offset = params[:offset].to_i notifications = Notification.where(user_id: user.id).visible.includes(:topic).order(created_at: :desc) notifications = notifications.where(read: true) if params[:filter] == ""read"" notifications = notifications.where(read: false) if params[:filter] == ""unread"" total_rows = notifications.dup.count notifications = notifications.offset(offset).limit(60) notifications = filter_inaccessible_notifications(notifications) render_json_dump( notifications: serialize_data(notifications, NotificationSerializer), total_rows_notifications: total_rows, seen_notification_id: user.seen_notification_id, load_more_notifications: notifications_path(username: user.username, offset: offset + 60, filter: params[:filter]), ) end end",True,Ruby,index,notifications_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""should raise an error if the image fails an integrity check when downloaded"" do stub_request(:get, ""http://www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) expect(running { @instance.remote_image_url = ""http://www.example.com/test.jpg"" }).to raise_error(CarrierWave::IntegrityError) end"
2814,"def index params.require(:post_action_type_id) params.require(:id) post_action_type_id = params[:post_action_type_id].to_i page = params[:page].to_i page_size = (params[:limit] || 200).to_i # Find the post, and then determine if they can see the post (if deleted) post = Post.with_deleted.where(id: params[:id].to_i).first guardian.ensure_can_see!(post) unknown_user_ids = Set.new if current_user.present? result = DB.query_single(<<~SQL, user_id: current_user.id) SELECT mu.muted_user_id AS id FROM muted_users AS mu WHERE mu.user_id = :user_id UNION SELECT iu.ignored_user_id AS id FROM ignored_users AS iu WHERE iu.user_id = :user_id SQL unknown_user_ids.merge(result) end post_actions = post .post_actions .where(post_action_type_id: post_action_type_id) .includes(:user) .offset(page * page_size) .order(""post_actions.created_at ASC"") .limit(page_size) if !guardian.can_see_post_actors?(post.topic, post_action_type_id) raise Discourse::InvalidAccess unless current_user post_actions = post_actions.where(user_id: current_user.id) end action_type = PostActionType.types.key(post_action_type_id) total_count = post[""#{action_type}_count""].to_i data = { post_action_users: serialize_data( post_actions.to_a, PostActionUserSerializer, unknown_user_ids: unknown_user_ids, ), } data[:total_rows_post_action_users] = total_count if total_count > page_size render_json_dump(data) end",True,Ruby,index,post_action_users_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""should be an error instance if file was downloaded"" do stub_request(:get, ""http://www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) @instance.remote_image_url = ""http://www.example.com/test.jpg"" e = @instance.image_integrity_error expect(e).to be_an_instance_of(CarrierWave::IntegrityError) expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy end"
2817,"def deleted_posts params.permit(:offset, :limit) guardian.ensure_can_see_deleted_posts! user = fetch_user_from_params offset = [params[:offset].to_i, 0].max limit = [(params[:limit] || 60).to_i, 100].min posts = user_posts(guardian, user.id, offset: offset, limit: limit).where.not(deleted_at: nil) render_serialized(posts, AdminUserActionSerializer) end",True,Ruby,deleted_posts,posts_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""should raise an error if the image fails to be processed when downloaded"" do stub_request(:get, ""http://www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) expect(running { @instance.remote_image_url = ""http://www.example.com/test.jpg"" }).to raise_error(CarrierWave::ProcessingError) end"
2818,"def search matches = TagGroup.includes(:tags).visible(guardian).all matches = matches.where(""lower(name) ILIKE ?"", ""%#{params[:q].strip}%"") if params[:q].present? if params[:names].present? matches = matches.where(""lower(NAME) in (?)"", params[:names].map(&:downcase)) end matches = matches.order(""name"").limit(params[:limit] || 5) render json: { results: matches.map { |x| { name: x.name, tag_names: x.tags.base_tags.pluck(:name).sort } }, } end",True,Ruby,search,tag_groups_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""should do nothing when a validation fails"" do Event.validate { |r| r.errors.add :textfile, ""FAIL!"" } @event.image = stub_file('test.jpeg') expect(@event.save).to be_falsey expect(@event.image).to be_an_instance_of(@uploader) expect(@event.image.current_path).to match(/^#{public_path('uploads/tmp')}/) end it ""should assign the filename to the database"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy @event.reload expect(@event[:image]).to eq('test.jpeg') expect(@event.image_identifier).to eq('test.jpeg') end it ""should preserve the image when nothing is assigned"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy @event = Event.find(@event.id) @event.foo = ""bar"" expect(@event.save).to be_truthy expect(@event[:image]).to eq('test.jpeg') expect(@event.image_identifier).to eq('test.jpeg') end it ""should remove the image if remove_image? returns true"" do @event.image = stub_file('test.jpeg') @event.save! @event.remove_image = true @event.save! @event.reload expect(@event.image).to be_blank expect(@event[:image]).to eq(nil) expect(@event.image_identifier).to eq(nil) end it ""should mark image as changed when saving a new image"" do expect(@event.image_changed?).to be_falsey @event.image = stub_file(""test.jpeg"") expect(@event.image_changed?).to be_truthy @event.save @event.reload expect(@event.image_changed?).to be_falsey @event.image = stub_file(""test.jpg"") expect(@event.image_changed?).to be_truthy expect(@event.changed_for_autosave?).to be_truthy end end describe ""image?"" do it ""returns true when the file is cached"" do @event.image = stub_file('test.jpg') expect(@event.image?).to be_truthy end it ""returns false when the file is removed"" do @event.remove_image! @event.save! expect(@event.image?).to be_falsey end it ""returns true when the file is stored"" do @event.image = stub_file('test.jpg') @event.save! expect(@event.image?).to be_truthy end it ""returns true when a file is removed and stored again"" do @event.image = stub_file('test.jpeg') @event.save! @event.remove_image! @event.save! @event.image = stub_file('test.jpeg') @event.save! expect(@event.image?).to be_truthy end end describe ""remove_image!"" do before do @event.image = stub_file('test.jpeg') @event.save! end it ""should clear the serialization column"" do @event.remove_image! expect(@event.attributes['image']).to be_blank end it ""resets remove_image? to false"" do @event.remove_image = true expect { @event.remove_image! }.to change { @event.remove_image? }.from(true).to(false) end end describe ""remove_image="" do it ""should mark the image as changed if changed"" do expect(@event.image_changed?).to be_falsey expect(@event.remove_image).to be_nil @event.remove_image = ""1"" expect(@event.image_changed?).to be_truthy end end describe ""#remote_image_url="" do before do stub_request(:get, ""http://www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) end # FIXME ideally image_changed? and remote_image_url_changed? would return true it ""should mark image as changed when setting remote_image_url"" do expect(@event.image_changed?).to be_falsey @event.remote_image_url = 'http://www.example.com/test.jpg' expect(@event.image_changed?).to be_truthy @event.save! @event.reload expect(@event.image_changed?).to be_falsey end context 'when validating download' do before do @uploader.class_eval do def download! file, headers = {} raise CarrierWave::DownloadError end end @event.remote_image_url = 'http://www.example.com/missing.jpg' end it ""should make the record invalid when a download error occurs"" do expect(@event).to_not be_valid end it ""should use I18n for download errors without messages"" do @event.valid? expect(@event.errors[:image]).to eq(['could not be downloaded']) change_locale_and_store_translations(:pt, :activerecord => { :errors => { :messages => { :carrierwave_download_error => 'não pode ser descarregado' } } }) do expect(@event).to_not be_valid expect(@event.errors[:image]).to eq(['não pode ser descarregado']) end end end end describe '#destroy' do it ""should not raise an error with a custom filename"" do @uploader.class_eval do def filename ""page.jpeg"" end end @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy expect { @event.destroy }.to_not raise_error end it ""should do nothing when no file has been assigned"" do expect(@event.save).to be_truthy @event.destroy end it ""should remove the file from the filesystem"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy expect(@event.image).to be_an_instance_of(@uploader) expect(@event.image.current_path).to eq public_path('uploads/test.jpeg') @event.destroy expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey end end"
2820,"def search filter_params = { for_input: params[:filterForInput], selected_tags: params[:selected_tags], exclude_synonyms: params[:excludeSynonyms], exclude_has_synonyms: params[:excludeHasSynonyms], } if params[:limit] begin filter_params[:limit] = Integer(params[:limit]) raise Discourse::InvalidParameters.new(:limit) if !filter_params[:limit].positive? rescue ArgumentError raise Discourse::InvalidParameters.new(:limit) end end filter_params[:category] = Category.find_by_id(params[:categoryId]) if params[:categoryId] if !params[:q].blank? clean_name = DiscourseTagging.clean_tag(params[:q]) filter_params[:term] = clean_name filter_params[:order_search_results] = true else filter_params[:order_popularity] = true end tags_with_counts, filter_result_context = DiscourseTagging.filter_allowed_tags(guardian, **filter_params, with_context: true) tags = self.class.tag_counts_json(tags_with_counts, guardian) json_response = { results: tags } if clean_name && !tags.find { |h| h[:id].downcase == clean_name.downcase } && tag = Tag.where_name(clean_name).first # filter_allowed_tags determined that the tag entered is not allowed json_response[:forbidden] = params[:q] if filter_params[:exclude_synonyms] && tag.synonym? json_response[:forbidden_message] = I18n.t( ""tags.forbidden.synonym"", tag_name: tag.target_tag.name, ) elsif filter_params[:exclude_has_synonyms] && tag.synonyms.exists? json_response[:forbidden_message] = I18n.t( ""tags.forbidden.has_synonyms"", tag_name: tag.name, ) else category_names = tag.categories.where(id: guardian.allowed_category_ids).pluck(:name) category_names += Category .joins(tag_groups: :tags) .where(id: guardian.allowed_category_ids, ""tags.id"": tag.id) .pluck(:name) if category_names.present? category_names.uniq! json_response[:forbidden_message] = I18n.t( ""tags.forbidden.restricted_to"", count: category_names.count, tag_name: tag.name, category_names: category_names.join("", ""), ) else json_response[:forbidden_message] = I18n.t( ""tags.forbidden.in_this_category"", tag_name: tag.name, ) end end end if required_tag_group = filter_result_context[:required_tag_group] json_response[:required_tag_group] = required_tag_group end render json: json_response end",True,Ruby,search,tags_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def create_info_block(options) return nil unless options proc do |img| options.each do |k, v| if v.is_a?(String) && (matches = v.match(/^[""'](.+)[""']/)) ActiveSupport::Deprecation.warn ""Passing quoted strings like #{v} to #manipulate! is deprecated, pass them without quoting."" v = matches[1] end img.public_send(:""#{k}="", v) end end end"
2823,"def user_menu_bookmarks if !current_user.username_equals_to?(params[:username]) raise Discourse::InvalidAccess.new(""username doesn't match current_user's username"") end reminder_notifications = Notification .for_user_menu(current_user.id, limit: USER_MENU_LIST_LIMIT) .unread .where(notification_type: Notification.types[:bookmark_reminder]) if reminder_notifications.size < USER_MENU_LIST_LIMIT exclude_bookmark_ids = reminder_notifications.filter_map { |notification| notification.data_hash[:bookmark_id] } bookmark_list = UserBookmarkList.new( user: current_user, guardian: guardian, params: { per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size, }, ) bookmark_list.load do |query| if exclude_bookmark_ids.present? query.where(""bookmarks.id NOT IN (?)"", exclude_bookmark_ids) end end end if reminder_notifications.present? serialized_notifications = ActiveModel::ArraySerializer.new( reminder_notifications, each_serializer: NotificationSerializer, scope: guardian, ) end if bookmark_list bookmark_list.bookmark_serializer_opts = { link_to_first_unread_post: true } serialized_bookmarks = serialize_data(bookmark_list, UserBookmarkListSerializer, scope: guardian, root: false)[ :bookmarks ] end render json: { notifications: serialized_notifications || [], bookmarks: serialized_bookmarks || [], } end",True,Ruby,user_menu_bookmarks,users_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it 'supports passing read options to RMagick' do expect_any_instance_of(::Magick::Image::Info).to receive(:density=).with(10) expect_any_instance_of(::Magick::Image::Info).to receive(:size=).with(""200x200"") instance.manipulate! :read => { :density => 10, :size => ""200x200"" } end"
2825,"def bookmarks user = fetch_user_from_params guardian.ensure_can_edit!(user) user_guardian = Guardian.new(user) respond_to do |format| format.json do bookmark_list = UserBookmarkList.new(user: user, guardian: guardian, params: params) bookmark_list.load if bookmark_list.bookmarks.empty? render json: { bookmarks: [] } else page = params[:page].to_i + 1 bookmark_list.more_bookmarks_url = ""#{Discourse.base_path}/u/#{params[:username]}/bookmarks.json?page=#{page}"" render_serialized(bookmark_list, UserBookmarkListSerializer) end end format.ics do @bookmark_reminders = Bookmark .with_reminders .where(user_id: user.id) .order(:reminder_at) .map do |bookmark| bookmark.registered_bookmarkable.serializer.new( bookmark, scope: user_guardian, root: false, ) end end end end",True,Ruby,bookmarks,users_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def updated_ajax @user = current_site.users.find(params[:user_id]) update_session = current_user_is?(@user) @user.update(params.require(:password).permit!) render inline: @user.errors.full_messages.join(', ') # keep user logged in when changing their own password update_auth_token_in_cookie @user.auth_token if update_session && @user.saved_change_to_password_digest? end"
2827,"def search_users term = params[:term].to_s.strip topic_id = params[:topic_id].to_i if params[:topic_id].present? category_id = params[:category_id].to_i if params[:category_id].present? topic_allowed_users = params[:topic_allowed_users] || false group_names = params[:groups] || [] group_names << params[:group] if params[:group] @groups = Group.where(name: group_names) if group_names.present? options = { topic_allowed_users: topic_allowed_users, searching_user: current_user, groups: @groups, } options[:include_staged_users] = !!ActiveModel::Type::Boolean.new.cast( params[:include_staged_users], ) options[:last_seen_users] = !!ActiveModel::Type::Boolean.new.cast(params[:last_seen_users]) if params[:limit].present? options[:limit] = params[:limit].to_i raise Discourse::InvalidParameters.new(:limit) if options[:limit] <= 0 end options[:topic_id] = topic_id if topic_id options[:category_id] = category_id if category_id results = UserSearch.new(term, options).search to_render = serialize_found_users(results) # blank term is only handy for in-topic search of users after @ # we do not want group results ever if term is blank groups = if term.present? && current_user if params[:include_groups] == ""true"" Group.visible_groups(current_user) elsif params[:include_mentionable_groups] == ""true"" Group.mentionable(current_user) elsif params[:include_messageable_groups] == ""true"" Group.messageable(current_user) end end if groups DiscoursePluginRegistry .groups_callback_for_users_search_controller_action .each do |param_name, block| groups = block.call(groups, current_user) if params[param_name.to_s] end # the plugin registry callbacks above are only evaluated when a param # is present matching the name of the callback. Any modifier registered using # register_modifier(:groups_for_users_search) will be evaluated without needing the # param. groups = DiscoursePluginRegistry.apply_modifier(:groups_for_users_search, groups) groups = Group.search_groups(term, groups: groups, sort: :auto) to_render[:groups] = groups.map { |m| { name: m.name, full_name: m.full_name } } end render json: to_render end",True,Ruby,search_users,users_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def cama_current_user return @cama_current_user if defined?(@cama_current_user) # api current user... @cama_current_user = cama_calc_api_current_user return @cama_current_user if @cama_current_user return nil unless cookie_auth_token_complete? @cama_current_user = current_site.users_include_admins.find_by_auth_token(user_auth_token_from_cookie).try(:decorate) end
2829,"def initialize(user:, guardian:, params:) @user = user @guardian = guardian @params = params @params.merge!(per_page: PER_PAGE) if params[:per_page].blank? @params[:per_page] = PER_PAGE if @params[:per_page] > PER_PAGE @bookmarks = [] @bookmark_serializer_opts = {} end",True,Ruby,initialize,user_bookmark_list.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def file_parse(key) file_path = File.join(@root_folder, key) url_path, is_dir = file_path.sub(Rails.root.join('public').to_s, ''), File.directory?(file_path) res = { ""name"" => File.basename(key), ""folder_path"" => File.dirname(key), ""url"" => is_dir ? '' : (is_private_uploader? ? url_path.sub(""#{@root_folder}/"", '') : File.join(@current_site.decorate.the_url(as_path: true, locale: false, skip_relative_url_root: true), url_path)), ""is_folder"" => is_dir, ""file_size"" => is_dir ? 0 : File.size(file_path).round(2), ""thumb"" => '', 'file_type' => self.class.get_file_format(file_path), 'dimension' => '' }.with_indifferent_access res['key'] = File.join(res['folder_path'], res['name']) res[""thumb""] = (is_private_uploader? ? '/admin/media/download_private_file?file=' + version_path(key).slice(1..-1) : version_path(res['url'])) if res['file_type'] == 'image' && File.extname(file_path).downcase != '.gif' if res['file_type'] == 'image' res[""thumb""].sub! '.svg', '.jpg' im = MiniMagick::Image.open(file_path) res['dimension'] = ""#{im[:width]}x#{im[:height]}"" rescue ""0x0"" # Malformed SVGs raise an exception here. end res end"
2830,def per_page @per_page ||= @params[:per_page] end,True,Ruby,per_page,user_bookmark_list.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def actions if params[:media_action] != 'crop_url' authorize! :manage, :media end params[:folder] = params[:folder].gsub(""//"", ""/"") if params[:folder].present? case params[:media_action] when ""new_folder"" params[:folder] = slugify_folder(params[:folder]) render partial: ""render_file_item"", locals: {files: [cama_uploader.add_folder(params[:folder])]} when ""del_folder"" cama_uploader.delete_folder(params[:folder]) render inline: """" when ""del_file"" cama_uploader.delete_file(params[:folder].gsub(""//"", ""/"")) render inline: """" when 'crop_url' unless params[:url].start_with?('data:') params[:url] = (params[:url].start_with?('http') ? '' : current_site.the_url(locale: nil)) + params[:url] end r = if local_url?(params[:url]) { error: t(""camaleon_cms.admin.media.local_upload_denied"") } else cama_tmp_upload( params[:url], formats: params[:formats], name: params[:name]) end"
2832,"def load(&blk) query = BookmarkQuery.new(user: @user, guardian: @guardian, params: @params) @bookmarks = query.list_all(&blk) @has_more = (@params[:page].to_i + 1) * @params[:per_page] < query.count @bookmarks end",True,Ruby,load,user_bookmark_list.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def nofollowify_links(string) raise ArgumentError, ""string"", ""must be html_safe"" unless string.html_safe? if this_blog.dofollowify string else followify_scrubber = Loofah::Scrubber.new do |node| node.set_attribute ""rel"", ""nofollow"" if node.name == ""a"" end sanitize h(string), scrubber: followify_scrubber end end"
2833,"def list_all(&blk) search_term = @params[:q] ts_query = search_term.present? ? Search.ts_query(term: search_term) : nil search_term_wildcard = search_term.present? ? ""%#{search_term}%"" : nil queries = Bookmark .registered_bookmarkables .map do |bookmarkable| interim_results = bookmarkable.perform_list_query(@user, @guardian) # this could occur if there is some security reason that the user cannot # access the bookmarkables that they have bookmarked, e.g. if they had 1 bookmark # on a topic and that topic was moved into a private category next if interim_results.blank? if search_term.present? interim_results = bookmarkable.perform_search_query(interim_results, search_term_wildcard, ts_query) end # this is purely to make the query easy to read and debug, otherwise it's # all mashed up into a massive ball in MiniProfiler :) ""---- #{bookmarkable.model.to_s} bookmarkable ---\n\n #{interim_results.to_sql}"" end .compact # same for interim results being blank, the user might have been locked out # from all their various bookmarks, in which case they will see nothing and # no further pagination/ordering/etc is required return [] if queries.empty? union_sql = queries.join(""\n\nUNION\n\n"") results = Bookmark.select(""bookmarks.*"").from(""(\n\n#{union_sql}\n\n) as bookmarks"") results = results.order( ""(CASE WHEN bookmarks.pinned THEN 0 ELSE 1 END), bookmarks.reminder_at ASC, bookmarks.updated_at DESC"", ) @count = results.count results = results.offset(@page * @params[:per_page]) if @page.positive? if updated_results = blk&.call(results) results = updated_results end results = results.limit(@limit).to_a BookmarkQuery.preload(results, self) results end",True,Ruby,list_all,bookmark_query.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def html_postprocess(_field, html) helper = ContentTextHelpers.new helper.sanitize html end"
2834,"def initialize(user:, guardian: nil, params: {}) @user = user @params = params @guardian = guardian || Guardian.new(@user) @page = @params[:page].to_i @limit = @params[:limit].present? ? @params[:limit].to_i : @params[:per_page] @count = 0 end",True,Ruby,initialize,bookmark_query.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""with dofollowify disabled, links should be nofollowed"" do @blog.dofollowify = false @blog.save result = nofollowify_links(original_html) aggregate_failures do expect(result).to eq('<a href=""http://myblog.net"" rel=""nofollow"">my blog</a>') expect(result).to be_html_safe end end"
2838,"def index params.permit(:username, :offset, :limit) offset = params[:offset].to_i limit = (params[:limit] || 50).to_i.clamp(1, 50) memberships = Chat::ChannelMembershipsQuery.call( channel: channel_from_params, offset: offset, limit: limit, username: params[:username], ) render_serialized( memberships, Chat::UserChannelMembershipSerializer, root: ""memberships"", meta: { total_rows: channel_from_params.user_count, load_more_url: ""/chat/api/channels/#{channel_from_params.id}/memberships?offset=#{offset + limit}&limit=#{limit}&username=#{params[:username]}"", }, ) end",True,Ruby,index,channels_memberships_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""renders email addresses in the body"" do comment = build_stubbed(:comment, body: ""foo@example.com"") expect(comment.html).to match(/mailto:/) end"
2840,"it ""is respected"" do expect(bookmark_query.list_all.count).to eq(1) end",True,Ruby,"""is respected""",bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def self.publication_months result = select(""published_at"").where(""published_at is not NULL"").where(type: ""Article"") result.map { |it| [it.publication_month] }.uniq end # Finds one article which was posted on a certain date and matches the # supplied dashed-title params is a Hash def self.requested_article(params) date_range = PublifyTime.delta(params[:year], params[:month], params[:day]) req_params = {} req_params[:permalink] = params[:title] if params[:title] req_params[:published_at] = date_range if date_range return if req_params.empty? # no search if no params send article = published.find_by(req_params) return article if article if params[:title] req_params[:permalink] = CGI.escape(params[:title]) article = published.find_by(req_params) return article if article end end # Fulltext searches the body of published articles def self.search(query, args = {}) query_s = query.to_s.strip if !query_s.empty? && args.empty? Article.searchstring(query) elsif !query_s.empty? && !args.empty? Article.searchstring(query).page(args[:page]).per(args[:per]) else [] end end def keywords_to_tags Tag.create_from_article!(self) end def interested_users User.where(notify_on_new_articles: true) end def notify_user_via_email(user) EmailNotify.send_article(self, user) if user.notify_via_email? end def comments_closed? !(allow_comments? && published? && in_feedback_window?) end def html_urls urls = [] html.gsub(/<a\s+[^>]*>/) do |tag| urls.push(Regexp.last_match[2].strip) if tag =~ /\bhref=([""']?)([^ >""]+)\1/ end urls.uniq end def pings_closed? !(allow_pings? && in_feedback_window?) end # check if time to comment is open or not def in_feedback_window? blog.sp_article_auto_close.zero? || published_at.to_i > blog.sp_article_auto_close.days.ago.to_i end # The web interface no longer distinguishes between separate ""body"" and # ""extended"" fields, and instead edits everything in a single edit field, # separating the extended content using ""\<!--more-->"". def body_and_extended if extended.blank? body else ""#{body}\n<!--more-->\n#{extended}"" end end # Split apart value around a ""\<!--more-->"" comment and assign it to our # #body and #extended fields. def body_and_extended=(value) parts = value.split(/\n?<!--more-->\n?/, 2) self.body = parts[0] self.extended = parts[1] || """" end def password_protected? password.present? end def add_comment(params) comments.build(params) end def access_by?(user) user.admin? || user_id == user.id end def allow_comments? return allow_comments unless allow_comments.nil? blog.default_allow_comments end def allow_pings? return allow_pings unless allow_pings.nil? blog.default_allow_pings end def published_comments comments.published.oldest_first end def published_trackbacks trackbacks.published.oldest_first end def published_feedback feedback.published.oldest_first end private def permalink_url_options format_url = blog.permalink_format.dup format_url.gsub!(""%year%"", published_at.year.to_s) format_url.gsub!(""%month%"", sprintf(""%<month>.2d"", month: published_at.month)) format_url.gsub!(""%day%"", sprintf(""%<day>.2d"", day: published_at.day)) format_url.gsub!(""%title%"", URI::DEFAULT_PARSER.escape(permalink.to_s)) if format_url[0, 1] == ""/"" format_url[1..-1] else format_url end end def trigger_publication # TODO: Skip if already published, update when published_at changes Trigger.post_action(published_at, self, ""publish!"") end end"
2841,"it ""can search by post content"" do bookmarks = bookmark_query(params: { q: ""content"" }).list_all expect(bookmarks.map(&:id)).to eq([bookmark4.id]) end",True,Ruby,"""can search by post content""",bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def comments_closed? !(allow_comments? && published? && in_feedback_window?) end
2842,"it ""can search by topic title"" do bookmarks = bookmark_query(params: { q: ""bugfix"" }).list_all expect(bookmarks.map(&:id)).to eq([bookmark4.id]) end",True,Ruby,"""can search by topic title""",bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""returns only published articles"" do article = create(:article) create(:comment, article: article) unpublished_article = create(:article) create(:comment, article: unpublished_article) unpublished_article.update!(state: ""draft"") expect(described_class.published).to eq([article]) expect(described_class.bestof).to eq([article]) end"
2846,"it ""can search by bookmark name"" do bookmarks = bookmark_query(params: { q: ""check"" }).list_all expect(bookmarks.map(&:id)).to eq([bookmark3.id]) end",True,Ruby,"""can search by bookmark name""",bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def html_postprocess(_field, html) helper = ContentTextHelpers.new helper.sanitize(helper.auto_link(html), tags: self.class.allowed_tags) end"
2848,"it ""allows searching bookmarkables by fields in other tables"" do bookmarks = bookmark_query(params: { q: ""bookmarkk"" }).list_all expect(bookmarks.map(&:id)).to eq([bookmark5.id]) end",True,Ruby,"""allows searching bookmarkables by fields in other tables""",bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def show_article auto_discovery_feed respond_to do |format| format.html do @comment = Comment.new @page_title = this_blog.article_title_template.to_title(@article, this_blog, params) if @article.password.blank? @description = this_blog.article_desc_template. to_title(@article, this_blog, params) end @keywords = @article.tags.map(&:name).join("", "") render ""articles/#{@article.post_type}"" end format.atom { render_feedback_feed(""atom"") } format.rss { render_feedback_feed(""rss"") } format.xml { render_feedback_feed(""atom"") } end rescue ActiveRecord::RecordNotFound error! end"
2849,"def bookmark_query(user: nil, params: nil) BookmarkQuery.new(user: user || self.user, params: params || self.params) end",True,Ruby,bookmark_query,bookmark_query_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def update id = params[:id] return unless access_granted?(id) @article = Article.find(id) if params[:article][:draft] fetch_fresh_or_existing_draft_for_article else @article = Article.find(@article.parent_id) unless @article.parent_id.nil? end update_article_attributes if @article.draft @article.state = ""draft"" elsif @article.draft? @article.publish! end if @article.save Article.where(parent_id: @article.id).map(&:destroy) unless @article.draft flash[:success] = I18n.t(""admin.content.update.success"") redirect_to action: ""index"" else @article.keywords = Tag.collection_to_string @article.tags load_resources render ""edit"" end end"
2853,"it ""does not exceed PAGE_SIZE if limit parameter is more than PAGE_SIZE"" do large_limit = DirectoryItemsController::PAGE_SIZE + 10 get ""/directory_items.json"", params: { period: ""all"", limit: large_limit } expect(response.status).to eq(200) json = response.parsed_body expect(json[""directory_items""].length).to eq(DirectoryItemsController::PAGE_SIZE) end",True,Ruby,"""does not exceed PAGE_SIZE if limit parameter is more than PAGE_SIZE""",directory_items_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""requires name to be present"" do expect(tag).to validate_presence_of(:name) end"
2854,"it ""handles invalid limit parameters gracefully"" do get ""/directory_items.json"", params: { period: ""all"", limit: ""invalid_limit"" } expect(response.status).to eq(200) json = response.parsed_body expect(json[""directory_items""]).not_to be_empty end",True,Ruby,"""handles invalid limit parameters gracefully""",directory_items_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""redirects to index"" do post :update, params: { id: contributor.id, user: { login: ""errand"", email: ""corey@test.com"", password: strong_password, password_confirmation: strong_password } } expect(response).to redirect_to(action: ""index"") end"
2856,"it ""has a clean protocol for ownership handover"" do user = sign_in(Fabricate(:user)) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { a: ""test"" }.to_json, owner: ""abcdefg"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(0) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { b: ""test"" }.to_json, owner: ""hijklmnop"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(1) expect(DraftSequence.current(user, ""abc"")).to eq(1) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 1, data: { c: ""test"" }.to_json, owner: ""hijklmnop"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(2) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 2, data: { c: ""test"" }.to_json, owner: ""abc"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(3) end",True,Ruby,"""has a clean protocol for ownership handover""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""empty blog name should raise an error"" do post :create, params: { setting: { blog_name: """", email: ""foo@bar.net"", password: strong_password } } expect(response).to redirect_to(action: ""index"") end"
2857,"it ""destroys drafts when required"" do user = sign_in(Fabricate(:user)) Draft.set(user, ""xxx"", 0, ""hi"") delete ""/drafts/xxx.json"", params: { sequence: 0 } expect(response.status).to eq(200) expect(Draft.get(user, ""xxx"", 0)).to eq(nil) end",True,Ruby,"""destroys drafts when required""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it ""empty email should raise an error"" do post :create, params: { setting: { blog_name: ""Foo"", email: """", password: strong_password } } expect(response).to redirect_to(action: ""index"") end"
2858,"it ""returns a draft if requested"" do user = sign_in(Fabricate(:user)) Draft.set(user, ""hello"", 0, ""test"") get ""/drafts/hello.json"" expect(response.status).to eq(200) expect(response.parsed_body[""draft""]).to eq(""test"") end",True,Ruby,"""returns a draft if requested""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def meeting_link(uniqueid, data) notification = t( ""notifications.meeting.#{data[:type]}"", name: name_or_email(data), group_name: data[:group], meeting_name: data[:typename] ) link = specific_meeting_link(data[:type], data[:typeid], data[:group_id]) notification_link(uniqueid, link, notification) end"
2859,"it ""has empty stream after deleting last draft"" do user = sign_in(Fabricate(:user)) Draft.set(user, ""xxx"", 0, ""{}"") Draft.clear(user, ""xxx"", 0) get ""/drafts.json"" expect(response.status).to eq(200) expect(response.parsed_body[""drafts""].length).to eq(0) end",True,Ruby,"""has empty stream after deleting last draft""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def comment_link(uniqueid, data) comment = comment_for_type(data) i18n_key = data[:cutoff] ? 'truncated' : 'full' notification = t( ""notifications.comment.#{i18n_key}"", name: name_or_email(data), comment: strip_tags(data[:comment]), typename: data[:typename] ) notification_link(uniqueid, comment[:path], notification) end"
2860,"it ""raises an error for out-of-sequence draft setting"" do user = sign_in(Fabricate(:user)) seq = DraftSequence.next!(user, ""abc"") Draft.set(user, ""abc"", seq, { b: ""test"" }.to_json) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: seq - 1, data: { a: ""test"" }.to_json, } expect(response.status).to eq(409) post ""/drafts.json"", params: { draft_key: ""abc"", sequence: seq + 1, data: { a: ""test"" }.to_json, } expect(response.status).to eq(409) end",True,Ruby,"""raises an error for out-of-sequence draft setting""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def group_link(uniqueid, data) notification = t( ""notifications.group.#{data[:type]}"", name: name_or_email(data), group_name: data[:group] ) link = ""/groups/#{data[:group_id]}"" notification_link(uniqueid, link, notification) end"
2864,"it ""cant trivially resolve conflicts without interaction"" do user = sign_in(Fabricate(:user)) DraftSequence.next!(user, ""abc"") post ""/drafts.json"", params: { draft_key: ""abc"", sequence: 0, data: { a: ""test"" }.to_json, owner: ""abcdefg"", } expect(response.status).to eq(200) expect(response.parsed_body[""draft_sequence""]).to eq(1) end",True,Ruby,"""cant trivially resolve conflicts without interaction""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def accepted_ally_link(uniqueid, data) notification = t( 'notifications.ally.accepted', name: name_or_email(data) ) link = ""/profile?uid=#{data[:uid]}"" notification_link(uniqueid, link, notification) end"
2866,"it ""saves a draft"" do user = sign_in(Fabricate(:user)) post ""/drafts.json"", params: { draft_key: ""xyz"", data: { my: ""data"" }.to_json, sequence: 0 } expect(response.status).to eq(200) expect(Draft.get(user, ""xyz"", 0)).to eq(%q({""my"":""data""})) end",True,Ruby,"""saves a draft""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def new_ally_request_link(uniqueid, data) link = ""/profile?uid=#{data[:uid]}"" link_html = ""<a href=\""#{link}\"">#{name_or_email(data)}</a>"" # rubocop:disable Layout/LineLength ""<div id=\""#{uniqueid}\""><div>#{t('notifications.ally.sent_html', link_to_user: link_html)}</div>#{request_actions(data[:user_id])}</div>"" # rubocop:enable Layout/LineLength end"
2867,"it ""returns correct stream length after adding a draft"" do user = sign_in(Fabricate(:user)) Draft.set(user, ""xxx"", 0, ""{}"") get ""/drafts.json"" expect(response.status).to eq(200) parsed = response.parsed_body expect(response.parsed_body[""drafts""].length).to eq(1) end",True,Ruby,"""returns correct stream length after adding a draft""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"it 'is valid with valid attributes' do notification = build(:notification, user: user) expect(notification).to be_valid end"
2869,"it ""checks for an conflict on update"" do user = sign_in(Fabricate(:user)) post = Fabricate(:post, user: user) post ""/drafts.json"", params: { draft_key: ""topic"", sequence: 0, data: { postId: post.id, originalText: post.raw, action: ""edit"" }.to_json, } expect(response.status).to eq(200) expect(response.parsed_body[""conflict_user""]).to eq(nil) post ""/drafts.json"", params: { draft_key: ""topic"", sequence: 0, data: { postId: post.id, originalText: ""something else"", action: ""edit"" }.to_json, } expect(response.status).to eq(200) expect(response.parsed_body[""conflict_user""][""id""]).to eq(post.last_editor.id) expect(response.parsed_body[""conflict_user""]).to include(""avatar_template"") end",True,Ruby,"""checks for an conflict on update""",drafts_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def render_notification(notification) uniqueid = notification[:uniqueid] data = convert_to_hash(notification[:data]) # In case data[:name] is invalid if data[:user_id] data[:email] = User.find(data[:user_id]).email end case data[:type] when /comment/ then comment_link(uniqueid, data) when /accepted_ally_request/ then accepted_ally_link(uniqueid, data) when /new_ally_request/ then new_ally_request_link(uniqueid, data) when /group/ then group_link(uniqueid, data) when /meeting/ then meeting_link(uniqueid, data) end"
2876,"it ""returns error 400 for suspicious limit"" do get ""/tags/filter/search.json"", params: { q: """", limit: ""1; SELECT 1"" } expect(response.status).to eq(400) expect(response.parsed_body[""errors""].first).to eq( I18n.t(""invalid_params"", message: ""limit""), ) end",True,Ruby,"""returns error 400 for suspicious limit""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def create_fixed_clamp_code(nbits, signed) if nbits == 1 && signed == :signed raise ""signed bitfield must have more than one bit"" end if signed == :signed max = ""max = (1 << (#{nbits} - 1)) - 1"" min = ""min = -(max + 1)"" else min = ""min = 0"" max = ""max = (1 << #{nbits}) - 1"" end clamp = ""(#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val)"" if nbits == 1 # allow single bits to be used as booleans clamp = ""(val == true) ? 1 : (not val) ? 0 : #{clamp}"" end ""val = #{clamp}"" end"
2877,"it ""returns error 400 for negative limit"" do get ""/tags/filter/search.json"", params: { q: """", limit: -1 } expect(response.status).to eq(400) expect(response.parsed_body[""errors""].first).to eq( I18n.t(""invalid_params"", message: ""limit""), ) end",True,Ruby,"""returns error 400 for negative limit""",tags_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,"def create_clamp_code(nbits, signed) if signed == :signed max = ""max = (1 << (#{nbits} - 1)) - 1"" min = ""min = -(max + 1)"" else max = ""max = (1 << #{nbits}) - 1"" min = ""min = 0"" end clamp = ""(#{max}; #{min}; val = (val < min) ? min : (val > max) ? max : val)"" ""val = #{clamp}"" end"
2878,"it ""returns an error if value is invalid"" do get ""/u/search/users.json"", params: { limit: ""-1"" } expect(response.status).to eq(400) end",True,Ruby,"""returns an error if value is invalid""",users_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def set_inboxes @inbox_ids = if params[:inbox_id] @current_user.assigned_inboxes.where(id: params[:inbox_id]) else @current_user.assigned_inboxes.pluck(:id) end
2880,"def run_serializer bookmark_list = UserBookmarkList.new(user: user, guardian: Guardian.new(user), params: {}) bookmark_list.load UserBookmarkListSerializer.new(bookmark_list) end",True,Ruby,run_serializer,user_bookmark_list_serializer_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:46+01:00,"SECURITY: Impose a upper bound on limit params in various controllers

What is the problem here?

In multiple controllers, we are accepting a `limit` params but do not
impose any upper bound on the values being accepted. Without an upper
bound, we may be allowing arbituary users from generating DB queries
which may end up exhausing the resources on the server.

What is the fix here?

A new `fetch_limit_from_params` helper method is introduced in
`ApplicationController` that can be used by controller actions to safely
get the limit from the params as a default limit and maximum limit has
to be set. When an invalid limit params is encountered, the server will
respond with the 400 response code.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38684,def update @campaign.update!(campaign_params) end
2882,"def perform_accept_invitation params.require(:id) params.permit( :email, :username, :name, :password, :timezone, :email_token, user_custom_fields: { }, ) invite = Invite.find_by(invite_key: params[:id]) redeeming_user = current_user if invite.present? begin attrs = { ip_address: request.remote_ip, session: session } if redeeming_user attrs[:redeeming_user] = redeeming_user else attrs[:username] = params[:username] attrs[:name] = params[:name] attrs[:password] = params[:password] attrs[:user_custom_fields] = params[:user_custom_fields] # If the invite is not scoped to an email then we allow the # user to provide it themselves if invite.is_invite_link? params.require(:email) attrs[:email] = params[:email] else # Otherwise we always use the email from the invitation. attrs[:email] = invite.email attrs[:email_token] = params[:email_token] if params[:email_token].present? end end user = invite.redeem(**attrs) rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e return render json: failed_json.merge(message: e.message), status: 412 end if user.blank? return render json: failed_json.merge(message: I18n.t(""invite.not_found_json"")), status: 404 end log_on_user(user) if !redeeming_user && user.active? && user.guardian.can_access_forum? user.update_timezone_if_missing(params[:timezone]) post_process_invite(user) create_topic_invite_notifications(invite, user) topic = invite.topics.first response = {} if user.present? if user.active? && user.guardian.can_access_forum? response[:message] = I18n.t(""invite.existing_user_success"") if redeeming_user if user.guardian.can_see?(topic) response[:redirect_to] = path(topic.relative_url) else response[:redirect_to] = path(""/"") end else response[:message] = if user.active? I18n.t(""activation.approval_required"") else I18n.t(""invite.confirm_email"") end cookies[:destination_url] = path(topic.relative_url) if user.guardian.can_see?(topic) end end render json: success_json.merge(response) else render json: failed_json.merge(message: I18n.t(""invite.not_found_json"")), status: 404 end",True,Ruby,perform_accept_invitation,invites_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:48+01:00,"SECURITY: Handle concurrent invite accepts

Raise an error on concurrent invite accept attempts.",CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),"The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",https://cwe.mitre.org/data/definitions/362.html,CVE-2023-37904,"it 'returns all campaigns belonging to the inbox to administrators' do # create a random campaign create(:campaign, account: account, trigger_rules: { url: 'https://test.com' }) get ""/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns"", headers: administrator.create_new_auth_token, as: :json expect(response).to have_http_status(:success) body = JSON.parse(response.body, symbolize_names: true) expect(body.first[:id]).to eq(campaign.display_id) expect(body.length).to eq(1) end"
2883,"def mark_invite_redeemed @invited_user_record = InvitedUser.create!(invite_id: invite.id, redeemed_at: Time.zone.now) if @invited_user_record.present? Invite.increment_counter(:redemption_count, invite.id) delete_duplicate_invites end @invited_user_record.present? end",True,Ruby,mark_invite_redeemed,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:48+01:00,"SECURITY: Handle concurrent invite accepts

Raise an error on concurrent invite accept attempts.",CWE-362,Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition'),"The product contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",https://cwe.mitre.org/data/definitions/362.html,CVE-2023-37904,"int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len, int not_first) { char *e, *n; unsigned long long cl; struct ist word; int check_prev = not_first; word.ptr = value->ptr; e = value->ptr + value->len; while (1) { if (word.ptr >= e) { /* empty header or empty value */ goto fail; } /* skip leading delimiter and blanks */ if (unlikely(HTTP_IS_LWS(*word.ptr))) { word.ptr++; continue; } /* digits only now */ for (cl = 0, n = word.ptr; n < e; n++) { unsigned int c = *n - '0'; if (unlikely(c > 9)) { /* non-digit */ if (unlikely(n == word.ptr)) // spaces only goto fail; break; } if (unlikely(cl > ULLONG_MAX / 10ULL)) goto fail; /* multiply overflow */ cl = cl * 10ULL; if (unlikely(cl + c < cl)) goto fail; /* addition overflow */ cl = cl + c; } /* keep a copy of the exact cleaned value */ word.len = n - word.ptr; /* skip trailing LWS till next comma or EOL */ for (; n < e; n++) { if (!HTTP_IS_LWS(*n)) { if (unlikely(*n != ',')) goto fail; break; } } /* if duplicate, must be equal */ if (check_prev && cl != *body_len) goto fail; /* OK, store this result as the one to be indexed */ *body_len = cl; *value = word; /* Now either n==e and we're done, or n points to the comma, * and we skip it and continue. */ if (n++ == e) break; word.ptr = n; check_prev = 1; } /* here we've reached the end with a single value or a series of * identical values, all matching previous series if any. The last * parsed value was sent back into <value>. We just have to decide * if this occurrence has to be indexed (it's the first one) or * silently skipped (it's not the first one) */ return !not_first; fail: return -1; }"
2888,def all_tags return @tags if defined?(@tags) # Calling method `pluck` or `order` along with `includes` causing N+1 queries tags = ( if SiteSetting.tags_sort_alphabetically topic.tags.sort_by(&:name) else topic_count_column = Tag.topic_count_column(scope) topic.tags.sort_by { |tag| tag.public_send(topic_count_column) }.reverse end ) tags = tags.reject { |tag| scope.hidden_tag_names.include?(tag[:name]) } if !scope.is_staff? @tags = tags end,True,Ruby,all_tags,topic_tags_mixin.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:50+01:00,"SECURITY: Hide restricted tags in noscript view

The hidden tags are usually filtered out by the serializer, but the
noscript view uses the topic objects instead of the serialized objects.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-38685,"def post_reactions_users id = params.require(:id).to_i reaction_value = params[:reaction_value] post = fetch_post_from_params raise Discourse::InvalidParameters if !post reaction_users = [] likes = post.post_actions.where( ""deleted_at IS NULL AND post_action_type_id = ?"", PostActionType.types[:like], ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id if likes.present? main_reaction = DiscourseReactions::Reaction.find_by( reaction_value: DiscourseReactions::Reaction.main_reaction_id, post_id: post.id, ) count = likes.length users = format_likes_users(likes) if main_reaction && main_reaction[:reaction_users_count] (users << get_users(main_reaction)).flatten! users.sort_by! { |user| user[:created_at] } count += main_reaction.reaction_users_count.to_i end reaction_users << { id: DiscourseReactions::Reaction.main_reaction_id, count: count, users: users.reverse.slice(0, MAX_USERS_COUNT + 1), } end if !reaction_value post .reactions .select do |reaction| reaction[:reaction_users_count] && reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id end .each { |reaction| reaction_users << format_reaction_user(reaction) } elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id post .reactions .where(reaction_value: reaction_value) .select { |reaction| reaction[:reaction_users_count] } .each { |reaction| reaction_users << format_reaction_user(reaction) } end render_json_dump(reaction_users: reaction_users) end"
2891,"def hijack(info: nil, &blk) controller_class = self.class if hijack = request.env[""rack.hijack""] request.env[""discourse.request_tracker.skip""] = true request_tracker = request.env[""discourse.request_tracker""] # in the past unicorn would recycle env, this is not longer the case env = request.env # rack may clean up tempfiles unless we trick it and take control tempfiles = env[Rack::RACK_TEMPFILES] env[Rack::RACK_TEMPFILES] = nil request_copy = ActionDispatch::Request.new(env) transfer_timings = MethodProfiler.transfer io = hijack.call # duplicate headers so other middleware does not mess with it # on the way down the stack original_headers = response.headers.dup Scheduler::Defer.later(""hijack #{params[""controller""]} #{params[""action""]} #{info}"") do MethodProfiler.start(transfer_timings) begin Thread.current[Logster::Logger::LOGSTER_ENV] = env # do this first to confirm we have a working connection # before doing any work io.write ""HTTP/1.1 "" # this trick avoids double render, also avoids any litter that the controller hooks # place on the response instance = controller_class.new response = ActionDispatch::Response.new instance.response = response instance.request = request_copy original_headers&.each { |k, v| instance.response.headers[k] = v } view_start = Process.clock_gettime(Process::CLOCK_MONOTONIC) begin instance.instance_eval(&blk) rescue => e # TODO we need to reuse our exception handling in ApplicationController Discourse.warn_exception( e, message: ""Failed to process hijacked response correctly"", env: env, ) end view_runtime = Process.clock_gettime(Process::CLOCK_MONOTONIC) - view_start instance.status = 500 unless instance.response_body || response.committed? response.commit! body = response.body headers = response.headers # add cors if needed if cors_origins = env[Discourse::Cors::ORIGINS_ENV] Discourse::Cors.apply_headers(cors_origins, env, headers) end headers[""Content-Type""] ||= response.content_type || ""text/plain"" headers[""Content-Length""] = body.bytesize headers[""Connection""] = ""close"" headers[""Discourse-Logged-Out""] = ""1"" if env[Auth::DefaultCurrentUserProvider::BAD_TOKEN] status_string = Rack::Utils::HTTP_STATUS_CODES[response.status.to_i] || ""Unknown"" io.write ""#{response.status} #{status_string}\r\n"" timings = MethodProfiler.stop if timings && duration = timings[:total_duration] headers[""X-Runtime""] = ""#{""%0.6f"" % duration}"" end headers.each { |name, val| io.write ""#{name}: #{val}\r\n"" } io.write ""\r\n"" io.write body rescue Errno::EPIPE, IOError # happens if client terminated before we responded, ignore io = nil ensure if Rails.configuration.try(:lograge).try(:enabled) if timings db_runtime = 0 db_runtime = timings[:sql][:duration] if timings[:sql] subscriber = Lograge::LogSubscribers::ActionController.new payload = ActiveSupport::HashWithIndifferentAccess.new( controller: self.class.name, action: action_name, params: request.filtered_parameters, headers: request.headers, format: request.format.ref, method: request.request_method, path: request.fullpath, view_runtime: view_runtime * 1000.0, db_runtime: db_runtime * 1000.0, timings: timings, status: response.status, ) event = ActiveSupport::Notifications::Event.new( ""hijack"", Time.now, Time.now + timings[:total_duration], """", payload, ) subscriber.process_action(event) end end MethodProfiler.clear Thread.current[Logster::Logger::LOGSTER_ENV] = nil begin io.close if io rescue StandardError nil end if request_tracker status = begin response.status rescue StandardError 500 end request_tracker.log_request_info(env, [status, headers || {}, []], timings) end tempfiles&.each(&:close!) end end # not leaked out, we use 418 ... I am a teapot to denote that we are hijacked render plain: """", status: 418 else blk.call end end",True,Ruby,hijack,hijack.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,def fetch_post_from_params post_id = params[:post_id] || params[:id] post = Post.find(post_id) guardian.ensure_can_see!(post) post end
2895,def length @queue.length end,True,Ruby,length,defer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,"def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil) message = { post_id: post.id, reactions: [reaction, previous_reaction].compact.uniq } opts = {} secure_audience = post.topic.secure_audience_publish_messages opts = secure_audience if secure_audience[:user_ids] != [] && secure_audience[:group_ids] != [] MessageBus.publish(""/topic/#{post.topic.id}/reactions"", message, opts) end"
2898,def initialize @async = !Rails.env.test? @queue = Queue.new @mutex = Mutex.new @stats_mutex = Mutex.new @paused = false @thread = nil @reactor = nil @timeout = DEFAULT_TIMEOUT @stats = LruRedux::ThreadSafeCache.new(STATS_CACHE_SIZE) end,True,Ruby,initialize,defer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,"def reactions_given params.require(:username) user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts)) raise Discourse::NotFound unless guardian.can_see_profile?(user) reaction_users = DiscourseReactions::ReactionUser .joins(:reaction, post: :topic) .joins(""LEFT JOIN categories ON categories.id = topics.category_id"") .includes(:user, :post, :reaction) .where(user_id: user.id) .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL') reaction_users = secure_reaction_users!(reaction_users) if params[:before_reaction_user_id] reaction_users = reaction_users .where('discourse_reactions_reaction_users.id < ?', params[:before_reaction_user_id].to_i) end reaction_users = reaction_users .order(created_at: :desc) .limit(20) render_serialized(reaction_users.to_a, UserReactionSerializer) end"
2899,"def do_work(non_block = false) db, job, desc = @queue.deq(non_block) start = Process.clock_gettime(Process::CLOCK_MONOTONIC) db ||= RailsMultisite::ConnectionManagement::DEFAULT RailsMultisite::ConnectionManagement.with_connection(db) do begin warning_job = @reactor.queue(@timeout) do Rails.logger.error ""'#{desc}' is still running after #{@timeout} seconds on db #{db}, this process may need to be restarted!"" end if !non_block job.call rescue => ex @stats_mutex.synchronize do stats = @stats[desc] stats[:errors] += 1 if stats end Discourse.handle_job_exception(ex, message: ""Running deferred code '#{desc}'"") ensure warning_job&.cancel end end rescue => ex Discourse.handle_job_exception(ex, message: ""Processing deferred code queue"") ensure ActiveRecord::Base.connection_handler.clear_active_connections! if start @stats_mutex.synchronize do stats = @stats[desc] if stats stats[:finished] += 1 stats[:duration] += Process.clock_gettime(Process::CLOCK_MONOTONIC) - start end end end end",True,Ruby,do_work,defer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,"def call(value) case value when *FALSE_VALUES then false when *NIL_VALUES then nil when Numeric, /\A[-+]?(0++\.?0*|0*+\.?0+)\z/ then !value.to_f.zero? else value.present? end"
2900,def do_all_work do_work(_non_block = true) while !@queue.empty? end,True,Ruby,do_all_work,defer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,"def apply_and_return_additional_attributes_to(scope:) attr_table_name = Models::AdditionalAttribute.quoted_table_name work_table_name = scope.quoted_table_name select_fields = [""#{work_table_name}.*""] additional_attributes.each do |attribute| table_name = attribute.fetch(:join_as_table_name) key = attribute.fetch(:key) scope = scope.joins( %(LEFT OUTER JOIN #{attr_table_name} AS #{table_name} ON #{table_name}.work_id = #{work_table_name}.id AND #{table_name}.key = ""#{key}"") ) select_fields << ""#{table_name}.value AS #{key}"" end scope.select(select_fields.join("", "")) scope end"
2901,"def later(desc = nil, db = RailsMultisite::ConnectionManagement.current_db, &blk) @stats_mutex.synchronize do stats = (@stats[desc] ||= { queued: 0, finished: 0, duration: 0, errors: 0 }) stats[:queued] += 1 end if @async start_thread if !@thread&.alive? && !@paused @queue << [db, blk, desc] else blk.call end end",True,Ruby,later,defer.rb,https://github.com/discourse/discourse,discourse,David Taylor,2023-07-28 12:53:51+01:00,SECURITY: Don't allow a particular site to monopolize the defer queue,CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2023-38498,def additional_attributes=(input) @additional_attributes = Array(input).map do |attribute_name| ADDITIONAL_ATTRIBUTE_MAP.fetch(attribute_name) end end
2929,"def one_time_password otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end",True,Ruby,one_time_password,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def index html = <<~HTML <!DOCTYPE html> <html> <head> </head> <body> <div id=""app""></div> #{script_tags} </body> </html> HTML [200, { ""content-type"" => ""text/html;"" }, [html]] end"
2930,"def one_time_password otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end",True,Ruby,one_time_password,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def call(env) return @app.call(env) unless env['PATH_INFO'].start_with? ""#{@bus.base_route}message-bus/_diagnostics"" route = env['PATH_INFO'].split(""#{@bus.base_route}message-bus/_diagnostics"")[1] if @bus.is_admin_lookup.nil? || !@bus.is_admin_lookup.call(env) return [403, {}, ['not allowed']] end return index unless route if route == '/discover' user_id = @bus.user_id_lookup.call(env) @bus.publish('/_diagnostics/discover', user_id: user_id) return [200, {}, ['ok']] end if route =~ /^\/hup\// hostname, pid = route.split('/hup/')[1].split('/') @bus.publish('/_diagnostics/hup', hostname: hostname, pid: pid.to_i) return [200, {}, ['ok']] end asset = route.split('/assets/')[1] if asset && JS_ASSETS.include?(asset) content = asset_contents(asset) return [200, { 'Content-Type' => 'application/javascript;charset=UTF-8' }, [content]] end [404, {}, ['not found']] end"
2933,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] valid_token = !!EmailToken.valid_token_format?(token) user = EmailToken.confirmable(token)&.user if valid_token && user&.totp_enabled? if !second_factor_token.present? @second_factor_required = true @backup_codes_enabled = true if user&.backup_codes_enabled? return render layout: 'no_ember' elsif !user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! @error = I18n.t('login.invalid_second_factor_code') return render layout: 'no_ember' end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) @error = login_not_approved[:error] elsif payload = login_error_check(user) @error = payload[:error] else log_on_user(user) return redirect_to path(""/"") end else @error = I18n.t('email_login.invalid_token') end render layout: 'no_ember' end",True,Ruby,email_login,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def self.has_attached_file(name, options = {}) # rubocop:disable Naming/PredicateName super(name, options) send(:""before_#{name}_validate"") do attachment = send(name) check_image_dimension(attachment) set_file_content_type(attachment) obfuscate_file_name(attachment) set_file_extension(attachment) end end"
2934,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] valid_token = !!EmailToken.valid_token_format?(token) user = EmailToken.confirmable(token)&.user if valid_token && user&.totp_enabled? if !second_factor_token.present? @second_factor_required = true @backup_codes_enabled = true if user&.backup_codes_enabled? return render layout: 'no_ember' elsif !user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! @error = I18n.t('login.invalid_second_factor_code') return render layout: 'no_ember' end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) @error = login_not_approved[:error] elsif payload = login_error_check(user) @error = payload[:error] else log_on_user(user) return redirect_to path(""/"") end else @error = I18n.t('email_login.invalid_token') end render layout: 'no_ember' end",True,Ruby,email_login,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def make metadata = VideoMetadataExtractor.new(@file.path) raise Paperclip::Error, ""Error while transcoding #{@file.path}: unsupported file"" unless metadata.valid? update_attachment_type(metadata) update_options_from_metadata(metadata) destination = Tempfile.new([@basename, @format ? "".#{@format}"" : '']) destination.binmode @output_options = @convert_options[:output]&.dup || {} @input_options = @convert_options[:input]&.dup || {} case @format.to_s when /jpg$/, /jpeg$/, /png$/, /gif$/ @input_options['ss'] = @time @output_options['f'] = 'image2' @output_options['vframes'] = 1 when 'mp4' @output_options['acodec'] = 'aac' @output_options['strict'] = 'experimental' if high_vfr?(metadata) && !eligible_to_passthrough?(metadata) @output_options['vsync'] = 'vfr' @output_options['r'] = @vfr_threshold end end"
2937,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect two factor',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def account_field_value_format(field, with_rel_me: true) if field.verified? && !field.account.local? TextFormatter.shortened_link(field.value_for_verification) else html_aware_format(field.value, field.account.local?, with_rel_me: with_rel_me, with_domains: true, multiline: false) end end"
2938,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect two factor',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def show filename = Rails.root.join(""attachments"", @attachment.filename) unless File.exist?(filename) COURSE_LOGGER.log(""Cannot find the file '#{@attachment.filename}' for""\ "" attachment #{@attachment.name}"") flash[:error] = ""Error loading #{@attachment.name} from #{@attachment.filename}"" redirect_to([@course, :attachments]) && return end # Set to application/octet-stream to force download send_file(filename, disposition: ""inline"", type: ""application/octet-stream"", filename: @attachment.filename) && return end"
2939,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) end",True,Ruby,"""fails when user is suspended""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def reset_password @admin_user = Motor::AdminUser.find(params[:admin_user_id]) authorize!(:manage, @admin_user) Devise::Mailer.default_url_options = { host: ENV['HOST'], protocol: request.protocol, port: request.port } @admin_user.send_reset_password_instructions head :ok end"
2940,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) end",True,Ruby,"""fails when user is suspended""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'authenticates successfuly' do basic_authorize 'a', 'b' get '/' assert_equal 200, last_response.status get '/?days=1000000' assert_equal 401, last_response.status end"
2947,"it 'returns the right response' do get ""/session/email-login/adasdad"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'returns the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def apply(operations) operations.inject(self) do |builder, (name, argument)| if argument == true || argument == nil builder.public_send(name) elsif argument.is_a?(Array) builder.public_send(name, *argument) elsif argument.is_a?(Hash) builder.public_send(name, **argument) else builder.public_send(name, argument) end end end"
2948,"it 'returns the right response' do get ""/session/email-login/adasdad"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'returns the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def resolve_target_path(target, reader) return target if target_http? target # Include file is resolved relative to dir of the current include, # or base_dir if within original docfile. path = reader.document.normalize_system_path(target, reader.dir, nil, target_name: 'include file') path if ::File.file?(path) end"
2949,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(500) end",True,Ruby,'fails when local logins is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def read_lines(path, selector) if selector IO.foreach(path).select.with_index(1, &selector) else URI.open(path, &:read) end end"
2950,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(500) end",True,Ruby,'fails when local logins is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def include_allowed?(target, reader) doc = reader.document return false if doc.safe >= ::Asciidoctor::SafeMode::SECURE return false if doc.attributes.fetch('max-include-depth', 64).to_i < 1 return false if target_http?(target) && !doc.attributes.key?('allow-uri-read') true end"
2955,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect backup code',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def read_lines(path, selector) # IO.open is deliberately not used directly to avoid potential security risks. # TODO: Get rid of 'open-uri' (URI.open). io = target_http?(path) ? URI : File io.open(path) do |f| if selector f.each.select.with_index(1, &selector) else f.read end end end"
2956,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect backup code',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def get_data_center_from_api_key(api_key) # Return an empty string for invalid API keys so Gibbon hits the main endpoint data_center = """" if api_key && api_key[""-""] # Remove all non-alphanumberic characters in case someone attempts to inject # a different domain into the API key (e.g. when consuming user form-provided keys) # This approach avoids assuming a 3 letter prefix (e.g. is MC were to create # a us10 DC, this would continue to work), and will continue to hit MC's server # rather than a would-be attacker's servers. data_center = ""#{api_key.split('-').last.gsub(/[^0-9a-z ]/i, '')}."" end data_center end"
2957,"it 'should return a second factor prompt' do get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) response_body = CGI.unescapeHTML(response.body) expect(response_body).to include(I18n.t( ""login.second_factor_title"" )) expect(response_body).to_not include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'should return a second factor prompt',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def self.extract_events(post) cooked = PrettyText.cook(post.raw, topic_id: post.topic_id, user_id: post.user_id) valid_options = VALID_OPTIONS.map { |o| ""data-#{o}"" } valid_custom_fields = [] SiteSetting.discourse_post_event_allowed_custom_fields.split('|').each do |setting| valid_custom_fields << { original: ""data-#{setting}"", normalized: ""data-#{setting.gsub(/_/, '-')}"" } end Nokogiri::HTML(cooked).css('div.discourse-post-event').map do |doc| event = nil doc.attributes.values.each do |attribute| name = attribute.name value = attribute.value if value && valid_options.include?(name) event ||= {} event[name.sub('data-', '').to_sym] = if name == ""data-name"" value else CGI.escapeHTML(value) end end valid_custom_fields.each do |valid_custom_field| if value && valid_custom_field[:normalized] == name event ||= {} event[valid_custom_field[:original].sub('data-', '').to_sym] = CGI.escapeHTML(value) end end end event end.compact"
2958,"it 'should return a second factor prompt' do get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) response_body = CGI.unescapeHTML(response.body) expect(response_body).to include(I18n.t( ""login.second_factor_title"" )) expect(response_body).to_not include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'should return a second factor prompt',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def diff @diff ||= begin @paths = case options[:source] when 'strings' [tempfile(string1), tempfile(string2)] when 'files' [string1, string2] end diff, stderr, process_status = Open3.capture3(diff_bin, *(diff_options + @paths)) diff.force_encoding('ASCII-8BIT') if diff.respond_to?(:valid_encoding?) && !diff.valid_encoding? if diff =~ /\A\s*\Z/ && !options[:allow_empty_diff] diff = case options[:source] when 'strings' then string1 when 'files' then File.read(string1) end.gsub(/^/, "" "") end"
2959,"it 'logs in correctly' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ROTP::TOTP.new(user_second_factor.data).now, second_factor_method: UserSecondFactor.methods[:totp] } expect(response).to redirect_to(""/"") end",True,Ruby,'logs in correctly',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def sanitize_data(project, data) return data if project&.assignment_id.blank? || data.blank? data = Oj.safe_load(data) saved_restricted_elements = Oj.safe_load(project.assignment.restrictions) scopes = data[""scopes""] || [] parsed_scopes = scopes.each_with_object([]) do |scope, new_scopes| restricted_elements_used = [] saved_restricted_elements.each do |element| restricted_elements_used.push(element) if scope[element].present? end scope[""restrictedCircuitElementsUsed""] = restricted_elements_used new_scopes.push(scope) end data[""scopes""] = parsed_scopes data.to_json end"
2960,"it 'logs in correctly' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ROTP::TOTP.new(user_second_factor.data).now, second_factor_method: UserSecondFactor.methods[:totp] } expect(response).to redirect_to(""/"") end",True,Ruby,'logs in correctly',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def validate unless validate_signature_exists? return notify(""There was a problem saving your gem: \nYou have added cert_chain in gemspec but signature was empty"", 403) end return notify(""There was a problem saving your gem: #{rubygem.all_errors(version)}"", 403) unless rubygem.valid? && version.valid? unless version.full_name == spec.original_name && Patterns::NAME_PATTERN.match?(spec.platform.to_s) return notify(""There was a problem saving your gem: the uploaded spec has malformed platform attributes"", 409) end true end"
2963,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include( I18n.t(""login.not_approved"") ) end",True,Ruby,"""doesn't log in the user when not approved""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def write_gem(body, spec) # we validate that the version full_name == spec.original_name original_name = @version.full_name gem_path = ""gems/#{original_name}.gem"" gem_contents = body.string spec.abbreviate spec.sanitize spec_path = ""quick/Marshal.4.8/#{original_name}.gemspec.rz"" spec_contents = Gem.deflate(Marshal.dump(spec)) spec_contents_checksum = Digest::SHA2.base64digest(spec_contents) # do all processing _before_ we upload anything to S3, so we lower the chances of orphaned files RubygemFs.instance.store(gem_path, gem_contents, checksum_sha256: version.sha256) RubygemFs.instance.store(spec_path, spec_contents, checksum_sha256: spec_contents_checksum) Fastly.purge(path: gem_path) Fastly.purge(path: spec_path) end"
2964,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include( I18n.t(""login.not_approved"") ) end",True,Ruby,"""doesn't log in the user when not approved""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def self.meta_delete(key:, cas: nil, ttl: nil, base64: false, quiet: false) cmd = ""md #{key}"" cmd << ' b' if base64 cmd << cas_string(cas) cmd << "" T#{ttl}"" if ttl cmd << ' q' if quiet cmd + TERMINATOR end"
2969,"it 'returns success' do get ""/session/email-login/#{email_token.token}"" expect(response).to redirect_to(""/"") end",True,Ruby,'returns success',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def self.flush(delay: nil, quiet: false) cmd = +'flush_all' cmd << "" #{parse_to_64_bit_int(delay, 0)}"" if delay cmd << ' noreply' if quiet cmd + TERMINATOR end"
2970,"it 'returns success' do get ""/session/email-login/#{email_token.token}"" expect(response).to redirect_to(""/"") end",True,Ruby,'returns success',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def self.meta_arithmetic(key:, delta:, initial:, incr: true, cas: nil, ttl: nil, base64: false, quiet: false) cmd = ""ma #{key} v"" cmd << ' b' if base64 cmd << "" D#{delta}"" if delta cmd << "" J#{initial}"" if initial # Always set a TTL if an initial value is specified cmd << "" N#{ttl || 0}"" if ttl || initial cmd << cas_string(cas) cmd << ' q' if quiet cmd << "" M#{incr ? 'I' : 'D'}"" cmd + TERMINATOR end"
2973,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'should return the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def self.meta_set(key:, value:, bitflags: nil, cas: nil, ttl: nil, mode: :set, base64: false, quiet: false) cmd = ""ms #{key} #{value.bytesize}"" cmd << ' c' unless %i[append prepend].include?(mode) cmd << ' b' if base64 cmd << "" F#{bitflags}"" if bitflags cmd << cas_string(cas) cmd << "" T#{ttl}"" if ttl cmd << "" M#{mode_to_token(mode)}"" cmd << ' q' if quiet cmd << TERMINATOR cmd << value cmd + TERMINATOR end"
2974,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'should return the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'handle read timeouts' do memcached_mock(lambda { |sock| sleep(0.6) sock.write('giraffe') }) do dc = Dalli::Client.new('localhost:19123') assert_raises Dalli::RingError, message: 'No server available' do dc.get('abc') end end end"
2979,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(404) end",True,Ruby,'fails when local logins via email is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"it 'handle no server available' do dc = Dalli::Client.new 'localhost:19333' assert_raises Dalli::RingError, message: 'No server available' do dc.get 'foo' end end"
2980,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(404) end",True,Ruby,'fails when local logins via email is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'handle connection reset' do memcached_mock(->(sock) { sock.close }) do dc = Dalli::Client.new('localhost:19123') assert_raises Dalli::RingError, message: 'No server available' do dc.get('abc') end end end"
2981,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username get ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end",True,Ruby,'should authenticate user and delete token',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"it 'handle connect timeouts' do memcached_mock(lambda { |sock| sleep(0.6) sock.close }, :delayed_start) do dc = Dalli::Client.new('localhost:19123') assert_raises Dalli::RingError, message: 'No server available' do dc.get('abc') end end end"
2982,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username get ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end",True,Ruby,'should authenticate user and delete token',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2019-06-17 15:59:41+01:00,"Merge pull request from GHSA-hv9p-jfm4-gpr9

* SECURITY: Add confirmation screen when logging in via email link

* SECURITY: Add confirmation screen when logging in via user-api OTP

* FIX: Correct translation key in session controller specs

* FIX: Use .email-login class for page",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'handle connection reset with unix socket' do socket_path = MemcachedMock::UNIX_SOCKET_PATH memcached_mock(->(sock) { sock.close }, :start_unix, socket_path) do dc = Dalli::Client.new(socket_path) assert_raises Dalli::RingError, message: 'No server available' do dc.get('abc') end end end"
2991,"def email_login raise Discourse::NotFound if !SiteSetting.enable_local_logins_via_email second_factor_token = params[:second_factor_token] second_factor_method = params[:second_factor_method].to_i token = params[:token] valid_token = !!EmailToken.valid_token_format?(token) user = EmailToken.confirmable(token)&.user if valid_token && user&.totp_enabled? if !second_factor_token.present? @second_factor_required = true @backup_codes_enabled = true if user&.backup_codes_enabled? return render layout: 'no_ember' elsif !user.authenticate_second_factor(second_factor_token, second_factor_method) RateLimiter.new(nil, ""second-factor-min-#{request.remote_ip}"", 3, 1.minute).performed! @error = I18n.t('login.invalid_second_factor_code') return render layout: 'no_ember' end end if user = EmailToken.confirm(token) if login_not_approved_for?(user) @error = login_not_approved[:error] elsif payload = login_error_check(user) @error = payload[:error] else log_on_user(user) return redirect_to path(""/"") end else @error = I18n.t('email_login.invalid_token') end render layout: 'no_ember' end",True,Ruby,email_login,session_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'handle malformed response' do memcached_mock(->(sock) { sock.write('123') }) do dc = Dalli::Client.new('localhost:19123') assert_raises Dalli::RingError, message: 'No server available' do dc.get('abc') end end end"
2994,"it 'does not log in with incorrect two factor' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:totp] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect two factor',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'connects to existing server' do rsd = Rack::Session::Dalli.new(incrementor, namespace: 'test:rack:session') assert_silent do rsd.data.with { |c| c.set('ping', '') } end end"
2996,"it 'logs in correctly' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ROTP::TOTP.new(user_second_factor.data).now, second_factor_method: UserSecondFactor.methods[:totp] } expect(response).to redirect_to(""/"") end",True,Ruby,'logs in correctly',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it 'faults on no connection' do rsd = Rack::Session::Dalli.new(incrementor, memcache_server: 'nosuchserver') assert_raises Dalli::RingError do rsd.data.with { |c| c.set('ping', '') } end end"
2997,"it 'should return a second factor prompt' do get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) response_body = CGI.unescapeHTML(response.body) expect(response_body).to include(I18n.t( ""login.second_factor_title"" )) expect(response_body).to_not include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'should return a second factor prompt',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def incoming account = Account.find_by_id_or_name(params[:account_name]) channel = account.geopoll_channels.find_by_name(params[:channel_name]) auth_token = channel.configuration[:auth_token].to_s.split(' ')[1] identifier = params[:Identifier] signature = Digest::MD5.hexdigest(auth_token + identifier) if !(ActiveSupport::SecurityUtils.secure_compare params[:Signature], signature) return render text: ""Error"", status: :unauthorized end unknown_params = params.except( 'Identifier', 'Signature', 'SourceAddress', 'TargetAddress', 'MessageText', # GeoPoll API specification 'account_name', 'channel_name', 'controller', 'action' # Rails-generated parameters ) msg = AtMessage.new msg.from = ""sms://#{params[:SourceAddress]}"" msg.to = ""sms://#{params[:TargetAddress]}"" msg.body = params[:MessageText] msg.channel_relative_id = params[:Identifier] account.route_at msg, channel channel.logger.warning :channel_id => channel.id, :at_message_id => msg.id, :message => ""Received unknown parameters for AT #{msg.id}: #{unknown_params.to_json}"" unless unknown_params.empty? render text: ""Accepted"" end"
2999,"it 'fails when local logins via email is disabled' do SiteSetting.enable_local_logins_via_email = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(404) end",True,Ruby,'fails when local logins via email is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def to_plain(argv1 = '', loose = false) return nil if argv1.empty? plain = argv1 if loose || plain =~ Match[:html] || plain =~ Match[:body] # 1. Remove <head>...</head> # 2. Remove <style>...</style> # 3. <a href = 'http://...'>...</a> to "" http://... "" # 4. <a href = 'mailto:...'>...</a> to "" Value <mailto:...> "" plain.scrub!('?') plain.gsub!(%r|<head>.*?</head>|im, '') plain.gsub!(%r|<style.*?>.*?</style>|im, '') plain.gsub!(%r|<a\s+href\s*=\s*['""](https?://.+?)['""].*?>(.*?)</a>|i, '[\2](\1)') plain.gsub!(%r|<a\s+href\s*=\s*[""']mailto:([^\s]+?)[""']>(.*?)</a>|i, '[\2](mailto:\1)') plain = plain.gsub(/<[^<@>]+?>\s*/, ' ') # Delete HTML tags except <neko@example.jp> plain = plain.gsub(/&lt;/, '<').gsub(/&gt;/, '>') # Convert to angle brackets plain = plain.gsub(/&amp;/, '&').gsub(/&nbsp;/, ' ') # Convert to ""&"" plain = plain.gsub(/&quot;/, '""').gsub(/&apos;/, ""'"") # Convert to "" and ' if argv1.size > plain.size plain = plain.squeeze(' ') plain << ""\n"" end end return plain end"
3005,"it 'returns the right response' do get ""/session/email-login/adasdad"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'returns the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def avatar_image(username, uploaded_avatar_id) template = User.avatar_template(username, uploaded_avatar_id).gsub(/{size}/, AVATAR_SIZE) ""![avatar\\|25x25](#{template})"" end"
3007,"it ""doesn't log in the user when not approved"" do SiteSetting.must_approve_users = true get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include( I18n.t(""login.not_approved"") ) end",True,Ruby,"""doesn't log in the user when not approved""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def create_category_posts(view, review_start, review_end, topic_id) review_categories = review_categories_from_settings review_categories.each do |category_id| category_post_topics = category_post_topics category_id, review_start, review_end if category_post_topics[:topics] view.assign(category_topics: category_post_topics) raw = view.render partial: ""yearly_review_category"", layout: false unless raw.empty? post_opts = { topic_id: topic_id, raw: raw, skip_validations: true, custom_fields: { ::YearlyReview::POST_CUSTOM_FIELD => review_start.year, }, } PostCreator.create!(Discourse.system_user, post_opts) end end end end"
3008,"it 'does not log in with incorrect backup code' do post ""/session/email-login/#{email_token.token}"", params: { second_factor_token: ""0000"", second_factor_method: UserSecondFactor.methods[:backup_codes] } expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t( ""login.invalid_second_factor_code"" )) end",True,Ruby,'does not log in with incorrect backup code',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"it ""should rank likes given and received correctly"" do Jobs::YearlyReview.new.execute({}) raw = Topic.last.first_post.raw expect(raw).to have_tag(""div.likes-given"") { with_text(/\@top_review_user\|11/) } expect(raw).to have_tag(""div.likes-given"") { with_text(/\@reviewed_user\|10/) } expect(raw).to have_tag(""div.likes-received"") { with_text(/\@reviewed_user\|11/) } expect(raw).to have_tag(""div.likes-received"") { with_text(/\@top_review_user\|10/) } end"
3012,"it 'returns success' do get ""/session/email-login/#{email_token.token}"" expect(response).to redirect_to(""/"") end",True,Ruby,'returns success',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def encode_io(io, options = '') command = ffmpeg_command(options: options) IO.popen(command, in: io) end"
3014,"it 'should return the right response' do email_token.update!(created_at: 999.years.ago) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to match( I18n.t('email_login.invalid_token') ) end",True,Ruby,'should return the right response',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def ffmpeg_command(input: '-', options: null) [ @use_avconv ? 'avconv' : 'ffmpeg', '-loglevel', '0', '-i', input, '-f', 's16le', '-ar', '48000', '-ac', '2', 'pipe:1', filter_volume_argument, ].concat(options.split).reject {|segment| segment.nil? || segment == '' } end"
3015,"it 'fails when local logins is disabled' do SiteSetting.enable_local_logins = false get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(500) end",True,Ruby,'fails when local logins is disabled',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,"def encode_file(file, options = '') command = ffmpeg_command(input: file, options: options) IO.popen(command) end"
3016,"it ""fails when user is suspended"" do user.update!( suspended_till: 2.days.from_now, suspended_at: Time.zone.now ) get ""/session/email-login/#{email_token.token}"" expect(response.status).to eq(200) expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only) )) end",True,Ruby,"""fails when user is suspended""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:37+01:00,SECURITY: Add confirmation screen when logging in via email link,CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-1020018,def set_up_request_echo_headers request_url_without_up_params = up.request_url_without_up_params unless request_url_without_up_params == request.original_url response.headers['X-Up-Location'] = up.request_url_without_up_params end response.headers['X-Up-Method'] = request.method end
3017,"def one_time_password otp_username = $redis.get ""otp_#{params[:token]}"" if otp_username && user = User.find_by_username(otp_username) log_on_user(user) $redis.del ""otp_#{params[:token]}"" return redirect_to path(""/"") else @error = I18n.t('user_api_key.invalid_token') end render layout: 'no_ember' end",True,Ruby,one_time_password,session_controller.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:44+01:00,SECURITY: Add confirmation screen when logging in via user-api OTP,NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,it 'does not mangle array params (BUGFIX)' do get '/binding_test/text?_up_1=x&foo%5B%5D=bar&foo%5B%5D=qux&_up_location=up_location' expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux') end
3021,"it 'should authenticate user and delete token' do user = Fabricate(:user) get ""/session/current.json"" expect(response.status).to eq(404) token = SecureRandom.hex $redis.setex ""otp_#{token}"", 10.minutes, user.username get ""/session/otp/#{token}"" expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect($redis.get(""otp_#{token}"")).to eq(nil) get ""/session/current.json"" expect(response.status).to eq(200) end",True,Ruby,'should authenticate user and delete token',session_controller_spec.rb,https://github.com/discourse/discourse,discourse,David Taylor,2019-06-17 16:18:44+01:00,SECURITY: Add confirmation screen when logging in via user-api OTP,NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2019-1020017,"def call(state) driver = instance.driver transport = driver.transport ::Kitchen::Terraform::Provisioner::Converge.new( config: driver.send(:config), connection: transport.connection({}), debug_connection: transport.connection(logger: ::Kitchen::Terraform::DebugLogger.new(logger)), logger: logger, version_requirement: version_requirement, workspace_name: workspace_name, ).call state: state rescue => error ::Kitchen::Terraform::Raise::ActionFailed.new(logger: logger).call message: error.message end"
3026,"def self.publish_unread(post) return unless post.topic.regular? # TODO at high scale we are going to have to defer this, # perhaps cut down to users that are around in the last 7 days as well group_ids = if post.post_type == Post.types[:whisper] [Group::AUTO_GROUPS[:staff]] else post.topic.category && post.topic.category.secure_group_ids end tags = nil tag_ids = nil if include_tags_in_report? tag_ids, tags = post.topic.tags.pluck(:id, :name).transpose end TopicUser .tracking(post.topic_id) .includes(user: :user_stat) .select([:user_id, :last_read_post_number, :notification_level]) .each do |tu| payload = { last_read_post_number: tu.last_read_post_number, highest_post_number: post.post_number, updated_at: post.topic.updated_at, created_at: post.created_at, category_id: post.topic.category_id, notification_level: tu.notification_level, archetype: post.topic.archetype, first_unread_at: tu.user.user_stat.first_unread_at, unread_not_too_old: true } if tags payload[:tags] = tags payload[:topic_tag_ids] = tag_ids end message = { topic_id: post.topic_id, message_type: UNREAD_MESSAGE_TYPE, payload: payload } MessageBus.publish(self.unread_channel_key(tu.user_id), message.as_json, group_ids: group_ids) end end",True,Ruby,self.publish_unread,topic_tracking_state.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2021-08-12 12:16:45+08:00,"SECURITY: User's read state for topic is leaked to unauthorized clients.

A user's read state for a topic such as the last read post number and the notification level is exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2021-37703,"def value self.value = ::Gem::Version.new ""7.0.1"" if not @value @value end"
3029,"it ""generates the correct messages for a secure topic"" do Jobs.run_immediately! UserActionManager.enable admin = Fabricate(:admin) cat = Fabricate(:category) cat.set_permissions(admins: :full) cat.save created_post = nil messages = MessageBus.track_publish do created_post = PostCreator.new(admin, basic_topic_params.merge(category: cat.id)).create _reply = PostCreator.new(admin, raw: ""this is my test reply 123 testing"", topic_id: created_post.topic_id).create end messages.filter! { |m| m.channel != ""/distributed_hash"" } channels = messages.map { |m| m.channel }.sort # 2 for topic, one to notify of new topic another for tracking state expect(channels).to eq( [ ""/new"", ""/u/#{admin.username}"", ""/u/#{admin.username}"", ""/unread/#{admin.id}"", ""/unread/#{admin.id}"", ""/latest"", ""/latest"", ""/topic/#{created_post.topic_id}"", ""/topic/#{created_post.topic_id}"", ""/user"", ""/user"", ""/user"" ].sort ) admin_ids = [Group[:admins].id] expect(messages.any? { |m| m.group_ids != admin_ids && m.user_ids != [admin.id] }).to eq(false) end",True,Ruby,"""generates the correct messages for a secure topic""",post_creator_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2021-08-12 12:16:45+08:00,"SECURITY: User's read state for topic is leaked to unauthorized clients.

A user's read state for a topic such as the last read post number and the notification level is exposed.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2021-37703,"it ""equals the gem version"" do expect(described_class.instance_variable_get(:@plugin_version)).to eq ""7.0.1"" end"
3033,"def bulk_unread_topic_ids topic_query = TopicQuery.new(current_user) if inbox = params[:private_message_inbox] filter = private_message_filter(topic_query, inbox) topic_query.options[:limit] = false topics = topic_query.filter_private_messages_unread(current_user, filter) else topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == ""true"" if params[:category_id] if params[:include_subcategories] topics = topics.where(<<~SQL, category_id: params[:category_id]) category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR category_id = :category_id SQL else topics = topics.where('category_id = ?', params[:category_id]) end end if params[:tag_name].present? topics = topics.joins(:tags).where(""tags.name"": params[:tag_name]) end end topics.pluck(:id) end",True,Ruby,bulk_unread_topic_ids,topics_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def extract_tar_for_moss(tmp_dir, external_tar, archive) return unless external_tar # Directory to hold tar ball and all individual files. extTarDir = File.join(tmp_dir, ""external_input"") baseFilesDir = File.join(tmp_dir, ""basefiles"") begin Dir.mkdir(extTarDir) Dir.mkdir(baseFilesDir) # To hold all basefiles rescue StandardError nil end # Read in the tarfile from the given source. extTarPath = File.join(extTarDir, ""input_file"") external_tar.rewind File.open(extTarPath, ""wb"") { |f| f.write(external_tar.read) } # Write tar file. # Directory to hold all external individual submission. extFilesDir = File.join(extTarDir, ""submissions"") begin Dir.mkdir(extFilesDir) # To hold all submissions rescue StandardError nil end # Untar the given Tar file. begin archive_extract = Archive.get_archive(extTarPath) # write each file, renaming nested files archive_extract.each do |entry| pathname = Archive.get_entry_name(entry) next if Archive.looks_like_directory?(pathname) output_dir = if archive extFilesDir else baseFilesDir end output_file = File.join(output_dir, pathname) # skip if the file lies outside the archive next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir)) # make sure all subdirectories are there File.open(output_file, ""wb"") do |out| out.write Archive.read_entry_file(entry) begin out.fsync rescue StandardError nil end end end rescue StandardError @failures << ""External Tar"" end"
3035,"def private_message_reset_new topic_query = TopicQuery.new(current_user) if params[:topic_ids].present? unless Array === params[:topic_ids] raise Discourse::InvalidParameters.new( ""Expecting topic_ids to contain a list of topic ids"" ) end topic_scope = topic_query .private_messages_for(current_user, :all) .where(""topics.id IN (?)"", params[:topic_ids].map(&:to_i)) else params.require(:inbox) inbox = params[:inbox].to_s filter = private_message_filter(topic_query, inbox) topic_query.options[:limit] = false topic_scope = topic_query.filter_private_message_new(current_user, filter) end topic_ids = TopicsBulkAction.new( current_user, topic_scope.pluck(:id), type: ""dismiss_topics"" ).perform! render json: success_json.merge(topic_ids: topic_ids) end",True,Ruby,private_message_reset_new,topics_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def importAsmtFromTar tarFile = params[""tarFile""] if tarFile.nil? flash[:error] = ""Please select an assessment tarball for uploading."" redirect_to(action: ""install_assessment"") return end begin tarFile = File.new(tarFile.open, ""rb"") tar_extract = Gem::Package::TarReader.new(tarFile) tar_extract.rewind is_valid_tar, asmt_name = valid_asmt_tar(tar_extract) tar_extract.close unless is_valid_tar flash[:error] += ""<br>Invalid tarball. A valid assessment tar has a single root ""\ ""directory that's named after the assessment, containing an ""\ ""assessment yaml file and an assessment ruby file."" flash[:html_safe] = true redirect_to(action: ""install_assessment"") && return end rescue SyntaxError => e flash[:error] = ""Error parsing assessment configuration file:"" # escape so that <compiled> doesn't get treated as a html tag flash[:error] += ""<br><pre>#{CGI.escapeHTML e.to_s}</pre>"" flash[:html_safe] = true redirect_to(action: ""install_assessment"") && return rescue StandardError => e flash[:error] = ""Error while reading the tarball -- #{e.message}."" redirect_to(action: ""install_assessment"") && return end # Check if the assessment already exists. unless @course.assessments.find_by(name: asmt_name).nil? flash[:error] = ""An assessment with the same name already exists for the course. ""\ ""Please use a different name."" redirect_to(action: ""install_assessment"") && return end # If all requirements are satisfied, extract assessment files. begin course_root = Rails.root.join(""courses"", @course.name) assessment_path = Rails.root.join(""courses"", @course.name, asmt_name) tar_extract.rewind tar_extract.each do |entry| relative_pathname = entry.full_name entry_file = File.join(course_root, relative_pathname) # Ensure file will lie within course, otherwise skip next unless Archive.in_dir?(Pathname(entry_file), Pathname(assessment_path)) if entry.directory? FileUtils.mkdir_p(entry_file, mode: entry.header.mode, verbose: false) elsif entry.file? FileUtils.mkdir_p(File.join(course_root, File.dirname(relative_pathname)), mode: entry.header.mode, verbose: false) File.open(entry_file, ""wb"") do |f| f.write entry.read end FileUtils.chmod entry.header.mode, entry_file, verbose: false elsif entry.header.typeflag == ""2"" File.symlink entry.header.linkname, entry_file end end tar_extract.close rescue StandardError => e flash[:error] = ""Error while extracting tarball to server -- #{e.message}."" redirect_to(action: ""install_assessment"") && return end params[:assessment_name] = asmt_name importAssessment && return end"
3037,"def filter_archived(list, user, archived: true) list = list.joins(<<~SQL) LEFT JOIN group_archived_messages gm ON gm.topic_id = topics.id LEFT JOIN user_archived_messages um ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id SQL list = if archived list.where(""um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL"") else list.where(""um.user_id IS NULL AND gm.topic_id IS NULL"") end list end",True,Ruby,filter_archived,private_message_lists.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def extract_tar_for_moss(tmp_dir, external_tar, archive) return unless external_tar # Directory to hold tar ball and all individual files. extTarDir = File.join(tmp_dir, ""external_input"") baseFilesDir = File.join(tmp_dir, ""basefiles"") begin Dir.mkdir(extTarDir) Dir.mkdir(baseFilesDir) # To hold all basefiles rescue StandardError nil end # Read in the tarfile from the given source. extTarPath = File.join(extTarDir, ""input_file"") external_tar.rewind File.open(extTarPath, ""wb"") { |f| f.write(external_tar.read) } # Write tar file. # Directory to hold all external individual submission. extFilesDir = File.join(extTarDir, ""submissions"") begin Dir.mkdir(extFilesDir) # To hold all submissions rescue StandardError nil end # Untar the given Tar file. begin archive_extract = Archive.get_archive(extTarPath) # write each file, renaming nested files archive_extract.each do |entry| pathname = Archive.get_entry_name(entry) next if Archive.looks_like_directory?(pathname) output_dir = if archive extFilesDir else baseFilesDir end output_file = File.join(output_dir, pathname) # skip if the file lies outside the archive next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir)) # make sure all subdirectories are there File.open(output_file, ""wb"") do |out| out.write Archive.read_entry_file(entry) begin out.fsync rescue StandardError nil end end end rescue StandardError @failures << ""External Tar"" end"
3040,"def private_messages_for(user, type) options = @options options.reverse_merge!(per_page: per_page_setting) result = Topic.includes(:allowed_users) result = result.includes(:tags) if SiteSetting.tagging_enabled if type == :group result = result.joins( ""INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')"" ) unless user.admin? result = result.joins(""INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}"") end elsif type == :user result = result.where(""topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})"") elsif type == :all result = result.where(""topics.id IN ( SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i} UNION ALL SELECT topic_id FROM topic_allowed_groups WHERE group_id IN ( SELECT group_id FROM group_users WHERE user_id = #{user.id.to_i} ) )"") end result = result.joins(""LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})"") .order(""topics.bumped_at DESC"") .private_messages result = result.limit(options[:per_page]) unless options[:limit] == false result = result.visible if options[:visible] || @user.nil? || @user.regular? if options[:page] offset = options[:page].to_i * options[:per_page] result = result.offset(offset) if offset > 0 end result end",True,Ruby,private_messages_for,private_message_lists.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def fill_field(model, key, value, params) return model unless model.methods.include? key.to_sym valid_model_class = valid_polymorphic_class params[""#{polymorphic_as}_type""] if polymorphic_as.present? model.send(""#{polymorphic_as}_type="", valid_model_class) # If the type is blank, reset the id too. if valid_model_class.blank? model.send(""#{polymorphic_as}_id="", nil) else model.send(""#{polymorphic_as}_id="", params[""#{polymorphic_as}_id""]) end else model.send(""#{key}="", value) end model end"
3043,"it 'does not include user or group archived messages' do UserArchivedMessage.archive!(user.id, group_message) UserArchivedMessage.archive!(user.id, private_message) topics = TopicQuery.new(nil).list_private_messages_all(user).topics expect(topics).to eq([]) GroupArchivedMessage.archive!(user_2.id, group_message) topics = TopicQuery.new(nil).list_private_messages_all(user_2).topics expect(topics).to contain_exactly(private_message) end",True,Ruby,'does not include user or group archived messages',private_message_lists_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def read return nil if @finished length, extensions = read_line.split("";"", 2) unless length =~ VALID_CHUNK_LENGTH raise BadRequest, ""Invalid chunk length: #{length.dump}"" end # It is possible this line contains chunk extension, so we use `to_i` to only consider the initial integral part: length = Integer(length, 16) if length == 0 @finished = true read_trailer return nil end # Read trailing CRLF: chunk = @stream.read(length + 2) # ...and chomp it off: chunk.chomp!(CRLF) @length += length @count += 1 return chunk end"
3044,"it 'returns a list of all private messages that has been archived' do UserArchivedMessage.archive!(user_2.id, private_message) GroupArchivedMessage.archive!(user_2.id, group_message) topics = TopicQuery.new(nil).list_private_messages_all_archive(user_2).topics expect(topics).to contain_exactly(private_message, group_message) end",True,Ruby,'returns a list of all private messages that has been archived',private_message_lists_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 10:29:42+08:00,"PERF: Improve query performance all inbox private messages. (#14304)

First reported in https://meta.discourse.org/t/-/202482/19

There are two optimizations being applied here:

1. Fetch a user's group ids in a seperate query instead of including it
   as a sub-query. When I tried a subquery, the query plan becomes very
inefficient.

1. Join against the `topic_allowed_users` and `topic_allowed_groups`
   table instead of doing an IN against a subquery where we UNION the
`topic_id`s from the two tables. From my profiling, this enables PG to
do a backwards index scan on the `index_topics_on_timestamps_private`
index.

This commit fixes a bug where listing all messages was incorrectly
excluding topics if a topic has been archived by a group even if the
user did not belong to the group.

This commit also fixes another bug where dismissing private messages
selectively was subjected to the default limit of 30.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"def extract_content_length(headers) if content_length = headers.delete(CONTENT_LENGTH) if content_length =~ VALID_CONTENT_LENGTH yield Integer(content_length, 10) else raise BadRequest, ""Invalid content length: #{content_length}"" end end end"
3047,"def bulk_unread_topic_ids topic_query = TopicQuery.new(current_user) if inbox = params[:private_message_inbox] filter = private_message_filter(topic_query, inbox) topic_query.options[:limit] = false topic_query .filter_private_messages_unread(current_user, filter) .distinct(false) .pluck(:id) else topics = TopicQuery.unread_filter(topic_query.joined_topic_user, staff: guardian.is_staff?).listable_topics topics = TopicQuery.tracked_filter(topics, current_user.id) if params[:tracked].to_s == ""true"" if params[:category_id] if params[:include_subcategories] topics = topics.where(<<~SQL, category_id: params[:category_id]) category_id in (select id FROM categories WHERE parent_category_id = :category_id) OR category_id = :category_id SQL else topics = topics.where('category_id = ?', params[:category_id]) end end if params[:tag_name].present? topics = topics.joins(:tags).where(""tags.name"": params[:tag_name]) end topics.pluck(:id) end end",True,Ruby,bulk_unread_topic_ids,topics_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 11:32:10+08:00,"Partially revert ""PERF: Improve query performance all inbox private messages. (#14304)"" (#14344)

This partially reverts commit ddb458343dc39a7a8c99467dcd809b444514fe2c.

Seeing performance degrade on larger sites so back to drawing board on
this one. Instead of the DISTINCT LEFT JOIN, we switch back to
IN(subquery).",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"it ""can read length of head response"" do body = client.read_response_body(""HEAD"", 200, {'content-length' => '3773'}) expect(body).to be_a ::Protocol::HTTP::Body::Head expect(body.length).to be == 3773 expect(body.read).to be_nil end"
3048,"def private_message_reset_new topic_query = TopicQuery.new(current_user, limit: false) if params[:topic_ids].present? unless Array === params[:topic_ids] raise Discourse::InvalidParameters.new( ""Expecting topic_ids to contain a list of topic ids"" ) end topic_scope = topic_query .private_messages_for(current_user, :all) .where(""topics.id IN (?)"", params[:topic_ids].map(&:to_i)) else params.require(:inbox) inbox = params[:inbox].to_s filter = private_message_filter(topic_query, inbox) topic_scope = topic_query.filter_private_message_new(current_user, filter) end topic_ids = TopicsBulkAction.new( current_user, topic_scope.distinct(false).pluck(:id), type: ""dismiss_topics"" ).perform! render json: success_json.merge(topic_ids: topic_ids) end",True,Ruby,private_message_reset_new,topics_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 11:32:10+08:00,"Partially revert ""PERF: Improve query performance all inbox private messages. (#14304)"" (#14344)

This partially reverts commit ddb458343dc39a7a8c99467dcd809b444514fe2c.

Seeing performance degrade on larger sites so back to drawing board on
this one. Instead of the DISTINCT LEFT JOIN, we switch back to
IN(subquery).",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,"it ""ignores zero length body"" do body = client.read_response_body(""HEAD"", 200, {'content-length' => '0'}) expect(body).to be_nil end"
3050,"def private_messages_for(user, type) options = @options options.reverse_merge!(per_page: per_page_setting) result = Topic.includes(:allowed_users) result = result.includes(:tags) if SiteSetting.tagging_enabled if type == :group result = result.joins( ""INNER JOIN topic_allowed_groups tag ON tag.topic_id = topics.id AND tag.group_id IN (SELECT id FROM groups WHERE LOWER(name) = '#{PG::Connection.escape_string(@options[:group_name].downcase)}')"" ) unless user.admin? result = result.joins(""INNER JOIN group_users gu ON gu.group_id = tag.group_id AND gu.user_id = #{user.id.to_i}"") end elsif type == :user result = result.where(""topics.id IN (SELECT topic_id FROM topic_allowed_users WHERE user_id = #{user.id.to_i})"") elsif type == :all group_ids = group_with_messages_ids(user) result = result.joins(<<~SQL) LEFT JOIN topic_allowed_users tau ON tau.topic_id = topics.id AND tau.user_id = #{user.id.to_i} LEFT JOIN topic_allowed_groups tag ON tag.topic_id = topics.id #{group_ids.present? ? ""AND tag.group_id IN (#{group_ids.join("","")})"" : """"} SQL result = result .where(""tag.topic_id IS NOT NULL OR tau.topic_id IS NOT NULL"") .distinct end result = result.joins(""LEFT OUTER JOIN topic_users AS tu ON (topics.id = tu.topic_id AND tu.user_id = #{user.id.to_i})"") .order(""topics.bumped_at DESC"") .private_messages result = result.limit(options[:per_page]) unless options[:limit] == false result = result.visible if options[:visible] || @user.nil? || @user.regular? if options[:page] offset = options[:page].to_i * options[:per_page] result = result.offset(offset) if offset > 0 end result end",True,Ruby,private_messages_for,private_message_lists.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 11:32:10+08:00,"Partially revert ""PERF: Improve query performance all inbox private messages. (#14304)"" (#14344)

This partially reverts commit ddb458343dc39a7a8c99467dcd809b444514fe2c.

Seeing performance degrade on larger sites so back to drawing board on
this one. Instead of the DISTINCT LEFT JOIN, we switch back to
IN(subquery).",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,
3052,"def filter_archived(list, user, archived: true) # Executing an extra query instead of a sub-query because it is more # efficient for the PG planner. Caution should be used when changing the # query here as it can easily lead to an inefficient query. group_ids = group_with_messages_ids(user) list = list.joins(<<~SQL) LEFT JOIN group_archived_messages gm ON gm.topic_id = topics.id #{group_ids.present? ? ""AND gm.group_id IN (#{group_ids.join("","")})"" : """"} LEFT JOIN user_archived_messages um ON um.user_id = #{user.id.to_i} AND um.topic_id = topics.id SQL list = if archived list.where(""um.user_id IS NOT NULL OR gm.topic_id IS NOT NULL"") else list.where(""um.user_id IS NULL AND gm.topic_id IS NULL"") end list end",True,Ruby,filter_archived,private_message_lists.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-09-15 11:32:10+08:00,"Partially revert ""PERF: Improve query performance all inbox private messages. (#14304)"" (#14344)

This partially reverts commit ddb458343dc39a7a8c99467dcd809b444514fe2c.

Seeing performance degrade on larger sites so back to drawing board on
this one. Instead of the DISTINCT LEFT JOIN, we switch back to
IN(subquery).",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2021-41082,
3057,"it 'should return the right response for a single option' do DiscoursePoll::Poll.vote( user, post.id, DiscoursePoll::DEFAULT_POLL_NAME, [option_a, option_b] ) get ""/polls/voters.json"", params: { post_id: post.id, poll_name: DiscoursePoll::DEFAULT_POLL_NAME, option_id: option_b } expect(response.status).to eq(200) poll = response.parsed_body[""voters""] expect(poll[option_a]).to eq(nil) option = poll[option_b] expect(option.length).to eq(1) expect(option.first[""id""]).to eq(user.id) expect(option.first[""username""]).to eq(user.username) end",True,Ruby,'should return the right response for a single option',poll_endpoints_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2021-11-19 09:50:08+08:00,"FIX: Validate number of votes allowed per poll per user. (#15001)

* DEV: Remove spec that we no longer need.

As far as we know, the migration has been successful for a number of
years.

* FIX: Validate number of votes allowed per poll per user.",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2021-43793,
3063,"def search_ids users = Set.new # 1. exact username matches if @term.present? exact_matches = scoped_users.where(username_lower: @term) # don't pollute mentions with users who haven't shown up in over a year exact_matches = exact_matches.where('last_seen_at > ?', 1.year.ago) if @topic_id || @category_id exact_matches .limit(@limit) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 2. in topic if @topic_id in_topic = filtered_by_term_users .where('users.id IN (SELECT user_id FROM posts WHERE topic_id = ?)', @topic_id) if @searching_user.present? in_topic = in_topic.where('users.id <> ?', @searching_user.id) end in_topic .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 3. in category secure_category_id = if @category_id DB.query_single(<<~SQL, @category_id).first SELECT id FROM categories WHERE read_restricted AND id = ? SQL elsif @topic_id DB.query_single(<<~SQL, @topic_id).first SELECT id FROM categories WHERE read_restricted AND id IN (SELECT category_id FROM topics WHERE id = ?) SQL end if secure_category_id category_groups = Group.where(<<~SQL, secure_category_id, MAX_SIZE_PRIORITY_MENTION) groups.id IN ( SELECT group_id FROM category_groups JOIN groups g ON group_id = g.id WHERE category_id = ? AND user_count < ? ) SQL if @searching_user.present? category_groups = category_groups.members_visible_groups(@searching_user) end in_category = filtered_by_term_users .where(<<~SQL, category_groups.pluck(:id)) users.id IN ( SELECT gu.user_id FROM group_users gu WHERE group_id IN (?) LIMIT 200 ) SQL if @searching_user.present? in_category = in_category.where('users.id <> ?', @searching_user.id) end in_category .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end return users.to_a if users.size >= @limit # 4. global matches if @term.present? filtered_by_term_users .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end # 5. last seen users (for search auto-suggestions) if @last_seen_users scoped_users .order('last_seen_at DESC NULLS LAST') .limit(@limit - users.size) .pluck(:id) .each { |id| users << id } end users.to_a end",True,Ruby,search_ids,user_search.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-01-03 13:25:40+05:18,SECURITY: only show user suggestions with regular post (#15436),CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-21642,
3066,def restrict_user_fields?(user) user.trust_level == TrustLevel[0] && anonymous? end,True,Ruby,restrict_user_fields?,user_guardian.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-01-05 10:23:36+08:00,"FIX: Hide user's bio if profile is restricted

The bio was sometimes visible in the meta tags even though it it should
not have been.",CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-21678,
3071,"it 'supports group' do topic = Fabricate(:topic, created_at: 3.months.ago) post = Fabricate(:post, raw: 'hi this is a test 123 123', topic: topic) group = Group.create!(name: ""Like_a_Boss"") GroupUser.create!(user_id: post.user_id, group_id: group.id) expect(Search.execute('group:like_a_boss').posts.length).to eq(1) expect(Search.execute('group:""like a brick""').posts.length).to eq(0) end",True,Ruby,'supports group',search_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-01-10 13:49:26+08:00,SECURITY: Advanced group search did not respect visiblity of groups.,CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-21677,
3074,"def perform_accept_invitation params.require(:id) params.permit(:email, :username, :name, :password, :timezone, :email_token, user_custom_fields: {}) invite = Invite.find_by(invite_key: params[:id]) if invite.present? begin attrs = { username: params[:username], name: params[:name], password: params[:password], user_custom_fields: params[:user_custom_fields], ip_address: request.remote_ip, session: session } if invite.is_invite_link? params.require(:email) attrs[:email] = params[:email] else attrs[:email] = invite.email attrs[:email_token] = params[:email_token] if params[:email_token].present? end user = invite.redeem(**attrs) rescue ActiveRecord::RecordInvalid, ActiveRecord::RecordNotSaved, Invite::UserExists => e return render json: failed_json.merge(message: e.message), status: 412 end if user.blank? return render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404 end log_on_user(user) if user.active? user.update_timezone_if_missing(params[:timezone]) post_process_invite(user) create_topic_invite_notifications(invite, user) topic = invite.topics.first response = {} if user.present? if user.active? if user.guardian.can_see?(topic) response[:redirect_to] = path(topic.relative_url) else response[:redirect_to] = path(""/"") end else response[:message] = I18n.t('invite.confirm_email') if user.guardian.can_see?(topic) cookies[:destination_url] = path(topic.relative_url) end end end render json: success_json.merge(response) else render json: failed_json.merge(message: I18n.t('invite.not_found_json')), status: 404 end end",True,Ruby,perform_accept_invitation,invites_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-01-12 22:24:54+02:00,SECURITY: Do not sign in unapproved users (#15552),CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2022-21684,
3077,"def resolve if @uri && @uri.port == 80 && FinalDestination.is_https_domain?(@uri.hostname) @uri.scheme = ""https"" @uri = URI(@uri.to_s) end if @limit < 0 @status = :too_many_redirects log(:warn, ""FinalDestination could not resolve URL (too many redirects): #{@uri}"") if @verbose return nil end unless validate_uri @status = :invalid_address log(:warn, ""FinalDestination could not resolve URL (invalid URI): #{@uri}"") if @verbose return nil end @ignored.each do |host| if @uri&.hostname&.match?(host) @status = :resolved return @uri end end if Oneboxer.cached_response_body_exists?(@uri.to_s) @status = :resolved return @uri end headers = request_headers middlewares = Excon.defaults[:middlewares] middlewares << Excon::Middleware::Decompress if @http_verb == :get response = Excon.public_send(@http_verb, @uri.to_s, read_timeout: timeout, connect_timeout: timeout, headers: headers, middlewares: middlewares ) location = nil response_headers = nil response_status = response.status.to_i case response.status when 200 # Cache body of successful `get` requests if @http_verb == :get if Oneboxer.cache_response_body?(@uri) Oneboxer.cache_response_body(@uri.to_s, response.body) end end if @follow_canonical next_url = fetch_canonical_url(response.body) if next_url.to_s.present? && next_url != @uri @follow_canonical = false @uri = next_url @http_verb = http_verb(@force_get_hosts, @follow_canonical) return resolve end end @content_type = response.headers['Content-Type'] if response.headers.has_key?('Content-Type') @status = :resolved return @uri when 103, 400, 405, 406, 409, 500, 501 response_status, small_headers = small_get(request_headers) if response_status == 200 @status = :resolved return @uri end response_headers = {} if cookie_val = small_headers['set-cookie'] response_headers[:cookies] = cookie_val end if location_val = small_headers['location'] response_headers[:location] = location_val.join end end",True,Ruby,resolve,final_destination.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-02-14 12:11:09+11:00,"SECURITY: Onebox response timeout and size limit (#15927)

Validation to ensure that Onebox request is no longer than 10 seconds and response size is not bigger than 1 MB",CWE-835,Loop with Unreachable Exit Condition ('Infinite Loop'),"The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",https://cwe.mitre.org/data/definitions/835.html,CVE-2022-23641,
3083,"def category_preferences_export return enum_for(:category_preferences_export) unless block_given? CategoryUser .where(user_id: @current_user.id) .select(:category_id, :notification_level, :last_seen_at) .each do |cu| yield [ cu.category_id, piped_category_name(cu.category_id), NotificationLevels.all[cu.notification_level], cu.last_seen_at ] end end",True,Ruby,category_preferences_export,export_user_archive.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-03-24 15:38:44+10:00,"SECURITY: Hide private categories in user activity export (#16273)

In some of the user's own activity export data,
we sometimes showed a secure category's name or
exposed the existence of a secure category.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-24782,
3084,"def get_user_archive_fields(user_archive) user_archive_array = [] topic_data = user_archive.topic user_archive = user_archive.as_json topic_data = Topic.with_deleted.find_by(id: user_archive['topic_id']) if topic_data.nil? return user_archive_array if topic_data.nil? categories = piped_category_name(topic_data.category_id) is_pm = topic_data.archetype == ""private_message"" ? I18n.t(""csv_export.boolean_yes"") : I18n.t(""csv_export.boolean_no"") url = ""#{Discourse.base_url}/t/#{topic_data.slug}/#{topic_data.id}/#{user_archive['post_number']}"" topic_hash = { ""post"" => user_archive['raw'], ""topic_title"" => topic_data.title, ""categories"" => categories, ""is_pm"" => is_pm, ""url"" => url } user_archive.merge!(topic_hash) HEADER_ATTRS_FOR['user_archive'].each do |attr| user_archive_array.push(user_archive[attr]) end user_archive_array end",True,Ruby,get_user_archive_fields,export_user_archive.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-03-24 15:38:44+10:00,"SECURITY: Hide private categories in user activity export (#16273)

In some of the user's own activity export data,
we sometimes showed a secure category's name or
exposed the existence of a secure category.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-24782,
3086,"def piped_category_name(category_id) return ""-"" unless category_id category = Category.find_by(id: category_id) return ""#{category_id}"" unless category categories = [category.name] while category.parent_category_id && category = category.parent_category categories << category.name end categories.reverse.join(""|"") end",True,Ruby,piped_category_name,export_user_archive.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-03-24 15:38:44+10:00,"SECURITY: Hide private categories in user activity export (#16273)

In some of the user's own activity export data,
we sometimes showed a secure category's name or
exposed the existence of a secure category.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-24782,
3089,"it 'correctly exports the CategoryUser table' do data, _csv_out = make_component_csv expect(data.find { |r| r['category_id'] == category.id }).to be_nil expect(data.length).to eq(4) data.sort! { |a, b| a['category_id'].to_i <=> b['category_id'].to_i } expect(data[0][:category_id]).to eq(subcategory.id.to_s) expect(data[0][:notification_level].to_s).to eq('tracking') expect(DateTime.parse(data[0][:dismiss_new_timestamp])).to eq(reset_at) expect(data[1][:category_id]).to eq(subsubcategory.id.to_s) expect(data[1][:category_names]).to eq(""#{category.name}|#{subcategory.name}|#{subsubcategory.name}"") expect(data[1][:notification_level]).to eq('regular') expect(DateTime.parse(data[1][:dismiss_new_timestamp])).to eq(reset_at) expect(data[2][:category_id]).to eq(announcements.id.to_s) expect(data[2][:category_names]).to eq(announcements.name) expect(data[2][:notification_level]).to eq('watching_first_post') expect(data[2][:dismiss_new_timestamp]).to eq('') expect(data[3][:category_names]).to eq(data[3][:category_id]) end",True,Ruby,'correctly exports the CategoryUser table',export_user_archive_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-03-24 15:38:44+10:00,"SECURITY: Hide private categories in user activity export (#16273)

In some of the user's own activity export data,
we sometimes showed a secure category's name or
exposed the existence of a secure category.",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2022-24782,
3100,"it ""returns the right category group permissions for a regular user ordered by ascending group name"" do json = described_class.new(category, scope: Guardian.new(user), root: false).as_json expect(json[:group_permissions]).to eq([ { permission_type: CategoryGroup.permission_types[:readonly], group_name: group.name }, { permission_type: CategoryGroup.permission_types[:full], group_name: user_group.name }, ]) end",True,Ruby,"""returns the right category group permissions for a regular user ordered by ascending group name""",category_serializer_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-04-08 13:46:20+08:00,"SECURITY: Category group permissions leaked to normal users.

After this commit, category group permissions can only be seen by users
that are allowed to manage a category. In the past, we inadvertently
included a category's group permissions settings in `CategoriesController#show`
and `CategoriesController#find_by_slug` endpoints for normal users when
those settings are only a concern to users that can manage a category.",CWE-276,Incorrect Default Permissions,"During installation, installed file permissions are set to allow anyone to modify those files.",https://cwe.mitre.org/data/definitions/276.html,CVE-2022-24804,
3102,"it ""returns the right category group permissions for an anon user"" do json = described_class.new(category, scope: Guardian.new, root: false).as_json expect(json[:group_permissions]).to eq([ { permission_type: CategoryGroup.permission_types[:full], group_name: Group[:everyone]&.name } ]) end",True,Ruby,"""returns the right category group permissions for an anon user""",category_serializer_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-04-08 13:46:20+08:00,"SECURITY: Category group permissions leaked to normal users.

After this commit, category group permissions can only be seen by users
that are allowed to manage a category. In the past, we inadvertently
included a category's group permissions settings in `CategoriesController#show`
and `CategoriesController#find_by_slug` endpoints for normal users when
those settings are only a concern to users that can manage a category.",CWE-276,Incorrect Default Permissions,"During installation, installed file permissions are set to allow anyone to modify those files.",https://cwe.mitre.org/data/definitions/276.html,CVE-2022-24804,
3103,"it ""returns the right category group permission for a staff user ordered by ascending group name"" do json = described_class.new(category, scope: Guardian.new(admin), root: false).as_json expect(json[:group_permissions]).to eq([ { permission_type: CategoryGroup.permission_types[:readonly], group_name: group.name }, { permission_type: CategoryGroup.permission_types[:full], group_name: private_group.name }, { permission_type: CategoryGroup.permission_types[:full], group_name: user_group.name }, { permission_type: CategoryGroup.permission_types[:readonly], group_name: 'everyone' }, ]) end",True,Ruby,"""returns the right category group permission for a staff user ordered by ascending group name""",category_serializer_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-04-08 13:46:20+08:00,"SECURITY: Category group permissions leaked to normal users.

After this commit, category group permissions can only be seen by users
that are allowed to manage a category. In the past, we inadvertently
included a category's group permissions settings in `CategoriesController#show`
and `CategoriesController#find_by_slug` endpoints for normal users when
those settings are only a concern to users that can manage a category.",CWE-276,Incorrect Default Permissions,"During installation, installed file permissions are set to allow anyone to modify those files.",https://cwe.mitre.org/data/definitions/276.html,CVE-2022-24804,
3106,"it ""returns the group permissions for everyone group too"" do category.set_permissions(everyone: :readonly) category.save! json = described_class.new(category, scope: Guardian.new(admin), root: false).as_json expect(json[:group_permissions]).to eq([ { permission_type: CategoryGroup.permission_types[:readonly], group_name: 'everyone' }, ]) end",True,Ruby,"""returns the group permissions for everyone group too""",category_serializer_spec.rb,https://github.com/discourse/discourse,discourse,Alan Guo Xiang Tan,2022-04-08 13:46:20+08:00,"SECURITY: Category group permissions leaked to normal users.

After this commit, category group permissions can only be seen by users
that are allowed to manage a category. In the past, we inadvertently
included a category's group permissions settings in `CategoriesController#show`
and `CategoriesController#find_by_slug` endpoints for normal users when
those settings are only a concern to users that can manage a category.",CWE-276,Incorrect Default Permissions,"During installation, installed file permissions are set to allow anyone to modify those files.",https://cwe.mitre.org/data/definitions/276.html,CVE-2022-24804,
3108,"def sso_login raise Discourse::NotFound unless SiteSetting.enable_discourse_connect raise Discourse::ReadOnly if @readonly_mode && !staff_writes_only_mode? params.require(:sso) params.require(:sig) begin sso = DiscourseConnect.parse(request.query_string, secure_session: secure_session) rescue DiscourseConnect::ParseError => e connect_verbose_warn { ""Verbose SSO log: Signature parse error\n\n#{e.message}\n\n#{sso&.diagnostics}"" } # Do NOT pass the error text to the client, it would give them the correct signature return render_sso_error(text: I18n.t(""discourse_connect.login_error""), status: 422) end if !sso.nonce_valid? connect_verbose_warn { ""Verbose SSO log: #{sso.nonce_error}\n\n#{sso.diagnostics}"" } return render_sso_error(text: I18n.t(""discourse_connect.timeout_expired""), status: 419) end if ScreenedIpAddress.should_block?(request.remote_ip) connect_verbose_warn { ""Verbose SSO log: IP address is blocked #{request.remote_ip}\n\n#{sso.diagnostics}"" } return render_sso_error(text: I18n.t(""discourse_connect.unknown_error""), status: 500) end return_path = sso.return_path sso.expire_nonce! begin invite = validate_invitiation!(sso) if user = sso.lookup_or_create_user(request.remote_ip) raise Discourse::ReadOnly if staff_writes_only_mode? && !user&.staff? if user.suspended? render_sso_error(text: failed_to_login(user)[:error], status: 403) return end # users logging in via SSO using an invite do not need to be approved, # they are already pre-approved because they have been invited if SiteSetting.must_approve_users? && !user.approved? && invite.blank? if SiteSetting.discourse_connect_not_approved_url.present? redirect_to SiteSetting.discourse_connect_not_approved_url, allow_other_host: true else render_sso_error(text: I18n.t(""discourse_connect.account_not_approved""), status: 403) end return # we only want to redeem the invite if # the user has not already redeemed an invite # (covers the same SSO user visiting an invite link) elsif invite.present? && user.invited_user.blank? redeem_invitation(invite, sso) # we directly call user.activate here instead of going # through the UserActivator path because we assume the account # is valid from the SSO provider's POV and do not need to # send an activation email to the user user.activate login_sso_user(sso, user) topic = invite.topics.first return_path = topic.present? ? path(topic.relative_url) : path(""/"") elsif !user.active? activation = UserActivator.new(user, request, session, cookies) activation.finish session[""user_created_message""] = activation.message return redirect_to(users_account_created_path) else login_sso_user(sso, user) end # If it's not a relative URL check the host if return_path !~ /^\/[^\/]/ begin uri = URI(return_path) if (uri.hostname == Discourse.current_hostname) return_path = uri.to_s elsif !SiteSetting.discourse_connect_allows_all_return_paths return_path = path(""/"") end rescue return_path = path(""/"") end end # this can be done more surgically with a regex # but it the edge case of never supporting redirects back to # any url with `/session/sso` in it anywhere is reasonable if return_path.include?(path(""/session/sso"")) return_path = path(""/"") end redirect_to return_path, allow_other_host: true else render_sso_error(text: I18n.t(""discourse_connect.not_found""), status: 500) end rescue ActiveRecord::RecordInvalid => e connect_verbose_warn { <<~TEXT } Verbose SSO log: Record was invalid: #{e.record.class.name} #{e.record.id} #{e.record.errors.to_h} Attributes: #{e.record.attributes.slice(*DiscourseConnectBase::ACCESSORS.map(&:to_s))} SSO Diagnostics: #{sso.diagnostics} TEXT text = nil # If there's a problem with the email we can explain that if (e.record.is_a?(User) && e.record.errors[:primary_email].present?) if e.record.email.blank? text = I18n.t(""discourse_connect.no_email"") else text = I18n.t(""discourse_connect.email_error"", email: ERB::Util.html_escape(e.record.email)) end end render_sso_error(text: text || I18n.t(""discourse_connect.unknown_error""), status: 500) rescue DiscourseConnect::BlankExternalId render_sso_error(text: I18n.t(""discourse_connect.blank_id_error""), status: 500) rescue Invite::ValidationFailed => e render_sso_error(text: e.message, status: 400) rescue Invite::RedemptionFailed => e render_sso_error(text: I18n.t(""discourse_connect.invite_redeem_failed""), status: 412) rescue Invite::UserExists => e render_sso_error(text: e.message, status: 412) rescue => e message = +""Failed to create or lookup user: #{e}."" message << "" "" message << "" #{sso.diagnostics}"" message << "" "" message << "" #{e.backtrace.join(""\n"")}"" Rails.logger.error(message) render_sso_error(text: I18n.t(""discourse_connect.unknown_error""), status: 500) end end",True,Ruby,sso_login,session_controller.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3109,"def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil) if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email) available_username = username else available_username = UserNameSuggester.suggest(email) end if email.present? && invite.domain.present? username, domain = email.split('@') if domain.present? && invite.domain != domain raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end end user = User.where(staged: true).with_email(email.strip.downcase).first user.unstage! if user user ||= User.new user.attributes = { email: email, username: available_username, name: name || available_username, active: false, trust_level: SiteSetting.default_invitee_trust_level, ip_address: ip_address, registration_ip_address: ip_address } if !SiteSetting.must_approve_users? || (SiteSetting.must_approve_users? && invite.invited_by.staff?) || EmailValidator.can_auto_approve_user?(user.email) ReviewableUser.set_approved_fields!(user, invite.invited_by) end user_fields = UserField.all if user_custom_fields.present? && user_fields.present? field_params = user_custom_fields || {} fields = user.custom_fields user_fields.each do |f| field_val = field_params[f.id.to_s] fields[""#{User::USER_FIELD_PREFIX}#{f.id}""] = field_val[0...UserField.max_length] unless field_val.blank? end user.custom_fields = fields end user.moderator = true if invite.moderator? && invite.invited_by.staff? if password user.password = password user.password_required! end authenticator = UserAuthenticator.new(user, session, require_password: false) if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end authenticator.start if authenticator.email_valid? && !authenticator.authenticated? raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end user.save! authenticator.finish if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup]) user.activate end User.find(user.id) end",True,Ruby,self.create_user_from_invite,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3111,def process_invitation approve_account_if_needed add_to_private_topics_if_invited add_user_to_groups send_welcome_message notify_invitee end,True,Ruby,process_invitation,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3112,"def approve_account_if_needed if invited_user.present? && reviewable_user = ReviewableUser.find_by(target: invited_user, status: Reviewable.statuses[:pending]) reviewable_user.perform( invite.invited_by, :approve_user, send_email: false, approved_by_invite: true ) end end",True,Ruby,approve_account_if_needed,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3114,"def build_actions(actions, guardian, args) return unless pending? if guardian.can_approve?(target) || args[:approved_by_invite] actions.add(:approve_user) do |a| a.icon = 'user-plus' a.label = ""reviewables.actions.approve_user.title"" end end delete_user_actions(actions, require_reject_reason: !is_a_suspect_user?) end",True,Ruby,build_actions,reviewable_user.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3116,"it ""should be created correctly"" do invite = Fabricate(:invite, email: 'walter.white@email.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(true) expect(user.active).to eq(false) end",True,Ruby,"""should be created correctly""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3121,"it ""can set password"" do user = InviteRedeemer.new(invite: invite, email: invite.email, username: username, name: name, password: password).redeem expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(true) end",True,Ruby,"""can set password""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3122,"it ""should redeem the invite if invited by non staff and approve if email in auto_approve_email_domains setting"" do SiteSetting.must_approve_users = true SiteSetting.auto_approve_email_domains = ""example.com"" user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.approved).to eq(true) end",True,Ruby,"""should redeem the invite if invited by non staff and approve if email in auto_approve_email_domains setting""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3123,"it ""should redeem the invite if invited by non staff and approve if staff not required to approve"" do inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(true) end",True,Ruby,"""should redeem the invite if invited by non staff and approve if staff not required to approve""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3124,"it ""should unstage user"" do staged_user = Fabricate(:staged, email: 'staged@account.com', active: true, username: 'staged1', name: 'Stage Name') invite = Fabricate(:invite, email: 'staged@account.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.id).to eq(staged_user.id) expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.staged).to eq(false) expect(user.email).to eq('staged@account.com') expect(user.approved).to eq(true) end",True,Ruby,"""should unstage user""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3125,"it ""does not activate user invited via links"" do invite = Fabricate(:invite, email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:not_required]) user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White') expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(true) expect(user.active).to eq(false) end",True,Ruby,"""does not activate user invited via links""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3128,"it ""should redeem the invite if invited by non staff but not approve"" do SiteSetting.must_approve_users = true inviter = invite.invited_by user = invite_redeemer.redeem expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(false) end",True,Ruby,"""should redeem the invite if invited by non staff but not approve""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3129,"it ""does not raise error if record is not pending"" do reviewable = ReviewableUser.needs_review!(target: Fabricate(:user, email: invite.email), created_by: invite.invited_by) reviewable.status = Reviewable.statuses[:ignored] reviewable.save! invite_redeemer.redeem reviewable.reload expect(reviewable.status).to eq(Reviewable.statuses[:ignored]) end",True,Ruby,"""does not raise error if record is not pending""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3130,"it ""approves pending record"" do reviewable = ReviewableUser.needs_review!(target: Fabricate(:user, email: invite.email), created_by: invite.invited_by) reviewable.status = Reviewable.statuses[:pending] reviewable.save! invite_redeemer.redeem reviewable.reload expect(reviewable.status).to eq(Reviewable.statuses[:approved]) end",True,Ruby,"""approves pending record""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3131,"it ""approves user if invited by staff"" do SiteSetting.must_approve_users = true invite = Fabricate(:invite, email: 'test@example.com', invited_by: Fabricate(:admin)) user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'test') expect(user.approved).to eq(true) end",True,Ruby,"""approves user if invited by staff""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3133,"it ""can set the password and ip_address"" do password = 's3cure5tpasSw0rD' ip_address = '192.168.1.1' invite = Fabricate(:invite, email: 'walter.white@email.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', password: password, ip_address: ip_address) expect(user).to have_password expect(user.confirm_password?(password)).to eq(true) expect(user.approved).to eq(true) expect(user.ip_address).to eq(ip_address) expect(user.registration_ip_address).to eq(ip_address) end",True,Ruby,"""can set the password and ip_address""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3135,"it ""does not automatically approve users if must_approve_users is true"" do SiteSetting.must_approve_users = true invite = Fabricate(:invite, email: 'test@example.com') user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'test') expect(user.approved).to eq(false) end",True,Ruby,"""does not automatically approve users if must_approve_users is true""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3137,"it ""should redeem the invite if invited by staff"" do SiteSetting.must_approve_users = true inviter = invite.invited_by inviter.admin = true user = invite_redeemer.redeem invite.reload expect(user.name).to eq(name) expect(user.username).to eq(username) expect(user.invited_by).to eq(inviter) expect(inviter.notifications.count).to eq(1) expect(user.approved).to eq(true) end",True,Ruby,"""should redeem the invite if invited by staff""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3138,"it ""activates user invited via email with a token"" do invite = Fabricate(:invite, invited_by: Fabricate(:admin), email: 'walter.white@email.com', emailed_status: Invite.emailed_status_types[:sent]) user = InviteRedeemer.create_user_from_invite(invite: invite, email: invite.email, username: 'walter', name: 'Walter White', email_token: invite.email_token) expect(user.username).to eq('walter') expect(user.name).to eq('Walter White') expect(user.email).to eq('walter.white@email.com') expect(user.approved).to eq(true) expect(user.active).to eq(true) end",True,Ruby,"""activates user invited via email with a token""",invite_redeemer_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3139,it 'activates user when must_approve_users? is enabled' do SiteSetting.must_approve_users = true invite.invited_by = Fabricate(:admin) user = invite.redeem expect(user.approved?).to eq(true) end,True,Ruby,'activates user when must_approve_users? is enabled',invite_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3140,"it ""allows you to create an account and redeems the invite successfully even if must_approve_users is enabled"" do SiteSetting.must_approve_users = true login_with_sso_and_invite expect(response.status).to eq(302) expect(response).to redirect_to(""/"") expect(invite.reload.redeemed?).to eq(true) user = User.find_by_email(""bob@bob.com"") expect(user.active).to eq(true) end",True,Ruby,"""allows you to create an account and redeems the invite successfully even if must_approve_users is enabled""",session_controller_spec.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-02 16:10:48+02:00,"SECURITY: Remove auto approval when redeeming an invite (#16974)

This security fix affects sites which have `SiteSetting.must_approve_users`
enabled. There are intentional and unintentional cases where invited
users can be auto approved and are deemed to have skipped the staff approval process.
Instead of trying to reason about when auto-approval should happen, we have decided that
enabling the `must_approve_users` setting going forward will just mean that all new users
must be explicitly approved by a staff user in the review queue. The only case where users are auto
approved is when the `auto_approve_email_domains` site setting is used.

Co-authored-by: Alan Guo Xiang Tan <gxtan1990@gmail.com>",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3142,"def self.create_user_from_invite(email:, invite:, username: nil, name: nil, password: nil, user_custom_fields: nil, ip_address: nil, session: nil, email_token: nil) if username && UsernameValidator.new(username).valid_format? && User.username_available?(username, email) available_username = username else available_username = UserNameSuggester.suggest(email) end if email.present? && invite.domain.present? username, domain = email.split('@') if domain.present? && invite.domain != domain raise ActiveRecord::RecordNotSaved.new(I18n.t('invite.domain_not_allowed')) end end user = User.where(staged: true).with_email(email.strip.downcase).first user.unstage! if user user ||= User.new user.attributes = { email: email, username: available_username, name: name || available_username, active: false, trust_level: SiteSetting.default_invitee_trust_level, ip_address: ip_address, registration_ip_address: ip_address } if SiteSetting.must_approve_users? && EmailValidator.can_auto_approve_user?(user.email) ReviewableUser.set_approved_fields!(user, Discourse.system_user) end user_fields = UserField.all if user_custom_fields.present? && user_fields.present? field_params = user_custom_fields || {} fields = user.custom_fields user_fields.each do |f| field_val = field_params[f.id.to_s] fields[""#{User::USER_FIELD_PREFIX}#{f.id}""] = field_val[0...UserField.max_length] unless field_val.blank? end user.custom_fields = fields end user.moderator = true if invite.moderator? && invite.invited_by.staff? if password user.password = password user.password_required! end authenticator = UserAuthenticator.new(user, session, require_password: false) if !authenticator.has_authenticator? && !SiteSetting.enable_local_logins raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end authenticator.start if authenticator.email_valid? && !authenticator.authenticated? raise ActiveRecord::RecordNotSaved.new(I18n.t(""login.incorrect_username_email_or_password"")) end user.save! authenticator.finish if invite.emailed_status != Invite.emailed_status_types[:not_required] && email == invite.email && invite.email_token.present? && email_token == invite.email_token user.email_tokens.create!(email: user.email, scope: EmailToken.scopes[:signup]) user.activate end User.find(user.id) end",True,Ruby,self.create_user_from_invite,invite_redeemer.rb,https://github.com/discourse/discourse,discourse,GitHub,2022-06-03 11:43:52+08:00,"FIX: Approves user when redeeming an invite for invites only sites (#16984)

When a site has `SiteSetting.invite_only` enabled, we create a
`ReviewableUser`record when activating a user if the user is not
approved. Therefore, we need to approve the user when redeeming an
invite.

There are some uncertainties surrounding why a `ReviewableRecord` is
created for a user in an invites only site but this commit does not seek
to address that.

Follow-up to 7c4e2d33fa4b922354c177ffc880a2f2701a91f9",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-31025,
3149,"def self.open(path_or_url, ext = nil, options = {}) options, ext = ext, nil if ext.is_a?(Hash) ext ||= if File.exist?(path_or_url) File.extname(path_or_url) else File.extname(URI(path_or_url).path) end ext.sub!(/:.*/, '') # hack for filenames or URLs that include a colon Kernel.open(path_or_url, ""rb"", options) do |file| read(file, ext) end end",True,Ruby,self.open,image.rb,https://github.com/minimagick/minimagick,minimagick,Janko Marohnić,2019-05-26 17:47:24+02:00,"Don't allow remote shell execution

Kernel#open accepts a string of format ""| <shell command>"" which
executes the specified shell command and otherwise presumably acts as
IO.popen. The open-uri standard library overrides Kernel#open to also
accept URLs.

However, the overridden Kernel#open just delegates to URI#open, so we
switch to using that directly and avoid the remote shell execution
vulnerability. For files we just use File.open, which should have the
same behaviour as Kernel#open.",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2019-13574,
3154,"def decode_compact_serialized(input, private_key_or_secret, algorithms = nil, encryption_methods = nil, _allow_blank_payload = false) unless input.count('.') + 1 == NUM_OF_SEGMENTS raise InvalidFormat.new(""Invalid JWE Format. JWE should include #{NUM_OF_SEGMENTS} segments."") end jwe = new _header_json_, jwe.jwe_encrypted_key, jwe.iv, jwe.cipher_text, jwe.authentication_tag = input.split('.').collect do |segment| begin Base64.urlsafe_decode64 segment rescue ArgumentError raise DecryptionFailed end end jwe.auth_data = input.split('.').first jwe.header = JSON.parse(_header_json_).with_indifferent_access unless private_key_or_secret == :skip_decryption jwe.decrypt! private_key_or_secret, algorithms, encryption_methods end jwe end",True,Ruby,decode_compact_serialized,jwe.rb,https://github.com/nov/json-jwt,nov,nov,2019-11-11 23:28:48+09:00,"explicitly specifying number of elements when splitting JWE string

ref.) CVE-2019-18848",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-18848,
3156,"def decode_compact_serialized(input, public_key_or_secret, algorithms = nil, allow_blank_payload = false) unless input.count('.') + 1 == NUM_OF_SEGMENTS raise InvalidFormat.new(""Invalid JWS Format. JWS should include #{NUM_OF_SEGMENTS} segments."") end header, claims, signature = input.split('.', JWS::NUM_OF_SEGMENTS).collect do |segment| Base64.urlsafe_decode64 segment.to_s end header = JSON.parse(header).with_indifferent_access if allow_blank_payload && claims == '' claims = nil else claims = JSON.parse(claims).with_indifferent_access end jws = new claims jws.header = header jws.signature = signature jws.signature_base_string = input.split('.')[0, JWS::NUM_OF_SEGMENTS - 1].join('.') jws.verify! public_key_or_secret, algorithms unless public_key_or_secret == :skip_verification jws end",True,Ruby,decode_compact_serialized,jws.rb,https://github.com/nov/json-jwt,nov,nov,2019-11-11 23:28:48+09:00,"explicitly specifying number of elements when splitting JWE string

ref.) CVE-2019-18848",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2019-18848,
3158,"def redirect_url return ""/"" unless member_login_node member_login_node.redirect_url || ""/"" end",True,Ruby,redirect_url,login_filter.rb,https://github.com/shirasagi/shirasagi,shirasagi,GitHub,2020-07-01 13:49:01+09:00,"[fix][cms] open redirect vulnerability on member login (#3646)

* [fix] open redirect vulnerability

* [add] reproducible spec",CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",https://cwe.mitre.org/data/definitions/601.html,CVE-2020-5607,
3160,"def set_member_and_redirect(member) set_member member Member::ActivityLog.create( cur_site: @cur_site, cur_member: member, activity_type: ""login"", remote_addr: remote_addr, user_agent: request.user_agent) ref = URI::decode(params[:ref] || flash[:ref] || """") ref = redirect_url if ref.blank? flash.discard(:ref) redirect_to ref end",True,Ruby,set_member_and_redirect,login_controller.rb,https://github.com/shirasagi/shirasagi,shirasagi,GitHub,2020-07-01 13:49:01+09:00,"[fix][cms] open redirect vulnerability on member login (#3646)

* [fix] open redirect vulnerability

* [add] reproducible spec",CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",https://cwe.mitre.org/data/definitions/601.html,CVE-2020-5607,
3169,"def login_success if params[:ref].blank? redirect_to default_logged_in_path elsif params[:ref] =~ /^\// redirect_to params[:ref] else render ""sns/login/redirect"" end end",True,Ruby,login_success,login_filter.rb,https://github.com/shirasagi/shirasagi,shirasagi,GitHub,2018-04-11 17:16:18+09:00,[fix] sns/login: close open redirect (#2061),CWE-601,URL Redirection to Untrusted Site ('Open Redirect'),"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",https://cwe.mitre.org/data/definitions/601.html,CVE-2019-6009,
3170,"def update if @application.update(application_params) flash[:notice] = I18n.t(:notice, scope: i18n_scope(:update)) respond_to do |format| format.html { redirect_to oauth_application_url(@application) } format.json { render json: @application } end else respond_to do |format| format.html { render :edit } format.json do errors = @application.errors.full_messages render json: { errors: errors }, status: :unprocessable_entity end end end end",True,Ruby,update,applications_controller.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3171,def show respond_to do |format| format.html format.json { render json: @application } end end,True,Ruby,show,applications_controller.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3173,"def create @application = Doorkeeper.config.application_model.new(application_params) if @application.save flash[:notice] = I18n.t(:notice, scope: %i[doorkeeper flash applications create]) flash[:application_secret] = @application.plaintext_secret respond_to do |format| format.html { redirect_to oauth_application_url(@application) } format.json { render json: @application } end else respond_to do |format| format.html { render :new } format.json do errors = @application.errors.full_messages render json: { errors: errors }, status: :unprocessable_entity end end end end",True,Ruby,create,applications_controller.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3177,def index @applications = Doorkeeper.config.application_model.authorized_for(current_resource_owner) respond_to do |format| format.html format.json { render json: @applications } end end,True,Ruby,index,authorized_applications_controller.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3181,"def as_json(options = {}) hash = super hash[""secret""] = plaintext_secret if hash.key?(""secret"") hash end",True,Ruby,as_json,application.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3187,"it ""includes plaintext secret"" do expect(app.as_json).to include(""secret"" => ""123123123"") end",True,Ruby,"""includes plaintext secret""",application_spec.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3188,"it ""respects custom options"" do expect(app.as_json(except: :secret)).not_to include(""secret"") expect(app.as_json(only: :id)).to match(""id"" => app.id) end",True,Ruby,"""respects custom options""",application_spec.rb,https://github.com/doorkeeper-gem/doorkeeper,doorkeeper-gem,GitHub,2020-05-02 15:58:58+03:00,"Merge pull request from GHSA-j7vx-8mqj-cqp9

* Attempt at fixing information disclosure vulnerability.

* Add `#as_json` method and attrs serialization restriction for Application model

* [ci skip] Add documentation for serialization

Co-authored-by: Nikita Bulai <bulaj.nikita@gmail.com>",CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-10187,
3191,"def handle_meta(message, local, &callback) method = Channel.parse(message['channel'])[1] unless META_METHODS.include?(method) response = make_response(message) response['error'] = Faye::Error.channel_forbidden(message['channel']) response['successful'] = false return callback.call([response]) end __send__(method, message, local) do |responses| responses = [responses].flatten responses.each { |r| advize(r, message['connectionType']) } callback.call(responses) end end",True,Ruby,handle_meta,server.rb,https://github.com/faye/faye,faye,James Coglan,2020-04-27 21:54:29+01:00,"Strict meta channel recognition in server

This addresses a security vulnerability affecting user-added extensions
that implement access control for channels. These extensions typically
work by checking incoming messages whose channel is `/meta/subscribe`
and then performing some authentication routine before allowing the
message through.

However, the Server parses channels in a way that means any channel
namespaced under `/meta/subscribe` will also work as a subscription
request. For example if the client sends a message to the channel
`/meta/subscribe/x`, that will bypass most authentication extensions but
will still be interpreted by the server as a subscription request, and
the client will be subscribed to the requested channel. The client has
thus bypassed the user's access control policy.

Here we prevent this by using a strict equality check; only messages
whose channel is exactly `/meta/subscribe` will be interpreted as
subscription requests. The same pattern is applied to all other meta
channels.",CWE-287,Improper Authentication,"When an actor claims to have a given identity, the product does not prove or insufficiently proves that the claim is correct.",https://cwe.mitre.org/data/definitions/287.html,CVE-2020-11020,
3198,"def authenticate(*credentials, &block) raise ArgumentError, 'at least 2 arguments required' if credentials.size < 2 if credentials[0].blank? return authentication_response(return_value: false, failure: :invalid_login, &block) end if @sorcery_config.downcase_username_before_authenticating credentials[0].downcase! end user = sorcery_adapter.find_by_credentials(credentials) unless user return authentication_response(failure: :invalid_login, &block) end set_encryption_attributes unless user.valid_password?(credentials[1]) return authentication_response(user: user, failure: :invalid_password, &block) end if user.respond_to?(:active_for_authentication?) && !user.active_for_authentication? return authentication_response(user: user, failure: :inactive, &block) end @sorcery_config.before_authenticate.each do |callback| success, reason = user.send(callback) unless success return authentication_response(user: user, failure: reason, &block) end end authentication_response(user: user, return_value: user, &block) end",True,Ruby,authenticate,model.rb,https://github.com/Sorcery/sorcery,Sorcery,GitHub,2020-05-02 20:56:58+00:00,"Fix brute force vuln due to callbacks not being ran (#235)

The authenticate method previously would return before callbacks executed if an
invalid password was provided, which causes the brute force protection to only
work for the first lockout period, and only resets after a successful login.

Fixes #231",CWE-307,Improper Restriction of Excessive Authentication Attempts,"The product does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame, making it more susceptible to brute force attacks.",https://cwe.mitre.org/data/definitions/307.html,CVE-2020-11052,
3203,"def handle_request(client, lines, requests) env = client.env io = client.io # io may be a MiniSSL::Socket return false if closed_socket?(io) normalize_env env, client env[PUMA_SOCKET] = io if env[HTTPS_KEY] && io.peercert env[PUMA_PEERCERT] = io.peercert end env[HIJACK_P] = true env[HIJACK] = client body = client.body head = env[REQUEST_METHOD] == HEAD env[RACK_INPUT] = body env[RACK_URL_SCHEME] ||= default_server_port(env) == PORT_443 ? HTTPS : HTTP if @early_hints env[EARLY_HINTS] = lambda { |headers| begin fast_write io, str_early_hints(headers) rescue ConnectionError => e @log_writer.debug_error e # noop, if we lost the socket we just won't send the early hints end } end req_env_post_parse env # A rack extension. If the app writes #call'ables to this # array, we will invoke them when the request is done. # after_reply = env[RACK_AFTER_REPLY] = [] begin begin status, headers, res_body = @thread_pool.with_force_shutdown do @app.call(env) end return :async if client.hijacked status = status.to_i if status == -1 unless headers.empty? and res_body == [] raise ""async response must have empty headers and body"" end return :async end rescue ThreadPool::ForceShutdown => e @log_writer.unknown_error e, client, ""Rack app"" @log_writer.log ""Detected force shutdown of a thread"" status, headers, res_body = lowlevel_error(e, env, 503) rescue Exception => e @log_writer.unknown_error e, client, ""Rack app"" status, headers, res_body = lowlevel_error(e, env, 500) end res_info = {} res_info[:content_length] = nil res_info[:no_body] = head res_info[:content_length] = if res_body.kind_of? Array and res_body.size == 1 res_body[0].bytesize else nil end cork_socket io str_headers(env, status, headers, res_info, lines, requests, client) line_ending = LINE_END content_length = res_info[:content_length] if res_body && !res_body.respond_to?(:each) response_hijack = res_body else response_hijack = res_info[:response_hijack] end if res_info[:no_body] if content_length and status != 204 lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending end lines << LINE_END fast_write io, lines.to_s return res_info[:keep_alive] end if content_length lines.append CONTENT_LENGTH_S, content_length.to_s, line_ending chunked = false elsif !response_hijack and res_info[:allow_chunked] lines << TRANSFER_ENCODING_CHUNKED chunked = true end lines << line_ending fast_write io, lines.to_s if response_hijack response_hijack.call io return :async end begin res_body.each do |part| next if part.bytesize.zero? if chunked fast_write io, (part.bytesize.to_s(16) << line_ending) fast_write io, part # part may have different encoding fast_write io, line_ending else fast_write io, part end io.flush end if chunked fast_write io, CLOSE_CHUNKED io.flush end rescue SystemCallError, IOError raise ConnectionError, ""Connection error detected during write"" end ensure uncork_socket io body.close client.tempfile.unlink if client.tempfile res_body.close if res_body.respond_to? :close after_reply.each { |o| o.call } end",True,Ruby,handle_request,request.rb,https://github.com/puma/puma,puma,Nate Berkopec,2022-02-11 12:51:26-08:00,"Ensure `close` is called on the response body no matter what

Another fallout from https://github.com/puma/puma/pull/2809 is that
in some cases the `res_body.close` wasn't called because some previous code
raised.

For Rails apps it means CurrentAttributes and a few other important
states aren't reset properly.

This is being improved on the Rails side too, but I believe it would
be good to harden this on the puma side as well.",CWE-404,Improper Resource Shutdown or Release,The product does not release or incorrectly releases a resource before it is made available for re-use.,https://cwe.mitre.org/data/definitions/404.html,CVE-2022-23634,
3207,"def setup_body @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond) if @env[HTTP_EXPECT] == CONTINUE # TODO allow a hook here to check the headers before # going forward @io << HTTP_11_100 @io.flush end @read_header = false body = @parser.body te = @env[TRANSFER_ENCODING2] if te te_lwr = te.downcase if te.include? ',' te_ary = te_lwr.split ',' te_count = te_ary.count CHUNKED te_valid = te_ary[0..-2].all? { |e| ALLOWED_TRANSFER_ENCODING.include? e } if te_ary.last == CHUNKED && te_count == 1 && te_valid @env.delete TRANSFER_ENCODING2 return setup_chunked_body body elsif te_count >= 1 raise HttpParserError , ""#{TE_ERR_MSG}, multiple chunked: '#{te}'"" elsif !te_valid raise HttpParserError501, ""#{TE_ERR_MSG}, unknown value: '#{te}'"" end elsif te_lwr == CHUNKED @env.delete TRANSFER_ENCODING2 return setup_chunked_body body elsif ALLOWED_TRANSFER_ENCODING.include? te_lwr raise HttpParserError , ""#{TE_ERR_MSG}, single value must be chunked: '#{te}'"" else raise HttpParserError501 , ""#{TE_ERR_MSG}, unknown value: '#{te}'"" end end @chunked_body = false cl = @env[CONTENT_LENGTH] if cl # cannot contain characters that are not \d if CONTENT_LENGTH_VALUE_INVALID.match? cl raise HttpParserError, ""Invalid Content-Length: #{cl.inspect}"" end else @buffer = body.empty? ? nil : body @body = EmptyBody set_ready return true end remain = cl.to_i - body.bytesize if remain <= 0 @body = StringIO.new(body) @buffer = nil set_ready return true end if remain > MAX_BODY @body = Tempfile.new(Const::PUMA_TMP_BASE) @body.unlink @body.binmode @tempfile = @body else # The body[0,0] trick is to get an empty string in the same # encoding as body. @body = StringIO.new body[0,0] end @body.write body @body_remain = remain false end",True,Ruby,setup_body,client.rb,https://github.com/puma/puma,puma,GitHub,2023-08-18 09:47:23+09:00,"Merge pull request from GHSA-68xg-gqqm-vgj8

* Reject empty string for Content-Length

* Ignore trailers in last chunk

* test_puma_server.rb - use heredoc, test_cl_and_te_smuggle

* client.rb - stye/RubyCop

* test_puma_server.rb - indented heredoc rubocop disable

* Dentarg comments

* Remove unused variable

---------

Co-authored-by: MSP-Greg <Greg.mpls@gmail.com>",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-40175,
3208,"def decode_chunk(chunk) if @partial_part_left > 0 if @partial_part_left <= chunk.size if @partial_part_left > 2 write_chunk(chunk[0..(@partial_part_left-3)]) # skip the \r\n end chunk = chunk[@partial_part_left..-1] @partial_part_left = 0 else if @partial_part_left > 2 if @partial_part_left == chunk.size + 1 # Don't include the last \r write_chunk(chunk[0..(@partial_part_left-3)]) else # don't include the last \r\n write_chunk(chunk) end end @partial_part_left -= chunk.size return false end end if @prev_chunk.empty? io = StringIO.new(chunk) else io = StringIO.new(@prev_chunk+chunk) @prev_chunk = """" end while !io.eof? line = io.gets if line.end_with?(""\r\n"") # Puma doesn't process chunk extensions, but should parse if they're # present, which is the reason for the semicolon regex chunk_hex = line.strip[/\A[^;]+/] if CHUNK_SIZE_INVALID.match? chunk_hex raise HttpParserError, ""Invalid chunk size: '#{chunk_hex}'"" end len = chunk_hex.to_i(16) if len == 0 @in_last_chunk = true @body.rewind rest = io.read last_crlf_size = ""\r\n"".bytesize if rest.bytesize < last_crlf_size @buffer = nil @partial_part_left = last_crlf_size - rest.bytesize return false else @buffer = rest[last_crlf_size..-1] @buffer = nil if @buffer.empty? set_ready return true end end len += 2 part = io.read(len) unless part @partial_part_left = len next end got = part.size case when got == len # proper chunked segment must end with ""\r\n"" if part.end_with? CHUNK_VALID_ENDING write_chunk(part[0..-3]) # to skip the ending \r\n else raise HttpParserError, ""Chunk size mismatch"" end when got <= len - 2 write_chunk(part) @partial_part_left = len - part.size when got == len - 1 # edge where we get just \r but not \n write_chunk(part[0..-2]) @partial_part_left = len - part.size end else @prev_chunk = line return false end end",True,Ruby,decode_chunk,client.rb,https://github.com/puma/puma,puma,GitHub,2023-08-18 09:47:23+09:00,"Merge pull request from GHSA-68xg-gqqm-vgj8

* Reject empty string for Content-Length

* Ignore trailers in last chunk

* test_puma_server.rb - use heredoc, test_cl_and_te_smuggle

* client.rb - stye/RubyCop

* test_puma_server.rb - indented heredoc rubocop disable

* Dentarg comments

* Remove unused variable

---------

Co-authored-by: MSP-Greg <Greg.mpls@gmail.com>",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-40175,
3212,"def test_large_chunked_request body = nil content_length = nil server_run { |env| body = env['rack.input'].read content_length = env['CONTENT_LENGTH'] [200, {}, [""""]] } header = ""GET / HTTP/1.1\r\nConnection: close\r\nTransfer-Encoding: chunked\r\n\r\n"" chunk_header_size = 6 # 4fb8\r\n # Current implementation reads one chunk of CHUNK_SIZE, then more chunks of size 4096. # We want a chunk to split exactly after ""#{request_body}\r"", before the ""\n"". edge_case_size = Puma::Const::CHUNK_SIZE + 4096 - header.size - chunk_header_size - 1 margin = 0 # 0 for only testing this specific case, increase to test more surrounding sizes (-margin..margin).each do |i| size = edge_case_size + i request_body = '.' * size request = ""#{header}#{size.to_s(16)}\r\n#{request_body}\r\n0\r\n\r\n"" data = send_http_and_read request assert_equal ""HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: 0\r\n\r\n"", data assert_equal size, Integer(content_length) assert_equal request_body, body end end",True,Ruby,test_large_chunked_request,test_puma_server.rb,https://github.com/puma/puma,puma,GitHub,2023-08-18 09:47:23+09:00,"Merge pull request from GHSA-68xg-gqqm-vgj8

* Reject empty string for Content-Length

* Ignore trailers in last chunk

* test_puma_server.rb - use heredoc, test_cl_and_te_smuggle

* client.rb - stye/RubyCop

* test_puma_server.rb - indented heredoc rubocop disable

* Dentarg comments

* Remove unused variable

---------

Co-authored-by: MSP-Greg <Greg.mpls@gmail.com>",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-40175,
3215,"def handle_request(req, lines) @requests_count +=1 env = req.env client = req.io return false if closed_socket?(client) normalize_env env, req env[PUMA_SOCKET] = client if env[HTTPS_KEY] && client.peercert env[PUMA_PEERCERT] = client.peercert end env[HIJACK_P] = true env[HIJACK] = req body = req.body head = env[REQUEST_METHOD] == HEAD env[RACK_INPUT] = body env[RACK_URL_SCHEME] = default_server_port(env) == PORT_443 ? HTTPS : HTTP if @early_hints env[EARLY_HINTS] = lambda { |headers| begin fast_write client, ""HTTP/1.1 103 Early Hints\r\n"".freeze headers.each_pair do |k, vs| if vs.respond_to?(:to_s) && !vs.to_s.empty? vs.to_s.split(NEWLINE).each do |v| fast_write client, ""#{k}: #{v}\r\n"" end else fast_write client, ""#{k}: #{vs}\r\n"" end end fast_write client, ""\r\n"".freeze rescue ConnectionError # noop, if we lost the socket we just won't send the early hints end } end # A rack extension. If the app writes #call'ables to this # array, we will invoke them when the request is done. # after_reply = env[RACK_AFTER_REPLY] = [] begin begin status, headers, res_body = @app.call(env) return :async if req.hijacked # Checking to see if an attacker is trying to inject headers into the response headers.reject! { |_k, v| CRLF_REGEX =~ v.to_s } status = status.to_i if status == -1 unless headers.empty? and res_body == [] raise ""async response must have empty headers and body"" end return :async end rescue ThreadPool::ForceShutdown => e @events.log ""Detected force shutdown of a thread, returning 503"" @events.unknown_error self, e, ""Rack app"" status = 503 headers = {} res_body = [""Request was internally terminated early\n""] rescue Exception => e @events.unknown_error self, e, ""Rack app"", env status, headers, res_body = lowlevel_error(e, env) end content_length = nil no_body = head if res_body.kind_of? Array and res_body.size == 1 content_length = res_body[0].bytesize end cork_socket client line_ending = LINE_END colon = COLON http_11 = if env[HTTP_VERSION] == HTTP_11 allow_chunked = true keep_alive = env.fetch(HTTP_CONNECTION, """").downcase != CLOSE include_keepalive_header = false # An optimization. The most common response is 200, so we can # reply with the proper 200 status without having to compute # the response header. # if status == 200 lines << HTTP_11_200 else lines.append ""HTTP/1.1 "", status.to_s, "" "", fetch_status_code(status), line_ending no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status] end true else allow_chunked = false keep_alive = env.fetch(HTTP_CONNECTION, """").downcase == KEEP_ALIVE include_keepalive_header = keep_alive # Same optimization as above for HTTP/1.1 # if status == 200 lines << HTTP_10_200 else lines.append ""HTTP/1.0 "", status.to_s, "" "", fetch_status_code(status), line_ending no_body ||= status < 200 || STATUS_WITH_NO_ENTITY_BODY[status] end false end response_hijack = nil headers.each do |k, vs| case k.downcase when CONTENT_LENGTH2 content_length = vs next when TRANSFER_ENCODING allow_chunked = false content_length = nil when HIJACK response_hijack = vs next end if vs.respond_to?(:to_s) && !vs.to_s.empty? vs.to_s.split(NEWLINE).each do |v| lines.append k, colon, v, line_ending end else lines.append k, colon, line_ending end end",True,Ruby,handle_request,server.rb,https://github.com/puma/puma,puma,GitHub,2020-02-28 12:53:29-06:00,"HTTP Injection - fix bug + 1 more vector (#2136)

+ Fixes a problem in 4.3.2/3.12.3 where we were not splitting newlines in headers according to Rack spec
+ Fixes another vector for HTTP injection - early hints",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2020-5249,
3222,"def email_verify_send raise Exceptions::UnprocessableEntity, 'No email!' if !params[:email] user = User.find_by(email: params[:email].downcase) if !user # result is always positive to avoid leaking of existing user accounts render json: { message: 'ok' }, status: :ok return end #if user.verified == true # render json: { error: 'Already verified!' }, status: :unprocessable_entity # return #end Token.create(action: 'Signup', user_id: user.id) result = User.signup_new_token(user) if result && result[:token] user = result[:user] NotificationFactory::Mailer.notification( template: 'signup', user: user, objects: result ) # only if system is in develop mode, send token back to browser for browser tests if Setting.get('developer_mode') == true render json: { message: 'ok', token: result[:token].name }, status: :ok return end # token sent to user, send ok to browser render json: { message: 'ok' }, status: :ok return end # unable to generate token render json: { message: 'failed' }, status: :ok end",True,Ruby,email_verify_send,users_controller.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-06-10 13:39:53+02:00,Fixes issue #2907 - Password strength settings are ignored when creating new customer accounts. Make login available to verified users only.,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2020-14214,
3223,"def password_policy(password) if Setting.get('password_min_size').to_i > password.length return [""Can\'t update password, it must be at least %s characters long!"", Setting.get('password_min_size')] end if Setting.get('password_need_digit').to_i == 1 && password !~ /\d/ return [""Can't update password, it must contain at least 1 digit!""] end if Setting.get('password_min_2_lower_2_upper_characters').to_i == 1 && ( password !~ /[A-Z].*[A-Z]/ || password !~ /[a-z].*[a-z]/ ) return [""Can't update password, it must contain at least 2 lowercase and 2 uppercase characters!""] end true end",True,Ruby,password_policy,users_controller.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-06-10 13:39:53+02:00,Fixes issue #2907 - Password strength settings are ignored when creating new customer accounts. Make login available to verified users only.,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2020-14214,
3229,"def self.password_reset_via_token(token, password) # check token user = by_reset_token(token) return if !user # reset password user.update!(password: password) # delete token Token.find_by(action: 'PasswordReset', name: token).destroy user end",True,Ruby,self.password_reset_via_token,user.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-06-10 13:39:53+02:00,Fixes issue #2907 - Password strength settings are ignored when creating new customer accounts. Make login available to verified users only.,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2020-14214,
3230,"def valid?(user, password) return false if user.blank? if PasswordHash.legacy?(user.password, password) update_password(user, password) return true end PasswordHash.verified?(user.password, password) end",True,Ruby,valid?,internal.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-06-10 13:39:53+02:00,Fixes issue #2907 - Password strength settings are ignored when creating new customer accounts. Make login available to verified users only.,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2020-14214,
3237,"def check_default_at_signup_permissions all_permissions = Permission.all.pluck(:id) admin_permissions = Permission.where('name LIKE ? OR name = ?', 'admin%', 'ticket.agent').pluck(:id) # admin.*/ticket.agent permissions normal_permissions = (all_permissions - admin_permissions) | (admin_permissions - all_permissions) # all other permissions besides admin.*/ticket.agent return true if default_at_signup != true # means if default_at_signup = false, no need further checks return true if self.permission_ids.all? { |i| normal_permissions.include? i } # allow user to choose only normal permissions raise Exceptions::UnprocessableEntity, 'Cannot set default at signup when role has admin or ticket.agent permissions.' end",True,Ruby,check_default_at_signup_permissions,role.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:51+01:00,Maintenance: Provide allow_signup column to define the signup permissions for roles and disable new permissions by default as signup permission.,NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2020-29159,
3246,"def update article = Ticket::Article.find(params[:id]) authorize!(article) clean_params = Ticket::Article.association_name_to_id_convert(params) clean_params = Ticket::Article.param_cleanup(clean_params, true) # only apply preferences changes (keep not updated keys/values) clean_params = article.param_preferences_merge(clean_params) article.update!(clean_params) if response_expand? result = article.attributes_with_association_names render json: result, status: :ok return end if response_full? full = Ticket::Article.full(params[:id]) render json: full, status: :ok return end render json: article.attributes_with_association_names, status: :ok end",True,Ruby,update,ticket_articles_controller.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:52+01:00,Maintenance: Sync Article REST API capabilities with the ones of the frontend.,CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-29160,
3248,"it 'does ticket create with agent and articles' do params = { title: 'a new ticket #1', group: 'Users', customer_id: customer.id, article: { body: 'some body', } } authenticated_as(agent) post '/api/v1/tickets', params: params, as: :json expect(response).to have_http_status(:created) params = { ticket_id: json_response['id'], content_type: 'text/plain', # or text/html body: 'some body', type: 'note', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) ticket = Ticket.find(json_response['ticket_id']) expect(ticket.articles.count).to eq(2) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) params = { ticket_id: json_response['ticket_id'], content_type: 'text/html', # or text/html body: 'some body <img src=""data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO 9TXL0Y4OHwAAAABJRU5ErkJggg=="" alt=""Red dot"" />', type: 'note', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).not_to match(/some body <img src=""cid:.+?/) expect(json_response['body']).to match(%r{some body <img src=""/api/v1/ticket_attachment/.+?"" alt=""Red dot""}) expect(json_response['content_type']).to eq('text/html') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(ticket.articles.count).to eq(3) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) expect(ticket.articles[2].attachments.count).to eq(1) expect(ticket.articles[2].attachments[0]['id']).to be_truthy expect(ticket.articles[2].attachments[0]['filename']).to eq('image1.png') expect(ticket.articles[2].attachments[0]['size']).to eq('21') expect(ticket.articles[2].attachments[0]['preferences']['Mime-Type']).to eq('image/png') expect(ticket.articles[2].attachments[0]['preferences']['Content-Disposition']).to eq('inline') expect(ticket.articles[2].attachments[0]['preferences']['Content-ID']).to match(/@zammad.example.com/) params = { ticket_id: json_response['ticket_id'], content_type: 'text/html', # or text/html body: 'some body', type: 'note', attachments: [ { 'filename' => 'some_file.txt', 'data' => 'dGVzdCAxMjM=', 'mime-type' => 'text/plain' }, ], } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/html') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(ticket.articles.count).to eq(4) expect(ticket.articles[0].attachments.count).to eq(0) expect(ticket.articles[1].attachments.count).to eq(0) expect(ticket.articles[2].attachments.count).to eq(1) expect(ticket.articles[3].attachments.count).to eq(1) get ""/api/v1/ticket_articles/#{json_response['id']}?expand=true"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['attachments'].count).to eq(1) expect(json_response['attachments'][0]['id']).to be_truthy expect(json_response['attachments'][0]['filename']).to eq('some_file.txt') expect(json_response['attachments'][0]['size']).to eq('8') expect(json_response['attachments'][0]['preferences']['Mime-Type']).to eq('text/plain') params = { ticket_id: json_response['ticket_id'], content_type: 'text/plain', body: 'some body', type: 'note', preferences: { some_key1: 123, }, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['preferences']['some_key1']).to eq(123) expect(ticket.articles.count).to eq(5) params = { body: 'some body 2', preferences: { some_key2: 'abc', }, } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['subject']).to be_nil expect(json_response['body']).to eq('some body 2') expect(json_response['content_type']).to eq('text/plain') expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['preferences']['some_key1']).to eq(123) expect(json_response['preferences']['some_key2']).to eq('abc') end",True,Ruby,'does ticket create with agent and articles',article_spec.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:52+01:00,Maintenance: Sync Article REST API capabilities with the ones of the frontend.,CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-29160,
3251,"it 'does ticket with correct ticket id (02.05)' do ticket = create( :ticket, title: 'ticket with corret ticket id', group: ticket_group, customer_id: customer.id, ) authenticated_as(admin) get ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq('ticket with corret ticket id') expect(json_response['customer_id']).to eq(ticket.customer_id) expect(json_response['updated_by_id']).to eq(1) expect(json_response['created_by_id']).to eq(1) params = { title: 'ticket with corret ticket id - 2', customer_id: agent.id, } put ""/api/v1/tickets/#{ticket.id}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq('ticket with corret ticket id - 2') expect(json_response['customer_id']).to eq(agent.id) expect(json_response['updated_by_id']).to eq(admin.id) expect(json_response['created_by_id']).to eq(1) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq('Tickets Admin') expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(false) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) params = { subject: 'new subject', internal: true, } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq('Tickets Admin') expect(json_response['subject']).to eq('new subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:ok) params = { ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Admin via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(false) expect(json_response['created_by_id']).to eq(admin.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) delete ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) end",True,Ruby,'does ticket with correct ticket id (02.05)',ticket_spec.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:52+01:00,Maintenance: Sync Article REST API capabilities with the ones of the frontend.,CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-29160,
3252,"it 'does ticket with correct ticket id (02.04)' do title = ""ticket with corret ticket id testagent#{rand(999_999_999)}"" ticket = create( :ticket, title: title, group: ticket_group, customer_id: customer.id, preferences: { some_key1: 123, }, ) authenticated_as(agent) get ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq(title) expect(json_response['customer_id']).to eq(ticket.customer_id) expect(json_response['updated_by_id']).to eq(1) expect(json_response['created_by_id']).to eq(1) expect(json_response['preferences']['some_key1']).to eq(123) params = { title: ""#{title} - 2"", customer_id: agent.id, preferences: { some_key2: 'abc', }, } put ""/api/v1/tickets/#{ticket.id}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['id']).to eq(ticket.id) expect(json_response['title']).to eq(""#{title} - 2"") expect(json_response['customer_id']).to eq(agent.id) expect(json_response['updated_by_id']).to eq(agent.id) expect(json_response['created_by_id']).to eq(1) expect(json_response['preferences']['some_key1']).to eq(123) expect(json_response['preferences']['some_key2']).to eq('abc') params = { ticket_id: ticket.id, subject: 'some subject', body: 'some body', } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) article_json_response = json_response expect(article_json_response).to be_a_kind_of(Hash) expect(article_json_response['ticket_id']).to eq(ticket.id) expect(article_json_response['from']).to eq('Tickets Agent') expect(article_json_response['subject']).to eq('some subject') expect(article_json_response['body']).to eq('some body') expect(article_json_response['content_type']).to eq('text/plain') expect(article_json_response['internal']).to eq(false) expect(article_json_response['created_by_id']).to eq(agent.id) expect(article_json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(article_json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'note').id) Scheduler.worker(true) get ""/api/v1/tickets/search?query=#{CGI.escape(title)}"", params: {}, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['tickets'][0]).to eq(ticket.id) expect(json_response['tickets_count']).to eq(1) params = { condition: { 'ticket.title' => { operator: 'contains', value: title, }, }, } post '/api/v1/tickets/search', params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['tickets'][0]).to eq(ticket.id) expect(json_response['tickets_count']).to eq(1) delete ""/api/v1/ticket_articles/#{article_json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:ok) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', internal: true, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Agent via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).to eq('some subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) params = { subject: 'new subject', } put ""/api/v1/ticket_articles/#{json_response['id']}"", params: params, as: :json expect(response).to have_http_status(:ok) expect(json_response).to be_a_kind_of(Hash) expect(json_response['ticket_id']).to eq(ticket.id) expect(json_response['from']).to eq(%(""Tickets Agent via #{ticket_group.email_address.realname}"" <#{ticket_group.email_address.email}>)) expect(json_response['subject']).to eq('new subject') expect(json_response['body']).to eq('some body') expect(json_response['content_type']).to eq('text/plain') expect(json_response['internal']).to eq(true) expect(json_response['created_by_id']).to eq(agent.id) expect(json_response['sender_id']).to eq(Ticket::Article::Sender.lookup(name: 'Agent').id) expect(json_response['type_id']).to eq(Ticket::Article::Type.lookup(name: 'email').id) params = { from: 'something which should not be changed on server side', ticket_id: ticket.id, subject: 'some subject', body: 'some body', type: 'email', internal: false, } post '/api/v1/ticket_articles', params: params, as: :json expect(response).to have_http_status(:created) expect(json_response['internal']).to eq(false) delete ""/api/v1/ticket_articles/#{json_response['id']}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) expect(json_response).to be_a_kind_of(Hash) expect(json_response['error']).to eq('Not authorized (communication articles cannot be deleted)!') delete ""/api/v1/tickets/#{ticket.id}"", params: {}, as: :json expect(response).to have_http_status(:unauthorized) expect(json_response).to be_a_kind_of(Hash) expect(json_response['error']).to eq('Not authorized (admin permission required)!') end",True,Ruby,'does ticket with correct ticket id (02.04)',ticket_spec.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:52+01:00,Maintenance: Sync Article REST API capabilities with the ones of the frontend.,CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-29160,
3254,"def access?(query) return false if record.internal == true && !user.permissions?('ticket.agent') ticket = Ticket.lookup(id: record.ticket_id) Pundit.authorize(user, ticket, query) end",True,Ruby,access?,article_policy.rb,https://github.com/zammad/zammad,zammad,Thorsten Eckel,2020-11-16 09:08:52+01:00,Maintenance: Improved article view for agent customer.,CWE-862,Missing Authorization,The product does not perform an authorization check when an actor attempts to access a resource or perform an action.,https://cwe.mitre.org/data/definitions/862.html,CVE-2020-29158,
3257,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif signature != generate_signature(string) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end",True,Ruby,verify_signature,derivation_endpoint.rb,https://github.com/shrinerb/shrine,shrinerb,Janko Marohnić,2020-10-04 18:26:39+02:00,"Securely compare signature in derivation_endpoint

Using regular string comparison when comparing signature has different
performance depending on how much of the string matched, which can make
derivation_endpoint susceptible to timing attacks. We avoid that by
using `Rack::Utils.secure_compare` instead.

Big thanks to @esparta for reporting this.",CWE-203,Observable Discrepancy,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.",https://cwe.mitre.org/data/definitions/203.html,CVE-2020-15237,
3258,"def verify_signature(string, signature) if signature.nil? fail InvalidSignature, ""missing \""signature\"" param"" elsif signature != generate_signature(string) fail InvalidSignature, ""provided signature does not match the calculated signature"" end end",True,Ruby,verify_signature,derivation_endpoint.rb,https://github.com/shrinerb/shrine,shrinerb,Janko Marohnić,2020-10-04 18:26:39+02:00,"Securely compare signature in derivation_endpoint

Using regular string comparison when comparing signature has different
performance depending on how much of the string matched, which can make
derivation_endpoint susceptible to timing attacks. We avoid that by
using `Rack::Utils.secure_compare` instead.

Big thanks to @esparta for reporting this.",CWE-208,Observable Timing Discrepancy,"Two separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.",https://cwe.mitre.org/data/definitions/208.html,CVE-2020-15237,
3262,"def rs256_decode_key(kid) jwks_x5c = jwks_key(:x5c, kid) if jwks_x5c.nil? raise OmniAuth::Auth0::TokenValidationError.new(""Could not find a public key for Key ID (kid) '#{kid}''"") end jwks_public_cert(jwks_x5c.first) end",True,Ruby,rs256_decode_key,jwt_validator.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3263,"def verify_signature(jwt) head = token_head(jwt) # Make sure the algorithm is supported and get the decode key. if head[:alg] == 'RS256' [rs256_decode_key(head[:kid]), head[:alg]] elsif head[:alg] == 'HS256' [@client_secret, head[:alg]] else raise OmniAuth::Auth0::TokenValidationError.new(""Signature algorithm of #{head[:alg]} is not supported. Expected the ID token to be signed with RS256 or HS256"") end end",True,Ruby,verify_signature,jwt_validator.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3270,"it 'should return nil if the key ID is invalid' do expect(jwt_validator.jwks_key(:alg, ""#{jwks_kid}_invalid"")).to eq(nil) end",True,Ruby,'should return nil if the key ID is invalid',jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3271,"def make_hs256_token(payload = nil) payload = { sub: 'abc123' } if payload.nil? JWT.encode payload, client_secret, 'HS256' end",True,Ruby,make_hs256_token,jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3273,"def stub_jwks stub_request(:get, 'https://samples.auth0.com/.well-known/jwks.json') .to_return( headers: { 'Content-Type' => 'application/json' }, body: jwks.to_json, status: 200 ) end",True,Ruby,stub_jwks,jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3276,"it 'should return a key' do expect(jwt_validator.jwks_key(:alg, jwks_kid)).to eq('RS256') end",True,Ruby,'should return a key',jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3279,"def stub_bad_jwks stub_request(:get, 'https://samples.auth0.com/.well-known/jwks-bad.json') .to_return( status: 404 ) end",True,Ruby,stub_bad_jwks,jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3281,"def make_rs256_token(payload = nil) payload = { sub: 'abc123' } if payload.nil? JWT.encode payload, rsa_private_key, 'RS256', kid: jwks_kid end",True,Ruby,make_rs256_token,jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3285,"def stub_dummy_jwks stub_request(:get, 'https://example.org/.well-known/jwks.json') .to_return( headers: { 'Content-Type' => 'application/json' }, body: rsa_token_jwks, status: 200 ) end",True,Ruby,stub_dummy_jwks,jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3287,"it 'should return an x5c key' do expect(jwt_validator.jwks_key(:x5c, jwks_kid).length).to eq(1) end",True,Ruby,'should return an x5c key',jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3289,"it 'should verify a standard RS256 token' do domain = 'example.org' sub = 'abc123' payload = { sub: sub, exp: future_timecode, iss: ""https://#{domain}/"", iat: past_timecode, aud: client_id, kid: jwks_kid } token = make_rs256_token(payload) verified_token = make_jwt_validator(opt_domain: domain).verify(token) expect(verified_token['sub']).to eq(sub) end",True,Ruby,'should verify a standard RS256 token',jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3295,"it 'should return nil if there is not key' do expect(jwt_validator.jwks_key(:auth0, jwks_kid)).to eq(nil) end",True,Ruby,'should return nil if there is not key',jwt_validator_spec.rb,https://github.com/auth0/omniauth-auth0,auth0,James Anderson,2020-10-08 15:12:47-05:00,Verify the JWT signature,CWE-347,Improper Verification of Cryptographic Signature,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",https://cwe.mitre.org/data/definitions/347.html,CVE-2020-15240,
3298,def spree_current_user @spree_current_user ||= Spree.user_class.find_by(id: doorkeeper_token.resource_owner_id) if doorkeeper_token end,True,Ruby,spree_current_user,base_controller.rb,https://github.com/spree/spree,spree,Damian Legawiec,2020-10-14 12:13:37+02:00,ensure doorkeeper_token is valid when authenticating requests in v2,CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2020-15269,
3299,"def read_body(socket, block) return unless socket if tc = self['transfer-encoding'] case tc when /chunked/io then read_chunked(socket, block) else raise HTTPStatus::NotImplemented, ""Transfer-Encoding: #{tc}."" end elsif self['content-length'] || @remaining_size @remaining_size ||= self['content-length'].to_i while @remaining_size > 0 sz = [@buffer_size, @remaining_size].min break unless buf = read_data(socket, sz) @remaining_size -= buf.bytesize block.call(buf) end if @remaining_size > 0 && @socket.eof? raise HTTPStatus::BadRequest, ""invalid body size."" end elsif BODY_CONTAINABLE_METHODS.member?(@request_method) && !@socket.eof raise HTTPStatus::LengthRequired end",True,Ruby,read_body,httprequest.rb,https://github.com/ruby/webrick,ruby,Yusuke Endoh,2020-09-29 13:15:58+09:00,"Make it more strict to interpret some headers

Some regexps were too tolerant.",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2020-25613,
3301,"def parse(socket=nil) @socket = socket begin @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : [] @addr = socket.respond_to?(:addr) ? socket.addr : [] rescue Errno::ENOTCONN raise HTTPStatus::EOFError end read_request_line(socket) if @http_version.major > 0 read_header(socket) @header['cookie'].each{|cookie| @cookies += Cookie::parse(cookie) } @accept = HTTPUtils.parse_qvalues(self['accept']) @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset']) @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding']) @accept_language = HTTPUtils.parse_qvalues(self['accept-language']) end return if @request_method == ""CONNECT"" return if @unparsed_uri == ""*"" begin setup_forwarded_info @request_uri = parse_uri(@unparsed_uri) @path = HTTPUtils::unescape(@request_uri.path) @path = HTTPUtils::normalize_path(@path) @host = @request_uri.host @port = @request_uri.port @query_string = @request_uri.query @script_name = """" @path_info = @path.dup rescue raise HTTPStatus::BadRequest, ""bad URI `#{@unparsed_uri}'."" end if /close/io =~ self[""connection""] @keep_alive = false elsif /keep-alive/io =~ self[""connection""] @keep_alive = true elsif @http_version < ""1.1"" @keep_alive = false else @keep_alive = true end end",True,Ruby,parse,httprequest.rb,https://github.com/ruby/webrick,ruby,Yusuke Endoh,2020-09-29 13:15:58+09:00,"Make it more strict to interpret some headers

Some regexps were too tolerant.",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2020-25613,
3303,"def self.dump(object) MultiJson.dump object, mode: :compat, escape_mode: :xss_safe, time_format: :ruby end",True,Ruby,self.dump,json_dumper.rb,https://github.com/gazay/gon,gazay,Alex Gaziev,2020-09-18 10:00:12-07:00,"CVE-2020-25739: Enforce HTML entities escaping in gon output

Version 6.4.0",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2020-25739,
3307,def RelaxNG string_or_io RelaxNG.new(string_or_io) end,True,Ruby,RelaxNG,relax_ng.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2020-12-03 14:08:11-05:00,"feat: XML::Schema and RelaxNG creation accept optional ParseOptions

I'm trying out a new pattern, which is that the parsed object carries
around the ParseOptions it was created with, which should make some
testing a bit easier.

I'm also not implementing the ""config block"" pattern in use for
Documents, because I think the UX is weird and I'm hoping to change
everything to use kwargs in a 2.0 release, anyway.",CWE-611,Improper Restriction of XML External Entity Reference,"The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",https://cwe.mitre.org/data/definitions/611.html,CVE-2020-26247,
3310,def Schema string_or_io Schema.new(string_or_io) end,True,Ruby,Schema,schema.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2020-12-03 14:08:11-05:00,"feat: XML::Schema and RelaxNG creation accept optional ParseOptions

I'm trying out a new pattern, which is that the parsed object carries
around the ParseOptions it was created with, which should make some
testing a bit easier.

I'm also not implementing the ""config block"" pattern in use for
Documents, because I think the UX is weird and I'm hoping to change
everything to use kwargs in a 2.0 release, anyway.",CWE-611,Improper Restriction of XML External Entity Reference,"The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",https://cwe.mitre.org/data/definitions/611.html,CVE-2020-26247,
3311,def self.new string_or_io from_document Nokogiri::XML(string_or_io) end,True,Ruby,self.new,schema.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2020-12-03 14:08:11-05:00,"feat: XML::Schema and RelaxNG creation accept optional ParseOptions

I'm trying out a new pattern, which is that the parsed object carries
around the ParseOptions it was created with, which should make some
testing a bit easier.

I'm also not implementing the ""config block"" pattern in use for
Documents, because I think the UX is weird and I'm hoping to change
everything to use kwargs in a 2.0 release, anyway.",CWE-611,Improper Restriction of XML External Entity Reference,"The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",https://cwe.mitre.org/data/definitions/611.html,CVE-2020-26247,
3321,"def parse_memory(data, encoding = ""UTF-8"") raise ArgumentError unless data return if data.empty? ctx = ParserContext.memory(data, encoding) yield ctx if block_given? ctx.parse_with(self) end",True,Ruby,parse_memory,parser.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2022-05-06 21:59:33-04:00,"fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types

Previously, arguments of the wrong type might cause segfault on CRuby.",CWE-241,Improper Handling of Unexpected Data Type,"The product does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).",https://cwe.mitre.org/data/definitions/241.html,CVE-2022-29181,
3324,def test_parse_memory_nil assert_raises(ArgumentError) do @parser.parse_memory(nil) end end,True,Ruby,test_parse_memory_nil,test_parser.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2022-05-06 21:59:33-04:00,"fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types

Previously, arguments of the wrong type might cause segfault on CRuby.",CWE-241,Improper Handling of Unexpected Data Type,"The product does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).",https://cwe.mitre.org/data/definitions/241.html,CVE-2022-29181,
3327,it :test_render_parse_nil_param do assert_raises(ArgumentError) { parser.parse_memory(nil) } end,True,Ruby,:test_render_parse_nil_param,test_parser.rb,https://github.com/sparklemotion/nokogiri,sparklemotion,Mike Dalessio,2022-05-06 21:59:33-04:00,"fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types

Previously, arguments of the wrong type might cause segfault on CRuby.",CWE-241,Improper Handling of Unexpected Data Type,"The product does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).",https://cwe.mitre.org/data/definitions/241.html,CVE-2022-29181,
3330,def email user_info['email'] || id_info['email'] end,True,Ruby,email,apple.rb,https://github.com/nhosoya/omniauth-apple,nhosoya,nhosoya,2020-12-02 19:45:12+09:00,"Use only verified email address to prevent fake email address

Co-authored-by: David Taylor <david@taylorhq.com>",CWE-290,Authentication Bypass by Spoofing,This attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks.,https://cwe.mitre.org/data/definitions/290.html,CVE-2020-26254,
3335,"def link(link, title, content) attributes = [ (""href=\""#{link}\"""" if link), (""title=\""#{title}\"""" if title), (""target=\""_blank\"""" if link =~ PROTOCOL_MATCHER), ] ""<a #{attributes.compact.join("" "")}>#{content}</a>"" end",True,Ruby,link,translation.rb,https://github.com/ahorner/text-helpers,ahorner,GitHub,2020-12-09 06:52:01-07:00,"Protect against reverse tabnabbing (#19)

* Protect against reverse tabnabbing

https://owasp.org/www-community/attacks/Reverse_Tabnabbing

* Use faster regular expression method",CWE-1022,Use of Web Link to Untrusted Target with window.opener Access,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.",https://cwe.mitre.org/data/definitions/1022.html,CVE-2020-36624,
3338,"def text(key, options = {}) options = html_safe_options(options) text = I18n.t(key, **{ scope: self.translation_scope, default: ""!#{key}!"", cascade: true, }.merge(options)).strip interpolation_options = { cascade: true }.merge(options) # Interpolate any keypaths (e.g., `!some.lookup.path/key!`) found in the text. while text =~ KEYPATH_MATCHER do text = text.gsub(KEYPATH_MATCHER) { |match| I18n.t($1, **interpolation_options) } end text = smartify(text) if options.fetch(:smart, true) text.html_safe end",True,Ruby,text,translation.rb,https://github.com/ahorner/text-helpers,ahorner,GitHub,2020-12-09 06:52:01-07:00,"Protect against reverse tabnabbing (#19)

* Protect against reverse tabnabbing

https://owasp.org/www-community/attacks/Reverse_Tabnabbing

* Use faster regular expression method",CWE-1022,Use of Web Link to Untrusted Target with window.opener Access,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.",https://cwe.mitre.org/data/definitions/1022.html,CVE-2020-36624,
3339,"it ""renders external links with target='_blank'"" do assert_equal ""<a href=\""http://external.com\"" target=\""_blank\"">External&nbsp;link</a>\n"", @helper.html(:external_link, inline: true) end",True,Ruby,"""renders external links with target='_blank'""",translation_test.rb,https://github.com/ahorner/text-helpers,ahorner,GitHub,2020-12-09 06:52:01-07:00,"Protect against reverse tabnabbing (#19)

* Protect against reverse tabnabbing

https://owasp.org/www-community/attacks/Reverse_Tabnabbing

* Use faster regular expression method",CWE-1022,Use of Web Link to Untrusted Target with window.opener Access,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.",https://cwe.mitre.org/data/definitions/1022.html,CVE-2020-36624,
3342,"it ""renders internal links without a target"" do assert_equal ""<a href=\""/internal/path\"">Internal&nbsp;link</a>\n"", @helper.html(:internal_link, inline: true) end",True,Ruby,"""renders internal links without a target""",translation_test.rb,https://github.com/ahorner/text-helpers,ahorner,GitHub,2020-12-09 06:52:01-07:00,"Protect against reverse tabnabbing (#19)

* Protect against reverse tabnabbing

https://owasp.org/www-community/attacks/Reverse_Tabnabbing

* Use faster regular expression method",CWE-1022,Use of Web Link to Untrusted Target with window.opener Access,"The web application produces links to untrusted external sites outside of its sphere of control, but it does not properly prevent the external site from modifying  security-critical properties of the window.opener object, such as the location property.",https://cwe.mitre.org/data/definitions/1022.html,CVE-2020-36624,
3343,"def placeholder(filename) css_class = InlineSvg.configuration.svg_not_found_css_class not_found_message = ""'#{filename}' #{extension_hint(filename)}"" if css_class.nil? return ""<svg><!-- SVG file not found: #{not_found_message}--></svg>"".html_safe else return ""<svg class='#{css_class}'><!-- SVG file not found: #{not_found_message}--></svg>"".html_safe end end",True,Ruby,placeholder,helpers.rb,https://github.com/jamesmartin/inline_svg,jamesmartin,Patrick Byrne,2020-03-03 10:44:06-06:00,"Escape filename to avoid XSS from malicious input

Because:

* If user input is provided for the file name (as in rendering an SVG
  based on a URL parameter), the blanket marking of the SVG output as
  HTML-safe exposes an app to an XSS attack in the comment listing the
  file that was not found.

Solution:

* HTML-escape the filename rendering the comment that it was not found.",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2020-36644,
3346,def opposite_direction direction.to_sym == :asc ? :desc : :asc end,True,Ruby,opposite_direction,order.rb,https://github.com/thoughtbot/administrate,thoughtbot,GitHub,2020-03-13 12:15:54+00:00,"Merge pull request from GHSA-2p5p-m353-833w

Previously, order parameters were passed directly through to the query.
This meant that passing in `foo` via a URL string would try and sort by
`foo`.",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2020-5257,
3349,"def initialize(attribute = nil, direction = nil) @attribute = attribute @direction = direction || :asc end",True,Ruby,initialize,order.rb,https://github.com/thoughtbot/administrate,thoughtbot,GitHub,2020-03-13 12:15:54+00:00,"Merge pull request from GHSA-2p5p-m353-833w

Previously, order parameters were passed directly through to the query.
This meant that passing in `foo` via a URL string would try and sort by
`foo`.",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2020-5257,
3353,"def test_post uri = URI('http://localhost:6470/makeme') req = Net::HTTP::Post.new(uri) # Set the headers the way we want them. req['Accept-Encoding'] = '*' req['Accept'] = 'application/json' req['User-Agent'] = 'Ruby' res = Net::HTTP.start(uri.hostname, uri.port) { |h| h.request(req) } assert_equal(Net::HTTPNoContent, res.class) end",True,Ruby,test_post,base_handler_test.rb,https://github.com/ohler55/agoo,ohler55,GitHub,2020-11-07 19:07:47-05:00,"Remote addr (#99)

* REMOTE_ADDR added

* Ready for merge",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2020-7670,
3354,"def test_put uri = URI('http://localhost:6470/makeme') req = Net::HTTP::Put.new(uri) # Set the headers the way we want them. req['Accept-Encoding'] = '*' req['Accept'] = 'application/json' req['User-Agent'] = 'Ruby' req.body = 'hello' res = Net::HTTP.start(uri.hostname, uri.port) { |h| h.request(req) } assert_equal(Net::HTTPCreated, res.class) assert_equal('hello', res.body) end",True,Ruby,test_put,base_handler_test.rb,https://github.com/ohler55/agoo,ohler55,GitHub,2020-11-07 19:07:47-05:00,"Remote addr (#99)

* REMOTE_ADDR added

* Ready for merge",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2020-7670,
3361,detectExtension(mimeType) { if (!mimeType) { return defaultExtension; } let parts = (mimeType || '') .toLowerCase() .trim() .split('/'); let rootType = parts.shift().trim(); let subType = parts.join('/').trim(); if (mimeTypes.has(rootType + '/' + subType)) { let value = mimeTypes.get(rootType + '/' + subType); if (Array.isArray(value)) { return value[0]; } return value; } switch (rootType) { case 'text': return 'txt'; default: return 'bin'; } },True,Ruby,detectExtension,mime-types.js,https://github.com/nodemailer/nodemailer,nodemailer,Andris Reinman,2020-11-12 10:03:18+02:00,v6.4.16,CWE-88,Improper Neutralization of Argument Delimiters in a Command ('Argument Injection'),"The product constructs a string for a command to be executed by a separate component
in another control sphere, but it does not properly delimit the
intended arguments, options, or switches within that command string.",https://cwe.mitre.org/data/definitions/88.html,CVE-2020-7769,
3363,"detectMimeType(filename) { if (!filename) { return defaultMimeType; } let parsed = path.parse(filename); let extension = (parsed.ext.substr(1) || parsed.name || '') .split('?') .shift() .trim() .toLowerCase(); let value = defaultMimeType; if (extensions.has(extension)) { value = extensions.get(extension); } if (Array.isArray(value)) { return value[0]; } return value; },",True,Ruby,detectMimeType,mime-types.js,https://github.com/nodemailer/nodemailer,nodemailer,Andris Reinman,2020-11-12 10:03:18+02:00,v6.4.16,CWE-88,Improper Neutralization of Argument Delimiters in a Command ('Argument Injection'),"The product constructs a string for a command to be executed by a separate component
in another control sphere, but it does not properly delimit the
intended arguments, options, or switches within that command string.",https://cwe.mitre.org/data/definitions/88.html,CVE-2020-7769,
3364,"def within_bounding_box(sw_lat, sw_lng, ne_lat, ne_lng, lat_attr, lon_attr) spans = ""#{lat_attr} BETWEEN #{sw_lat} AND #{ne_lat} AND "" # handle box that spans 180 longitude if sw_lng.to_f > ne_lng.to_f spans + ""(#{lon_attr} BETWEEN #{sw_lng} AND 180 OR "" + ""#{lon_attr} BETWEEN -180 AND #{ne_lng})"" else spans + ""#{lon_attr} BETWEEN #{sw_lng} AND #{ne_lng}"" end end",True,Ruby,within_bounding_box,sql.rb,https://github.com/alexreisner/geocoder,alexreisner,Alex Reisner,2020-01-23 09:13:06-07:00,Sanitize lat/lon for SQL query.,CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2020-7981,
3367,"def download(url, remote_headers = {}) headers = remote_headers. reverse_merge('User-Agent' => ""CarrierWave/#{CarrierWave::VERSION}"") begin file = OpenURI.open_uri(process_uri(url.to_s), headers) rescue StandardError => e raise CarrierWave::DownloadError, ""could not download file: #{e.message}"" end CarrierWave::Downloader::RemoteFile.new(file) end",True,Ruby,download,base.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3370,"def filename_from_header return nil unless file.meta.include? 'content-disposition' match = file.meta['content-disposition'].match(/filename=(?:""([^""]+)""|([^"";]+))/) return nil unless match match[1].presence || match[2].presence end",True,Ruby,filename_from_header,remote_file.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3371,def filename_from_uri CGI.unescape(File.basename(file.base_uri.path)) end,True,Ruby,filename_from_uri,remote_file.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3374,"def original_filename filename = filename_from_header || filename_from_uri mime_type = MiniMime.lookup_by_content_type(file.content_type) unless File.extname(filename).present? || mime_type.blank? filename = ""#{filename}.#{mime_type.extension}"" end filename end",True,Ruby,original_filename,remote_file.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3375,def initialize(file) @file = file.is_a?(String) ? StringIO.new(file) : file end,True,Ruby,initialize,remote_file.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3379,"it ""converts to Punycode URI"" do expect(subject.process_uri(uri).to_s).to eq 'http://xn--eckwd4c7cu47r2wf.jp/test.jpg' end",True,Ruby,"""converts to Punycode URI""",base_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3383,"it ""raises an error when trying to download a local file"" do expect { subject.download('/etc/passwd') }.to raise_error(CarrierWave::DownloadError) end",True,Ruby,"""raises an error when trying to download a local file""",base_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3386,"it ""downloads a file"" do expect(subject.download(uri).file.read).to eq file end",True,Ruby,"""downloads a file""",base_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3391,"it 'sets file extension based on content-type if missing' do expect(subject.original_filename).to eq ""test.jpeg"" end",True,Ruby,'sets file extension based on content-type if missing',remote_file_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3393,"it ""should raise an error if the image fails an integrity check when downloaded"" do stub_request(:get, ""www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) expect(running { @instance.remote_image_url = ""http://www.example.com/test.jpg"" }).to raise_error(CarrierWave::IntegrityError) end",True,Ruby,"""should raise an error if the image fails an integrity check when downloaded""",mount_single_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3394,"it ""should be an error instance if file was downloaded"" do stub_request(:get, ""www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) @instance.remote_image_url = ""http://www.example.com/test.jpg"" e = @instance.image_integrity_error expect(e).to be_an_instance_of(CarrierWave::IntegrityError) expect(e.message.lines.grep(/^You are not allowed to upload/)).to be_truthy end",True,Ruby,"""should be an error instance if file was downloaded""",mount_single_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3395,"it ""should raise an error if the image fails to be processed when downloaded"" do stub_request(:get, ""www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) expect(running { @instance.remote_image_url = ""http://www.example.com/test.jpg"" }).to raise_error(CarrierWave::ProcessingError) end",True,Ruby,"""should raise an error if the image fails to be processed when downloaded""",mount_single_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3400,"it ""should do nothing when a validation fails"" do Event.validate { |r| r.errors.add :textfile, ""FAIL!"" } @event.image = stub_file('test.jpeg') expect(@event.save).to be_falsey expect(@event.image).to be_an_instance_of(@uploader) expect(@event.image.current_path).to match(/^#{public_path('uploads/tmp')}/) end it ""should assign the filename to the database"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy @event.reload expect(@event[:image]).to eq('test.jpeg') expect(@event.image_identifier).to eq('test.jpeg') end it ""should preserve the image when nothing is assigned"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy @event = Event.find(@event.id) @event.foo = ""bar"" expect(@event.save).to be_truthy expect(@event[:image]).to eq('test.jpeg') expect(@event.image_identifier).to eq('test.jpeg') end it ""should remove the image if remove_image? returns true"" do @event.image = stub_file('test.jpeg') @event.save! @event.remove_image = true @event.save! @event.reload expect(@event.image).to be_blank expect(@event[:image]).to eq(nil) expect(@event.image_identifier).to eq(nil) end it ""should mark image as changed when saving a new image"" do expect(@event.image_changed?).to be_falsey @event.image = stub_file(""test.jpeg"") expect(@event.image_changed?).to be_truthy @event.save @event.reload expect(@event.image_changed?).to be_falsey @event.image = stub_file(""test.jpg"") expect(@event.image_changed?).to be_truthy expect(@event.changed_for_autosave?).to be_truthy end end describe ""image?"" do it ""returns true when the file is cached"" do @event.image = stub_file('test.jpg') expect(@event.image?).to be_truthy end it ""returns false when the file is removed"" do @event.remove_image! @event.save! expect(@event.image?).to be_falsey end it ""returns true when the file is stored"" do @event.image = stub_file('test.jpg') @event.save! expect(@event.image?).to be_truthy end it ""returns true when a file is removed and stored again"" do @event.image = stub_file('test.jpeg') @event.save! @event.remove_image! @event.save! @event.image = stub_file('test.jpeg') @event.save! expect(@event.image?).to be_truthy end end describe ""remove_image!"" do before do @event.image = stub_file('test.jpeg') @event.save! end it ""should clear the serialization column"" do @event.remove_image! expect(@event.attributes['image']).to be_blank end it ""resets remove_image? to false"" do @event.remove_image = true expect { @event.remove_image! }.to change { @event.remove_image? }.from(true).to(false) end end describe ""remove_image="" do it ""should mark the image as changed if changed"" do expect(@event.image_changed?).to be_falsey expect(@event.remove_image).to be_nil @event.remove_image = ""1"" expect(@event.image_changed?).to be_truthy end end describe ""#remote_image_url="" do before do stub_request(:get, ""www.example.com/test.jpg"").to_return(body: File.read(file_path(""test.jpg""))) end # FIXME ideally image_changed? and remote_image_url_changed? would return true it ""should mark image as changed when setting remote_image_url"" do expect(@event.image_changed?).to be_falsey @event.remote_image_url = 'http://www.example.com/test.jpg' expect(@event.image_changed?).to be_truthy @event.save! @event.reload expect(@event.image_changed?).to be_falsey end context 'when validating download' do before do @uploader.class_eval do def download! file, headers = {} raise CarrierWave::DownloadError end end @event.remote_image_url = 'http://www.example.com/missing.jpg' end it ""should make the record invalid when a download error occurs"" do expect(@event).to_not be_valid end it ""should use I18n for download errors without messages"" do @event.valid? expect(@event.errors[:image]).to eq(['could not be downloaded']) change_locale_and_store_translations(:pt, :activerecord => { :errors => { :messages => { :carrierwave_download_error => 'não pode ser descarregado' } } }) do expect(@event).to_not be_valid expect(@event.errors[:image]).to eq(['não pode ser descarregado']) end end end end describe '#destroy' do it ""should not raise an error with a custom filename"" do @uploader.class_eval do def filename ""page.jpeg"" end end @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy expect { @event.destroy }.to_not raise_error end it ""should do nothing when no file has been assigned"" do expect(@event.save).to be_truthy @event.destroy end it ""should remove the file from the filesystem"" do @event.image = stub_file('test.jpeg') expect(@event.save).to be_truthy expect(@event.image).to be_an_instance_of(@uploader) expect(@event.image.current_path).to eq public_path('uploads/test.jpeg') @event.destroy expect(File.exist?(public_path('uploads/test.jpeg'))).to be_falsey end end",True,Ruby,"""should do nothing when a validation fails""",activerecord_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:22+09:00,"Fix SSRF vulnerability in the remote file download feature

Closes #2509, Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-fwcm-636p-68r5",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-21288,
3403,"def create_info_block(options) return nil unless options assignments = options.map { |k, v| ""img.#{k} = #{v}"" } code = ""lambda { |img| "" + assignments.join("";"") + ""}"" eval code end",True,Ruby,create_info_block,rmagick.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:28+09:00,"Fix Code Injection vulnerability in CarrierWave::RMagick

Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-cf3w-g86h-35x4",CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2021-21305,
3406,"it 'supports passing read options to RMagick' do expect_any_instance_of(::Magick::Image::Info).to receive(:density=).with(10) expect_any_instance_of(::Magick::Image::Info).to receive(:size=).with(""200x200"") instance.manipulate! :read => { :density => 10, :size => %{""200x200""} } end",True,Ruby,'supports passing read options to RMagick',rmagick_spec.rb,https://github.com/carrierwaveuploader/carrierwave,carrierwaveuploader,M.Shibuya,2021-02-08 13:42:28+09:00,"Fix Code Injection vulnerability in CarrierWave::RMagick

Refs. https://github.com/carrierwaveuploader/carrierwave/security/advisories/GHSA-cf3w-g86h-35x4",CWE-94,Improper Control of Generation of Code ('Code Injection'),"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",https://cwe.mitre.org/data/definitions/94.html,CVE-2021-21305,
3413,"def updated_ajax @user = current_site.users.find(params[:user_id]) render inline: @user.update(params.require(:password).permit!) ? """" : @user.errors.full_messages.join(', ') end",True,Ruby,updated_ajax,users_controller.rb,https://github.com/owen2345/camaleon-cms,owen2345,Brian Kephart,2021-10-11 23:53:35-05:00,"Logout user on password change, except in the session making the change",CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2021-25970,
3420,"def cama_current_user return @cama_current_user if defined?(@cama_current_user) # api current user... @cama_current_user = cama_calc_api_current_user return @cama_current_user if @cama_current_user return nil unless cookies[:auth_token].present? c = cookies[:auth_token].split(""&"") return nil unless c.size == 3 @cama_current_user = current_site.users_include_admins.find_by_auth_token(c[0]).try(:decorate) end",True,Ruby,cama_current_user,session_helper.rb,https://github.com/owen2345/camaleon-cms,owen2345,Brian Kephart,2021-10-11 23:53:35-05:00,"Logout user on password change, except in the session making the change",CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2021-25970,
3421,"def file_parse(key) file_path = File.join(@root_folder, key) url_path, is_dir = file_path.sub(Rails.root.join('public').to_s, ''), File.directory?(file_path) res = { ""name"" => File.basename(key), ""folder_path"" => File.dirname(key), ""url"" => is_dir ? '' : (is_private_uploader? ? url_path.sub(""#{@root_folder}/"", '') : File.join(@current_site.decorate.the_url(as_path: true, locale: false, skip_relative_url_root: true), url_path)), ""is_folder"" => is_dir, ""file_size"" => is_dir ? 0 : File.size(file_path).round(2), ""thumb"" => '', 'file_type' => self.class.get_file_format(file_path), 'dimension' => '' }.with_indifferent_access res['key'] = File.join(res['folder_path'], res['name']) res[""thumb""] = (is_private_uploader? ? '/admin/media/download_private_file?file=' + version_path(key).slice(1..-1) : version_path(res['url'])) if res['file_type'] == 'image' && File.extname(file_path).downcase != '.gif' if res['file_type'] == 'image' res[""thumb""].sub! '.svg', '.jpg' im = MiniMagick::Image.open(file_path) res['dimension'] = ""#{im[:width]}x#{im[:height]}"" end res end",True,Ruby,file_parse,camaleon_cms_local_uploader.rb,https://github.com/owen2345/camaleon-cms,owen2345,Brian Kephart,2021-10-12 00:00:07-05:00,Fix error when uploading an SVG with no size,CWE-755,Improper Handling of Exceptional Conditions,The product does not handle or incorrectly handles an exceptional condition.,https://cwe.mitre.org/data/definitions/755.html,CVE-2021-25971,
3425,"def actions if params[:media_action] != 'crop_url' authorize! :manage, :media end params[:folder] = params[:folder].gsub(""//"", ""/"") if params[:folder].present? case params[:media_action] when ""new_folder"" params[:folder] = slugify_folder(params[:folder]) render partial: ""render_file_item"", locals: {files: [cama_uploader.add_folder(params[:folder])]} when ""del_folder"" cama_uploader.delete_folder(params[:folder]) render inline: """" when ""del_file"" cama_uploader.delete_file(params[:folder].gsub(""//"", ""/"")) render inline: """" when 'crop_url' unless params[:url].start_with?('data:') params[:url] = (params[:url].start_with?('http') ? '' : current_site.the_url(locale: nil)) + params[:url] end r = cama_tmp_upload( params[:url], formats: params[:formats], name: params[:name]) unless r[:error].present? params[:file_upload] = r[:file_path] sett = {remove_source: true} sett[:same_name] = true if params[:same_name].present? sett[:name] = params[:name] if params[:name].present? upload(sett) else render inline: r[:error] end end",True,Ruby,actions,media_controller.rb,https://github.com/owen2345/camaleon-cms,owen2345,Brian Kephart,2021-10-12 00:02:51-05:00,Disallow uploads from localhost,CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2021-25972,
3427,"def nofollowify_links(string) if this_blog.dofollowify string else string.gsub(/<a(.*?)>/i, '<a\1 rel=""nofollow"">') end end",True,Ruby,nofollowify_links,base_helper.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3429,"def html_postprocess(_field, html) html end",True,Ruby,html_postprocess,content_base.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3431,"it ""with dofollowify enabled, links should be nofollowed"" do @blog.dofollowify = true @blog.save expect(nofollowify_links('<a href=""http://myblog.net"">my blog</a>')). to eq('<a href=""http://myblog.net"">my blog</a>') end",True,Ruby,"""with dofollowify enabled, links should be nofollowed""",base_helper_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3434,"it ""with dofollowify disabled, links should be nofollowed"" do @blog.dofollowify = false @blog.save expect(nofollowify_links('<a href=""http://myblog.net"">my blog</a>')). to eq('<a href=""http://myblog.net"" rel=""nofollow"">my blog</a>') end",True,Ruby,"""with dofollowify disabled, links should be nofollowed""",base_helper_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3441,"it ""renders email addresses in the body"" do comment = build_stubbed(:comment, body: ""foo@example.com"") expect(comment.generate_html(:body)).to match(/mailto:/) end",True,Ruby,"""renders email addresses in the body""",comment_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3442,"it ""converts the comment markup to HTML"" do expect(comment.generate_html(:body)).to match(%r{<em>italic</em>}) expect(comment.generate_html(:body)).to match(%r{<strong>bold</strong>}) end",True,Ruby,"""converts the comment markup to HTML""",content_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2021-10-10 19:37:47+02:00,"Ensure all Content html is sanitized

- Require all content to be html_safe before displaying
- Sanitize all content html, not just Comments
- Make nofollowify_links take and return html_safe strings",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25974,
3454,"def self.publication_months result = select(""published_at"").where(""published_at is not NULL"").where(type: ""Article"") result.map { |it| [it.publication_month] }.uniq end # Finds one article which was posted on a certain date and matches the # supplied dashed-title params is a Hash def self.requested_article(params) date_range = PublifyTime.delta(params[:year], params[:month], params[:day]) req_params = {} req_params[:permalink] = params[:title] if params[:title] req_params[:published_at] = date_range if date_range return if req_params.empty? # no search if no params send article = published.find_by(req_params) return article if article if params[:title] req_params[:permalink] = CGI.escape(params[:title]) article = published.find_by(req_params) return article if article end end # Fulltext searches the body of published articles def self.search(query, args = {}) query_s = query.to_s.strip if !query_s.empty? && args.empty? Article.searchstring(query) elsif !query_s.empty? && !args.empty? Article.searchstring(query).page(args[:page]).per(args[:per]) else [] end end def keywords_to_tags Tag.create_from_article!(self) end def interested_users User.where(notify_on_new_articles: true) end def notify_user_via_email(user) EmailNotify.send_article(self, user) if user.notify_via_email? end def comments_closed? !(allow_comments? && in_feedback_window?) end def html_urls urls = [] html.gsub(/<a\s+[^>]*>/) do |tag| urls.push(Regexp.last_match[2].strip) if tag =~ /\bhref=([""']?)([^ >""]+)\1/ end urls.uniq end def pings_closed? !(allow_pings? && in_feedback_window?) end # check if time to comment is open or not def in_feedback_window? blog.sp_article_auto_close.zero? || published_at.to_i > blog.sp_article_auto_close.days.ago.to_i end # The web interface no longer distinguishes between separate ""body"" and # ""extended"" fields, and instead edits everything in a single edit field, # separating the extended content using ""\<!--more-->"". def body_and_extended if extended.blank? body else ""#{body}\n<!--more-->\n#{extended}"" end end # Split apart value around a ""\<!--more-->"" comment and assign it to our # #body and #extended fields. def body_and_extended=(value) parts = value.split(/\n?<!--more-->\n?/, 2) self.body = parts[0] self.extended = parts[1] || """" end def password_protected? password.present? end def add_comment(params) comments.build(params) end def access_by?(user) user.admin? || user_id == user.id end def allow_comments? return allow_comments unless allow_comments.nil? blog.default_allow_comments end def allow_pings? return allow_pings unless allow_pings.nil? blog.default_allow_pings end def published_comments comments.published.oldest_first end def published_trackbacks trackbacks.published.oldest_first end def published_feedback feedback.published.oldest_first end private def permalink_url_options format_url = blog.permalink_format.dup format_url.gsub!(""%year%"", published_at.year.to_s) format_url.gsub!(""%month%"", sprintf(""%<month>.2d"", month: published_at.month)) format_url.gsub!(""%day%"", sprintf(""%<day>.2d"", day: published_at.day)) format_url.gsub!(""%title%"", URI::DEFAULT_PARSER.escape(permalink.to_s)) if format_url[0, 1] == ""/"" format_url[1..-1] else format_url end end def trigger_publication # TODO: Skip if already published, update when published_at changes Trigger.post_action(published_at, self, ""publish!"") end end",True,Ruby,self.publication_months,article.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-02-13 16:40:55+01:00,Do not allow comments on Article if not published,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-0574,
3455,def comments_closed? !(allow_comments? && in_feedback_window?) end,True,Ruby,comments_closed?,article.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-02-13 16:40:55+01:00,Do not allow comments on Article if not published,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-0574,
3459,"it ""returns only published articles"" do article = create(:article) create(:comment, article: article) unpublished_article = create(:article, state: ""draft"") create(:comment, article: unpublished_article) expect(described_class.published).to eq([article]) expect(described_class.bestof).to eq([article]) end",True,Ruby,"""returns only published articles""",article_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-02-13 16:40:55+01:00,Do not allow comments on Article if not published,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-0574,
3464,"def html_postprocess(_field, html) helper = ContentTextHelpers.new helper.sanitize(helper.auto_link(html)) end",True,Ruby,html_postprocess,feedback.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-02-13 18:12:03+01:00,Do not allow images in comments,NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-0578,
3467,"def show_article auto_discovery_feed respond_to do |format| format.html do @comment = Comment.new @page_title = this_blog.article_title_template.to_title(@article, this_blog, params) @description = this_blog.article_desc_template.to_title(@article, this_blog, params) @keywords = @article.tags.map(&:name).join("", "") render ""articles/#{@article.post_type}"" end format.atom { render_feedback_feed(""atom"") } format.rss { render_feedback_feed(""rss"") } format.xml { render_feedback_feed(""atom"") } end rescue ActiveRecord::RecordNotFound error! end",True,Ruby,show_article,articles_controller.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-05-14 19:24:53+02:00,Do not create article meta description for password-protected articles,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-1553,
3470,"it ""article alone should be password protected"" do get :redirect, params: { from: from_param } expect(response.body).to have_selector('input[id=""article_password""]', count: 1) end",True,Ruby,"""article alone should be password protected""",articles_controller_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-05-14 19:24:53+02:00,Do not create article meta description for password-protected articles,CWE-863,Incorrect Authorization,"The product performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.",https://cwe.mitre.org/data/definitions/863.html,CVE-2022-1553,
3473,"def update return unless access_granted?(params[:id]) id = params[:article][:id] || params[:id] @article = Article.find(id) if params[:article][:draft] fetch_fresh_or_existing_draft_for_article else @article = Article.find(@article.parent_id) unless @article.parent_id.nil? end update_article_attributes if @article.draft @article.state = ""draft"" elsif @article.draft? @article.publish! end if @article.save Article.where(parent_id: @article.id).map(&:destroy) unless @article.draft flash[:success] = I18n.t(""admin.content.update.success"") redirect_to action: ""index"" else @article.keywords = Tag.collection_to_string @article.tags load_resources render ""edit"" end end",True,Ruby,update,content_controller.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-05-22 13:24:24+02:00,Use only the main id parameter to find Article to update,CWE-639,Authorization Bypass Through User-Controlled Key,The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.,https://cwe.mitre.org/data/definitions/639.html,CVE-2022-1810,
3477,"def check_image_content_type!(new_file) if image?(new_file) magic_type = mime_magic_content_type(new_file) if magic_type != new_file.content_type raise CarrierWave::IntegrityError, ""has MIME type mismatch"" end end end",True,Ruby,check_image_content_type!,resource_uploader.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-05-22 15:25:53+02:00,Refuse html files as resources even if declared to be plain text,CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-1811,
3480,def mime_magic_content_type(new_file) content_type = nil File.open(new_file.path) do |fd| content_type = Marcel::MimeType.for(fd) end content_type end,True,Ruby,mime_magic_content_type,resource_uploader.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-05-22 15:25:53+02:00,Refuse html files as resources even if declared to be plain text,CWE-434,Unrestricted Upload of File with Dangerous Type,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,https://cwe.mitre.org/data/definitions/434.html,CVE-2022-1811,
3508,"it ""requires name to be present"" do expect(blog.tags.build(name: """")).not_to be_valid end",True,Ruby,"""requires name to be present""",tag_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-08-14 14:02:12+02:00,"Validate lengths of string attributes

When using the MySQL database, Rails automatically sets a limit of 255
characters for string columns. This changes ensures this limit is also
enforced in the validations. For several columns with a different limit,
that different limit is enforced instead.

For the PostgreSQL database, there is no limit in the database, but it
is useful to set a limit anyway to prevent absurdly large values from
being submitted.",CWE-20,Improper Input Validation,"The product receives input or data, but it does
        not validate or incorrectly validates that the input has the
        properties that are required to process the data safely and
        correctly.",https://cwe.mitre.org/data/definitions/20.html,CVE-2023-0299,
3519,"it ""redirects to index"" do post :update, params: { id: contributor.id, user: { login: ""errand"", email: ""corey@test.com"", password: ""testpass"", password_confirmation: ""testpass"" } } expect(response).to redirect_to(action: ""index"") end",True,Ruby,"""redirects to index""",users_controller_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-08-19 23:41:41+02:00,"Require user passwords to be strong

This adds validation of passwords using the zxcvbn password strength
estimation gem.",CWE-521,Weak Password Requirements,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.",https://cwe.mitre.org/data/definitions/521.html,CVE-2023-0569,
3521,"it ""empty blog name should raise an error"" do post :create, params: { setting: { blog_name: """", email: ""foo@bar.net"", password: ""foobar123"" } } expect(response).to redirect_to(action: ""index"") end",True,Ruby,"""empty blog name should raise an error""",setup_controller_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-08-19 23:41:41+02:00,"Require user passwords to be strong

This adds validation of passwords using the zxcvbn password strength
estimation gem.",CWE-521,Weak Password Requirements,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.",https://cwe.mitre.org/data/definitions/521.html,CVE-2023-0569,
3522,"it ""empty email should raise an error"" do post :create, params: { setting: { blog_name: ""Foo"", email: """", password: ""foobar123"" } } expect(response).to redirect_to(action: ""index"") end",True,Ruby,"""empty email should raise an error""",setup_controller_spec.rb,https://github.com/publify/publify,publify,Matijs van Zuijlen,2022-08-19 23:41:41+02:00,"Require user passwords to be strong

This adds validation of passwords using the zxcvbn password strength
estimation gem.",CWE-521,Weak Password Requirements,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.",https://cwe.mitre.org/data/definitions/521.html,CVE-2023-0569,
3533,"def meeting_link(uniqueid, data) notification = t( ""notifications.meeting.#{data[:type]}"", name: data[:user], group_name: data[:group], meeting_name: data[:typename] ) link = specific_meeting_link(data[:type], data[:typeid], data[:group_id]) notification_link(uniqueid, link, notification) end",True,Ruby,meeting_link,notifications_helper.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3534,"def comment_link(uniqueid, data) comment = comment_for_type(data) i18n_key = data[:cutoff] ? 'truncated' : 'full' notification = t( ""notifications.comment.#{i18n_key}"", name: data[:user], comment: strip_tags(data[:comment]), typename: data[:typename] ) notification_link(uniqueid, comment[:path], notification) end",True,Ruby,comment_link,notifications_helper.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3535,"def group_link(uniqueid, data) notification = t( ""notifications.group.#{data[:type]}"", name: data[:user], group_name: data[:group] ) link = ""/groups/#{data[:group_id]}"" notification_link(uniqueid, link, notification) end",True,Ruby,group_link,notifications_helper.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3537,"def accepted_ally_link(uniqueid, data) notification = t( 'notifications.ally.accepted', name: data[:user] ) link = ""/profile?uid=#{data[:uid]}"" notification_link(uniqueid, link, notification) end",True,Ruby,accepted_ally_link,notifications_helper.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3538,"def new_ally_request_link(uniqueid, data) link = ""/profile?uid=#{data[:uid]}"" link_html = ""<a href=\""#{link}\"">#{data[:user]}</a>"" # rubocop:disable Layout/LineLength ""<div id=\""#{uniqueid}\""><div>#{t('notifications.ally.sent_html', link_to_user: link_html)}</div>#{request_actions(data[:user_id])}</div>"" # rubocop:enable Layout/LineLength end",True,Ruby,new_ally_request_link,notifications_helper.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3540,"it 'returns correct link' do data = { cutoff: false, user: 'Julia Nguyen', comment: 'Hello', typename: 'typename', type: 'type_comment_moment', typeid: 1, commentable_id: 1 } expect(comment_link(uniqueid, data)).to eq('<a id=""uniqueid"" href=""/moments/1"">Julia Nguyen commented ""Hello"" on typename</a>') end",True,Ruby,'returns correct link',notifications_helper_spec.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3543,it 'is valid with valid attributes' do notification = build(:notification) expect(notification).to be_valid end,True,Ruby,'is valid with valid attributes',notification_spec.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-18 23:01:15-05:00,[#2052] Fix stored XSS in Notifications,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2021-25988,
3545,"def render_notification(notification) uniqueid = notification[:uniqueid] data = convert_to_hash(notification[:data]) # In case data[:name] is invalid data[:email] = User.find(data[:user_id]).email case data[:type] when /comment/ then comment_link(uniqueid, data) when /accepted_ally_request/ then accepted_ally_link(uniqueid, data) when /new_ally_request/ then new_ally_request_link(uniqueid, data) when /group/ then group_link(uniqueid, data) when /meeting/ then meeting_link(uniqueid, data) end",True,Ruby,render_notification,notifications_controller.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2021-11-19 01:49:08-05:00,[#2052] Fix improper access control leads to admin self-banning,NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2021-25991,
3551,def destroy current_user.invalidate_all_sessions! super end,True,Ruby,destroy,sessions_controller.rb,https://github.com/ifmeorg/ifme,ifmeorg,Julia Nguyen,2022-02-04 02:25:03-05:00,Call invalidate_all_sessions in prepend_before_action,CWE-613,Insufficient Session Expiration,"According to WASC, ""Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.""",https://cwe.mitre.org/data/definitions/613.html,CVE-2021-25992,
3553,"def create_fixed_clamp_code(nbits, signed) if nbits == 1 && signed == :signed raise ""signed bitfield must have more than one bit"" end if signed == :signed max = (1 << (nbits - 1)) - 1 min = -(max + 1) else min = 0 max = (1 << nbits) - 1 end clamp = ""(val < #{min}) ? #{min} : (val > #{max}) ? #{max} : val"" if nbits == 1 # allow single bits to be used as booleans clamp = ""(val == true) ? 1 : (not val) ? 0 : #{clamp}"" end ""val = #{clamp}"" end",True,Ruby,create_fixed_clamp_code,bits.rb,https://github.com/dmendel/bindata,dmendel,Dion Mendel,2021-05-18 11:39:35+08:00,Improved creation time of Bits and Integers,NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2021-32823,
3556,"def create_clamp_code(nbits, signed) if signed == :signed max = (1 << (nbits - 1)) - 1 min = -(max + 1) else max = (1 << nbits) - 1 min = 0 end ""val = (val < #{min}) ? #{min} : (val > #{max}) ? #{max} : val"" end",True,Ruby,create_clamp_code,int.rb,https://github.com/dmendel/bindata,dmendel,Dion Mendel,2021-05-18 11:39:35+08:00,Improved creation time of Bits and Integers,NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2021-32823,
3561,def set_inboxes @inbox_ids = if params[:inbox_id] current_account.inboxes.where(id: params[:inbox_id]) else @current_user.assigned_inboxes.pluck(:id) end,True,Ruby,set_inboxes,conversation_finder.rb,https://github.com/chatwoot/chatwoot,chatwoot,GitHub,2022-02-03 18:25:28-08:00,"Fix: Conversation filter permissions (#3908)

fixes: chatwoot/product#225",CWE-639,Authorization Bypass Through User-Controlled Key,The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.,https://cwe.mitre.org/data/definitions/639.html,CVE-2021-3813,
3566,def update @campaign.update(campaign_params) end,True,Ruby,update,campaigns_controller.rb,https://github.com/chatwoot/chatwoot,chatwoot,GitHub,2022-02-04 14:26:18+05:18,fix: Ongoing campaign URL validation (#3890),CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2022-0527,
3571,"it 'returns all campaigns belonging to the inbox to administrators' do # create a random campaign create(:campaign, account: account) get ""/api/v1/accounts/#{account.id}/inboxes/#{inbox.id}/campaigns"", headers: administrator.create_new_auth_token, as: :json expect(response).to have_http_status(:success) body = JSON.parse(response.body, symbolize_names: true) expect(body.first[:id]).to eq(campaign.display_id) expect(body.length).to eq(1) end",True,Ruby,'returns all campaigns belonging to the inbox to administrators',inboxes_controller_spec.rb,https://github.com/chatwoot/chatwoot,chatwoot,GitHub,2022-02-04 14:26:18+05:18,fix: Ongoing campaign URL validation (#3890),CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2022-0527,
3573,def url_valid?(url) url = begin URI.parse(url) rescue StandardError false end url.is_a?(URI::HTTP) || url.is_a?(URI::HTTPS) end,True,Ruby,url_valid?,campaign.rb,https://github.com/chatwoot/chatwoot,chatwoot,GitHub,2022-03-30 14:24:22+05:18,"fix: Referer URL validation (#4309)

Fixes #354",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2022-1021,
3580,"int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len, int not_first) { char *e, *n; unsigned long long cl; struct ist word; int check_prev = not_first; word.ptr = value->ptr - 1; // -1 for next loop's pre-increment e = value->ptr + value->len; while (++word.ptr < e) { /* skip leading delimiter and blanks */ if (unlikely(HTTP_IS_LWS(*word.ptr))) continue; /* digits only now */ for (cl = 0, n = word.ptr; n < e; n++) { unsigned int c = *n - '0'; if (unlikely(c > 9)) { /* non-digit */ if (unlikely(n == word.ptr)) // spaces only goto fail; break; } if (unlikely(cl > ULLONG_MAX / 10ULL)) goto fail; /* multiply overflow */ cl = cl * 10ULL; if (unlikely(cl + c < cl)) goto fail; /* addition overflow */ cl = cl + c; } /* keep a copy of the exact cleaned value */ word.len = n - word.ptr; /* skip trailing LWS till next comma or EOL */ for (; n < e; n++) { if (!HTTP_IS_LWS(*n)) { if (unlikely(*n != ',')) goto fail; break; } } /* if duplicate, must be equal */ if (check_prev && cl != *body_len) goto fail; /* OK, store this result as the one to be indexed */ *body_len = cl; *value = word; word.ptr = n; check_prev = 1; } /* here we've reached the end with a single value or a series of * identical values, all matching previous series if any. The last * parsed value was sent back into <value>. We just have to decide * if this occurrence has to be indexed (it's the first one) or * silently skipped (it's not the first one) */ return !not_first; fail: return -1; }",True,Ruby,http_parse_cont_len_header,http.c,https://github.com/haproxy/haproxy,haproxy,Willy Tarreau,2023-08-09 09:27:38+02:00,"BUG/MAJOR: http: reject any empty content-length header value

The content-length header parser has its dedicated function, in order
to take extreme care about invalid, unparsable, or conflicting values.
But there's a corner case in it, by which it stops comparing values
when reaching the end of the header. This has for a side effect that
an empty value or a value that ends with a comma does not deserve
further analysis, and it acts as if the header was absent.

While this is not necessarily a problem for the value ending with a
comma as it will be cause a header folding and will disappear, it is a
problem for the first isolated empty header because this one will not
be recontructed when next ones are seen, and will be passed as-is to the
backend server. A vulnerable HTTP/1 server hosted behind haproxy that
would just use this first value as ""0"" and ignore the valid one would
then not be protected by haproxy and could be attacked this way, taking
the payload for an extra request.

In field the risk depends on the server. Most commonly used servers
already have safe content-length parsers, but users relying on haproxy
to protect a known-vulnerable server might be at risk (and the risk of
a bug even in a reputable server should never be dismissed).

A configuration-based work-around consists in adding the following rule
in the frontend, to explicitly reject requests featuring an empty
content-length header that would have not be folded into an existing
one:

    http-request deny if { hdr_len(content-length) 0 }

The real fix consists in adjusting the parser so that it always expects a
value at the beginning of the header or after a comma. It will now reject
requests and responses having empty values anywhere in the C-L header.

This needs to be backported to all supported versions. Note that the
modification was made to functions h1_parse_cont_len_header() and
http_parse_cont_len_header(). Prior to 2.8 the latter was in
h2_parse_cont_len_header(). One day the two should be refused but the
former is also used by Lua.

The HTTP messaging reg-tests were completed to test these cases.

Thanks to Ben Kallus of Dartmouth College and Narf Industries for
reporting this! (this is in GH #2237).",CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-40225,
3581,"def post_reactions_users id = params.require(:id).to_i reaction_value = params[:reaction_value] post = Post.find_by(id: id) raise Discourse::InvalidParameters if !post reaction_users = [] likes = post.post_actions.where( ""deleted_at IS NULL AND post_action_type_id = ?"", PostActionType.types[:like], ) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id if likes.present? main_reaction = DiscourseReactions::Reaction.find_by( reaction_value: DiscourseReactions::Reaction.main_reaction_id, post_id: post.id, ) count = likes.length users = format_likes_users(likes) if main_reaction && main_reaction[:reaction_users_count] (users << get_users(main_reaction)).flatten! users.sort_by! { |user| user[:created_at] } count += main_reaction.reaction_users_count.to_i end reaction_users << { id: DiscourseReactions::Reaction.main_reaction_id, count: count, users: users.reverse.slice(0, MAX_USERS_COUNT + 1), } end if !reaction_value post .reactions .select do |reaction| reaction[:reaction_users_count] && reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id end .each { |reaction| reaction_users << format_reaction_user(reaction) } elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id post .reactions .where(reaction_value: reaction_value) .select { |reaction| reaction[:reaction_users_count] } .each { |reaction| reaction_users << format_reaction_user(reaction) } end render_json_dump(reaction_users: reaction_users) end",True,Ruby,post_reactions_users,custom_reactions_controller.rb,https://github.com/discourse/discourse-reactions,discourse,GitHub,2023-04-03 11:34:28-06:00,"SECURITY: Publish reactions based on topic permissions (#218)

Only show post reactions to users that have permission to see the
post.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-30611,
3582,def fetch_post_from_params post = Post.find(params[:post_id]) guardian.ensure_can_see!(post) post end,True,Ruby,fetch_post_from_params,custom_reactions_controller.rb,https://github.com/discourse/discourse-reactions,discourse,GitHub,2023-04-03 11:34:28-06:00,"SECURITY: Publish reactions based on topic permissions (#218)

Only show post reactions to users that have permission to see the
post.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-30611,
3585,"def publish_change_to_clients!(post, reaction: nil, previous_reaction: nil) MessageBus.publish( ""/topic/#{post.topic.id}/reactions"", post_id: post.id, reactions: [reaction, previous_reaction].compact.uniq, ) end",True,Ruby,publish_change_to_clients!,custom_reactions_controller.rb,https://github.com/discourse/discourse-reactions,discourse,GitHub,2023-04-03 11:34:28-06:00,"SECURITY: Publish reactions based on topic permissions (#218)

Only show post reactions to users that have permission to see the
post.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-30611,
3589,"it ""gives 400 ERROR when the post_id OR reaction_value is invalid"" do get ""/discourse-reactions/posts/1000000/reactions-users.json"" expect(response.status).to eq(400) get ""/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test"" expect(response.status).to eq(400) end",True,Ruby,"""gives 400 ERROR when the post_id OR reaction_value is invalid""",custom_reactions_controller_spec.rb,https://github.com/discourse/discourse-reactions,discourse,GitHub,2023-04-03 11:34:28-06:00,"SECURITY: Publish reactions based on topic permissions (#218)

Only show post reactions to users that have permission to see the
post.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-30611,
3592,"def reactions_given params.require(:username) user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts)) raise Discourse::NotFound unless guardian.can_see_profile?(user) reaction_users = DiscourseReactions::ReactionUser .joins(:reaction, :post) .includes(:user, :post, :reaction) .where(user_id: user.id) .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL') if params[:before_reaction_user_id] reaction_users = reaction_users .where('discourse_reactions_reaction_users.id < ?', params[:before_reaction_user_id].to_i) end reaction_users = reaction_users .order(created_at: :desc) .limit(20) render_serialized(reaction_users.to_a, UserReactionSerializer) end",True,Ruby,reactions_given,custom_reactions_controller.rb,https://github.com/discourse/discourse-reactions,discourse,GitHub,2021-10-11 13:03:38+11:00,"SECURITY: leaking PMs and secure categories topics (#110)

Ensure that user has access to private messages and categories of he topics",CWE-200,Exposure of Sensitive Information to an Unauthorized Actor,The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.,https://cwe.mitre.org/data/definitions/200.html,CVE-2021-41140,
3602,"def call(value) case value when *FALSE_VALUES then false when *NIL_VALUES then nil when Numeric, /\A[-+]?(0+\.?0*|0*\.?0+)\z/ then !value.to_f.zero? else value.present? end",True,Ruby,call,boolean_typecaster.rb,https://github.com/cgriego/active_attr,cgriego,GitHub,2021-04-12 16:06:15-05:00,"fix ReDoS vulnerability (#185)

resolve https://github.com/cgriego/active_attr/issues/184

Co-authored-by: wonda-tea-coffee <rikita.ishikawa@crowdworks.co.jp>",CWE-404,Improper Resource Shutdown or Release,The product does not release or incorrectly releases a resource before it is made available for re-use.,https://cwe.mitre.org/data/definitions/404.html,CVE-2021-4250,
3604,"def apply_and_return_additional_attributes_to(scope:) attr_table_name = Models::AdditionalAttribute.quoted_table_name work_table_name = scope.quoted_table_name select_fields = [""#{work_table_name}.*""] additional_attributes.each do |attribute| table_name = attribute.to_s.pluralize scope = scope.joins( %(LEFT OUTER JOIN #{attr_table_name} AS #{table_name} ON #{table_name}.work_id = #{work_table_name}.id AND #{table_name}.key = ""#{attribute}"") ) select_fields << ""#{table_name}.value AS #{attribute}"" end scope.select(select_fields.join("", "")) scope end",True,Ruby,apply_and_return_additional_attributes_to,search_criteria_for_works_parameter.rb,https://github.com/ndlib/sipity,ndlib,Jeremy Friesen,2021-08-12 09:38:31-04:00,"Adding protection against SQL injection

Prior to this commit, the SearchCriteriaForWorksParameter class was to
optimistic in the additional_attributes it received.  This was ""okay"" in
that these attributes were passed from within the application (and not
from user input).

However, I wanted to tighten that up further which is why I added the
changes to fetch the attributes from a map.

And even with all of this, [brakeman][1] identified this as a weak
chance for SQL injection.  So I also added a config/brakeman.yml file to
skip over this file. (alas I can't skip over a singular violation)

[1]:https://rubygems.org/gems/brakeman",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2021-4298,
3606,def additional_attributes=(input) @additional_attributes = Array(input).map do |attribute_name| Models::AdditionalAttribute.sanitize_sql_for_conditions(attribute_name.to_s) end end,True,Ruby,additional_attributes,search_criteria_for_works_parameter.rb,https://github.com/ndlib/sipity,ndlib,Jeremy Friesen,2021-08-12 09:38:31-04:00,"Adding protection against SQL injection

Prior to this commit, the SearchCriteriaForWorksParameter class was to
optimistic in the additional_attributes it received.  This was ""okay"" in
that these attributes were passed from within the application (and not
from user input).

However, I wanted to tighten that up further which is why I added the
changes to fetch the attributes from a map.

And even with all of this, [brakeman][1] identified this as a weak
chance for SQL injection.  So I also added a config/brakeman.yml file to
skip over this file. (alas I can't skip over a singular violation)

[1]:https://rubygems.org/gems/brakeman",CWE-89,Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'),"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/89.html,CVE-2021-4298,
3607,"def index html = <<~HTML <!DOCTYPE html> <html> <head> </head> <body> <div id=""app""></div> #{js_asset ""jquery-1.8.2.js""} #{js_asset ""react.js""} #{js_asset ""react-dom.js""} #{js_asset ""babel.min.js""} #{js_asset ""message-bus.js""} #{js_asset ""application.jsx"", ""text/jsx""} </body> </html> HTML [200, { ""content-type"" => ""text/html;"" }, [html]] end",True,Ruby,index,diagnostics.rb,https://github.com/discourse/message_bus,discourse,Alan Guo Xiang Tan,2021-12-17 14:11:53+08:00,SECURITY: Fix path traversal on diagnostics route.,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2021-43840,
3608,"def call(env) return @app.call(env) unless env['PATH_INFO'].start_with? ""#{@bus.base_route}message-bus/_diagnostics"" route = env['PATH_INFO'].split(""#{@bus.base_route}message-bus/_diagnostics"")[1] if @bus.is_admin_lookup.nil? || !@bus.is_admin_lookup.call(env) return [403, {}, ['not allowed']] end return index unless route if route == '/discover' user_id = @bus.user_id_lookup.call(env) @bus.publish('/_diagnostics/discover', user_id: user_id) return [200, {}, ['ok']] end if route =~ /^\/hup\// hostname, pid = route.split('/hup/')[1].split('/') @bus.publish('/_diagnostics/hup', hostname: hostname, pid: pid.to_i) return [200, {}, ['ok']] end asset = route.split('/assets/')[1] if asset && !asset !~ /\// content = asset_contents(asset) return [200, { 'Content-Type' => 'application/javascript;charset=UTF-8' }, [content]] end [404, {}, ['not found']] end",True,Ruby,call,diagnostics.rb,https://github.com/discourse/message_bus,discourse,Alan Guo Xiang Tan,2021-12-17 14:11:53+08:00,SECURITY: Fix path traversal on diagnostics route.,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2021-43840,
3613,"it ""should return a 403 if a user attempts to get at the _diagnostics path"" do get ""/message-bus/_diagnostics"" last_response.status.must_equal 403 end",True,Ruby,"""should return a 403 if a user attempts to get at the _diagnostics path""",middleware_spec.rb,https://github.com/discourse/message_bus,discourse,Alan Guo Xiang Tan,2021-12-17 14:11:53+08:00,SECURITY: Fix path traversal on diagnostics route.,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2021-43840,
3616,"it ""should get a 200 with html for an authorized user"" do def @bus.is_admin_lookup proc { |_| true } end get ""/message-bus/_diagnostics"" last_response.status.must_equal 200 end",True,Ruby,"""should get a 200 with html for an authorized user""",middleware_spec.rb,https://github.com/discourse/message_bus,discourse,Alan Guo Xiang Tan,2021-12-17 14:11:53+08:00,SECURITY: Fix path traversal on diagnostics route.,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2021-43840,
3617,"it ""should get the script it asks for"" do def @bus.is_admin_lookup proc { |_| true } end get ""/message-bus/_diagnostics/assets/message-bus.js"" last_response.status.must_equal 200 last_response.content_type.must_equal ""application/javascript;charset=UTF-8"" end",True,Ruby,"""should get the script it asks for""",middleware_spec.rb,https://github.com/discourse/message_bus,discourse,Alan Guo Xiang Tan,2021-12-17 14:11:53+08:00,SECURITY: Fix path traversal on diagnostics route.,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2021-43840,
3619,"def self.has_attached_file(name, options = {}) # rubocop:disable Naming/PredicateName options = { validate_media_type: false }.merge(options) super(name, options) send(:""before_#{name}_post_process"") do attachment = send(name) check_image_dimension(attachment) set_file_content_type(attachment) obfuscate_file_name(attachment) set_file_extension(attachment) Paperclip::Validators::MediaTypeSpoofDetectionValidator.new(attributes: [name]).validate(self) end end",True,Ruby,self.has_attached_file,attachmentable.rb,https://github.com/mastodon/mastodon,mastodon,GitHub,2023-07-06 15:05:05+02:00,"Merge pull request from GHSA-9928-3cp5-93fm

* Fix attachments getting processed despite failing content-type validation

* Add a restrictive ImageMagick security policy tailored for Mastodon

* Fix misdetection of MP3 files with large cover art

* Reject unprocessable audio/video files instead of keeping them unchanged",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2023-36460,
3623,"def make metadata = VideoMetadataExtractor.new(@file.path) unless metadata.valid? Paperclip.log(""Unsupported file #{@file.path}"") return File.open(@file.path) end update_attachment_type(metadata) update_options_from_metadata(metadata) destination = Tempfile.new([@basename, @format ? "".#{@format}"" : '']) destination.binmode @output_options = @convert_options[:output]&.dup || {} @input_options = @convert_options[:input]&.dup || {} case @format.to_s when /jpg$/, /jpeg$/, /png$/, /gif$/ @input_options['ss'] = @time @output_options['f'] = 'image2' @output_options['vframes'] = 1 when 'mp4' @output_options['acodec'] = 'aac' @output_options['strict'] = 'experimental' if high_vfr?(metadata) && !eligible_to_passthrough?(metadata) @output_options['vsync'] = 'vfr' @output_options['r'] = @vfr_threshold end end",True,Ruby,make,transcoder.rb,https://github.com/mastodon/mastodon,mastodon,GitHub,2023-07-06 15:05:05+02:00,"Merge pull request from GHSA-9928-3cp5-93fm

* Fix attachments getting processed despite failing content-type validation

* Add a restrictive ImageMagick security policy tailored for Mastodon

* Fix misdetection of MP3 files with large cover art

* Reject unprocessable audio/video files instead of keeping them unchanged",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2023-36460,
3631,"def account_field_value_format(field, with_rel_me: true) html_aware_format(field.value, field.account.local?, with_rel_me: with_rel_me, with_domains: true, multiline: false) end",True,Ruby,account_field_value_format,formatting_helper.rb,https://github.com/mastodon/mastodon,mastodon,GitHub,2023-07-06 15:06:49+02:00,Merge pull request from GHSA-55j9-c3mp-6fcq,NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-36462,
3642,"def show filename = Rails.root.join(""attachments"", @attachment.filename) unless File.exist?(filename) COURSE_LOGGER.log(""Cannot find the file '#{@attachment.filename}' for""\ "" attachment #{@attachment.name}"") flash[:error] = ""Error loading #{@attachment.name} from #{@attachment.filename}"" redirect_to([@course, :attachments]) && return end send_file(filename, disposition: ""inline"", type: @attachment.mime_type, filename: @attachment.filename) && return end",True,Ruby,show,attachments_controller.rb,https://github.com/autolab/autolab,autolab,GitHub,2022-04-10 16:52:02-04:00,"Force download of attachments (#1490)

* Rubocop fix

* resolve merge

* restore gemfile

* restore nl",CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2022-0936,
3643,"def reset_password @admin_user = Motor::AdminUser.find(params[:admin_user_id]) authorize!(:manage, @admin_user) Devise::Mailer.default_url_options = { host: request.host, protocol: request.protocol, port: request.port } @admin_user.send_reset_password_instructions head :ok end",True,Ruby,reset_password,admin_users_controller.rb,https://github.com/motor-admin/motor-admin,motor-admin,Pete Matsyburka,2022-01-20 18:39:40+02:00,do not use request host in for devise,CWE-116,Improper Encoding or Escaping of Output,"The product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.",https://cwe.mitre.org/data/definitions/116.html,CVE-2022-23079,
3648,"it 'authenticates successfuly' do basic_authorize 'a', 'b' get '/' assert_equal 200, last_response.status end",True,Ruby,'authenticates successfuly',test_web.rb,https://github.com/mperham/sidekiq,mperham,Mike Perham,2022-01-20 10:42:26-08:00,"Validate `days` parameter to avoid possible DoS in Web UI

Thank you to Sergey Shpakov of http://tutum.space for reporting.",CWE-770,Allocation of Resources Without Limits or Throttling,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",https://cwe.mitre.org/data/definitions/770.html,CVE-2022-23837,
3649,"def apply(operations) operations.inject(self) do |builder, (name, argument)| if argument == true || argument == nil builder.send(name) elsif argument.is_a?(Array) builder.send(name, *argument) elsif argument.is_a?(Hash) builder.send(name, **argument) else builder.send(name, argument) end end end",True,Ruby,apply,chainable.rb,https://github.com/janko/image_processing,janko,Janko Marohnić,2022-03-01 22:15:04+01:00,"Prevent remote shell execution in `#apply`

If the operations are coming from user input, this could allow the user
to execute arbitrary shell commands via `Kernel#system` and
`Kernel#spawn`:

  ImageProcessing::Vips.apply({ system: ""echo something"" })

We prevent this by using `#public_send` instead of `#send`, which goes
to method missing instead of calling private methods, which include
`Kernel#system` and `Kernel#spawn`.",NVD-CWE-Other,Other,"NVD is only using a subset of CWE for mapping instead of the entire CWE, and the weakness type is not covered by that subset.",https://nvd.nist.gov/vuln/categories,CVE-2022-24720,
3659,"def resolve_target_path(target, reader) return target if target_uri? target # Include file is resolved relative to dir of the current include, # or base_dir if within original docfile. path = reader.document.normalize_system_path(target, reader.dir, nil, target_name: 'include file') path if ::File.file?(path) end",True,Ruby,resolve_target_path,include_processor.rb,https://github.com/jirutka/asciidoctor-include-ext,jirutka,Jakub Jirutka,2022-03-30 00:50:25+02:00,"Fix command injection vulnerability

Reported by Joern Schneeweisz from GitLab GmbH:

> During an internal assessment on some GitLab code I came across a way
> to execute arbitrary commands in your asciidoctor-include-ext Gem.
>
> The following adoc snippet demonstrates the issue:
>
> ```
> :app-name: |id # + \
> http://test.com
>
> include::{app-name}[]
> ```
>
> It uses a linebreak to bypass the `target_uri` check here
> https://github.com/jirutka/asciidoctor-include-ext/blob/master/lib/asciidoctor/include_ext/include_processor.rb#L97
> and feed a command with the `|` prefix to open/IO.foreach.
>
> You can verify this with the above snippet by rendering it like this
>
> ```
> asciidoctor -r asciidoctor-include-ext  -a allow-uri-read home.asciidoc
> ```

See-Also: https://sakurity.com/blog/2015/02/28/openuri.html",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2022-24803,
3660,def target_uri?(target) ::Asciidoctor::Helpers.uriish?(target) end,True,Ruby,target_uri?,include_processor.rb,https://github.com/jirutka/asciidoctor-include-ext,jirutka,Jakub Jirutka,2022-03-30 00:50:25+02:00,"Fix command injection vulnerability

Reported by Joern Schneeweisz from GitLab GmbH:

> During an internal assessment on some GitLab code I came across a way
> to execute arbitrary commands in your asciidoctor-include-ext Gem.
>
> The following adoc snippet demonstrates the issue:
>
> ```
> :app-name: |id # + \
> http://test.com
>
> include::{app-name}[]
> ```
>
> It uses a linebreak to bypass the `target_uri` check here
> https://github.com/jirutka/asciidoctor-include-ext/blob/master/lib/asciidoctor/include_ext/include_processor.rb#L97
> and feed a command with the `|` prefix to open/IO.foreach.
>
> You can verify this with the above snippet by rendering it like this
>
> ```
> asciidoctor -r asciidoctor-include-ext  -a allow-uri-read home.asciidoc
> ```

See-Also: https://sakurity.com/blog/2015/02/28/openuri.html",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2022-24803,
3664,"def read_lines(filename, selector) if selector IO.foreach(filename).select.with_index(1, &selector) else URI.open(filename, &:read) end end",True,Ruby,read_lines,include_processor.rb,https://github.com/jirutka/asciidoctor-include-ext,jirutka,Jakub Jirutka,2022-03-30 00:50:25+02:00,"Fix command injection vulnerability

Reported by Joern Schneeweisz from GitLab GmbH:

> During an internal assessment on some GitLab code I came across a way
> to execute arbitrary commands in your asciidoctor-include-ext Gem.
>
> The following adoc snippet demonstrates the issue:
>
> ```
> :app-name: |id # + \
> http://test.com
>
> include::{app-name}[]
> ```
>
> It uses a linebreak to bypass the `target_uri` check here
> https://github.com/jirutka/asciidoctor-include-ext/blob/master/lib/asciidoctor/include_ext/include_processor.rb#L97
> and feed a command with the `|` prefix to open/IO.foreach.
>
> You can verify this with the above snippet by rendering it like this
>
> ```
> asciidoctor -r asciidoctor-include-ext  -a allow-uri-read home.asciidoc
> ```

See-Also: https://sakurity.com/blog/2015/02/28/openuri.html",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2022-24803,
3665,"def include_allowed?(target, reader) doc = reader.document return false if doc.safe >= ::Asciidoctor::SafeMode::SECURE return false if doc.attributes.fetch('max-include-depth', 64).to_i < 1 return false if target_uri?(target) && !doc.attributes.key?('allow-uri-read') true end",True,Ruby,include_allowed?,include_processor.rb,https://github.com/jirutka/asciidoctor-include-ext,jirutka,Jakub Jirutka,2022-03-30 00:50:25+02:00,"Fix command injection vulnerability

Reported by Joern Schneeweisz from GitLab GmbH:

> During an internal assessment on some GitLab code I came across a way
> to execute arbitrary commands in your asciidoctor-include-ext Gem.
>
> The following adoc snippet demonstrates the issue:
>
> ```
> :app-name: |id # + \
> http://test.com
>
> include::{app-name}[]
> ```
>
> It uses a linebreak to bypass the `target_uri` check here
> https://github.com/jirutka/asciidoctor-include-ext/blob/master/lib/asciidoctor/include_ext/include_processor.rb#L97
> and feed a command with the `|` prefix to open/IO.foreach.
>
> You can verify this with the above snippet by rendering it like this
>
> ```
> asciidoctor -r asciidoctor-include-ext  -a allow-uri-read home.asciidoc
> ```

See-Also: https://sakurity.com/blog/2015/02/28/openuri.html",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2022-24803,
3667,"def read_lines(path, selector) if selector IO.foreach(path).select.with_index(1, &selector) else URI.open(path, &:read) end end",True,Ruby,read_lines,include_processor.rb,https://github.com/jirutka/asciidoctor-include-ext,jirutka,Jakub Jirutka,2022-03-30 00:52:06+02:00,"Make #read_lines code more robust, avoid using IO.open directly",CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2022-24803,
3671,"def base_api_url computed_api_endpoint = ""https://#{get_data_center_from_api_key(self.api_key)}api.mailchimp.com"" raise Gibbon::GibbonError, ""SSRF attempt"" unless URI(computed_api_endpoint).host.include?(""api.mailchimp.com"") ""#{self.api_endpoint || computed_api_endpoint}/3.0/"" end",True,Ruby,base_api_url,api_request.rb,https://github.com/amro/gibbon,amro,Amro Mousa,2022-02-24 16:10:06-05:00,"bump version, handle invalid API key DC",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2022-27311,
3673,"def get_data_center_from_api_key(api_key) # Return an empty string for invalid API keys so Gibbon hits the main endpoint data_center = """" if api_key && api_key[""-""] # Add a period since the data_center is a subdomain and it keeps things dry data_center = ""#{api_key.split('-').last}."" end data_center end",True,Ruby,get_data_center_from_api_key,gibbon_helpers.rb,https://github.com/amro/gibbon,amro,Amro Mousa,2022-02-24 16:10:06-05:00,"bump version, handle invalid API key DC",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2022-27311,
3675,"it ""raises with a valid SSRF attack"" do @api_key = ""-attacker.net/test/?"" @gibbon.api_key = @api_key expect {@gibbon.try.retrieve}.to raise_error(Gibbon::MailChimpError, /SSRF attempt/) end",True,Ruby,"""raises with a valid SSRF attack""",gibbon_spec.rb,https://github.com/amro/gibbon,amro,Amro Mousa,2022-02-24 16:10:06-05:00,"bump version, handle invalid API key DC",CWE-918,Server-Side Request Forgery (SSRF),"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",https://cwe.mitre.org/data/definitions/918.html,CVE-2022-27311,
3679,"def self.extract_events(post) cooked = PrettyText.cook(post.raw, topic_id: post.topic_id, user_id: post.user_id) valid_options = VALID_OPTIONS.map { |o| ""data-#{o}"" } valid_custom_fields = [] SiteSetting.discourse_post_event_allowed_custom_fields.split('|').each do |setting| valid_custom_fields << { original: ""data-#{setting}"", normalized: ""data-#{setting.gsub(/_/, '-')}"" } end Nokogiri::HTML(cooked).css('div.discourse-post-event').map do |doc| event = nil doc.attributes.values.each do |attribute| name = attribute.name value = attribute.value if value && valid_options.include?(name) event ||= {} event[name.sub('data-', '').to_sym] = CGI.escapeHTML(value) end valid_custom_fields.each do |valid_custom_field| if value && valid_custom_field[:normalized] == name event ||= {} event[valid_custom_field[:original].sub('data-', '').to_sym] = CGI.escapeHTML(value) end end end event end.compact end",True,Ruby,self.extract_events,event_parser.rb,https://github.com/discourse/discourse-calendar,discourse,GitHub,2022-06-13 11:13:56-06:00,SECURITY: correctly escape event name (#280),CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2022-31059,
3693,"def diff @diff ||= begin @paths = case options[:source] when 'strings' [tempfile(string1), tempfile(string2)] when 'files' [string1, string2] end if WINDOWS # don't use open3 on windows cmd = sprintf '""%s"" %s %s', diff_bin, diff_options.join(' '), @paths.map { |s| %(""#{s}"") }.join(' ') diff = `#{cmd}` else diff = Open3.popen3(diff_bin, *(diff_options + @paths)) { |i, o, e| o.read } end diff.force_encoding('ASCII-8BIT') if diff.respond_to?(:valid_encoding?) && !diff.valid_encoding? if diff =~ /\A\s*\Z/ && !options[:allow_empty_diff] diff = case options[:source] when 'strings' then string1 when 'files' then File.read(string1) end.gsub(/^/, "" "") end",True,Ruby,diff,diff.rb,https://github.com/samg/diffy,samg,Sam Goldstein,2022-06-10 13:54:25-07:00,"Remove windows specific exec.  Open2.capture3 should work on all
platforms.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2022-33127,
3695,"def sanitize_data(project, data) return data if project&.assignment_id.blank? || data.blank? data = Oj.load(data) saved_restricted_elements = Oj.load(project.assignment.restrictions) scopes = data[""scopes""] || [] parsed_scopes = scopes.each_with_object([]) do |scope, new_scopes| restricted_elements_used = [] saved_restricted_elements.each do |element| restricted_elements_used.push(element) if scope[element].present? end scope[""restrictedCircuitElementsUsed""] = restricted_elements_used new_scopes.push(scope) end data[""scopes""] = parsed_scopes data.to_json end",True,Ruby,sanitize_data,simulator_helper.rb,https://github.com/CircuitVerse/CircuitVerse,CircuitVerse,GitHub,2022-08-23 14:30:56+05:18,"security: use Oj.safe_load to process json payload

`Oj#load` method is not safe for processing user input and can have serious impacts.",CWE-502,Deserialization of Untrusted Data,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,https://cwe.mitre.org/data/definitions/502.html,CVE-2022-36038,
3698,"def validate signature_missing = ""There was a problem saving your gem: \nYou have added cert_chain in gemspec but signature was empty"" return notify(signature_missing, 403) unless validate_signature_exists? (rubygem.valid? && version.valid?) || notify(""There was a problem saving your gem: #{rubygem.all_errors(version)}"", 403) end",True,Ruby,validate,pusher.rb,https://github.com/rubygems/rubygems.org,rubygems,GitHub,2023-08-16 18:37:38-07:00,"Merge pull request from GHSA-rxcq-2m4f-94wm

* Add improved input validation of pushed gemspecs

See https://github.com/rubygems/rubygems.org/security/advisories/GHSA-rxcq-2m4f-94wm

* Remove debugging code",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-40165,
3699,"def write_gem(body, spec) original_name = spec.original_name gem_path = ""gems/#{original_name}.gem"" gem_contents = body.string spec.abbreviate spec.sanitize spec_path = ""quick/Marshal.4.8/#{original_name}.gemspec.rz"" spec_contents = Gem.deflate(Marshal.dump(spec)) spec_contents_checksum = Digest::SHA2.base64digest(spec_contents) # do all processing _before_ we upload anything to S3, so we lower the chances of orphaned files RubygemFs.instance.store(gem_path, gem_contents, checksum_sha256: version.sha256) RubygemFs.instance.store(spec_path, spec_contents, checksum_sha256: spec_contents_checksum) Fastly.purge(path: gem_path) Fastly.purge(path: spec_path) end",True,Ruby,write_gem,pusher.rb,https://github.com/rubygems/rubygems.org,rubygems,GitHub,2023-08-16 18:37:38-07:00,"Merge pull request from GHSA-rxcq-2m4f-94wm

* Add improved input validation of pushed gemspecs

See https://github.com/rubygems/rubygems.org/security/advisories/GHSA-rxcq-2m4f-94wm

* Remove debugging code",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-40165,
3709,"def self.meta_delete(key:, cas: nil, ttl: nil, base64: false, quiet: false) cmd = ""md #{key}"" cmd << ' b' if base64 cmd << "" C#{cas}"" if cas && !cas.zero? cmd << "" T#{ttl}"" if ttl cmd << ' q' if quiet cmd + TERMINATOR end",True,Ruby,self.meta_delete,request_formatter.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3714,"def self.flush(delay: nil, quiet: false) cmd = +'flush_all' cmd << "" #{delay}"" if delay cmd << ' noreply' if quiet cmd + TERMINATOR end",True,Ruby,self.flush,request_formatter.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3716,"def self.meta_arithmetic(key:, delta:, initial:, incr: true, cas: nil, ttl: nil, base64: false, quiet: false) cmd = ""ma #{key} v"" cmd << ' b' if base64 cmd << "" D#{delta}"" if delta cmd << "" J#{initial}"" if initial cmd << "" C#{cas}"" if cas && !cas.zero? cmd << "" N#{ttl}"" if ttl cmd << ' q' if quiet cmd << "" M#{incr ? 'I' : 'D'}"" cmd + TERMINATOR end",True,Ruby,self.meta_arithmetic,request_formatter.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3717,"def self.meta_set(key:, value:, bitflags: nil, cas: nil, ttl: nil, mode: :set, base64: false, quiet: false) cmd = ""ms #{key} #{value.bytesize}"" cmd << ' c' unless %i[append prepend].include?(mode) cmd << ' b' if base64 cmd << "" F#{bitflags}"" if bitflags cmd << "" C#{cas}"" if cas && !cas.zero? cmd << "" T#{ttl}"" if ttl cmd << "" M#{mode_to_token(mode)}"" cmd << ' q' if quiet cmd << TERMINATOR cmd << value cmd + TERMINATOR end",True,Ruby,self.meta_set,request_formatter.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3720,"it 'handle read timeouts' do memcached_mock(lambda { |sock| sleep(0.6) sock.write('giraffe') }) do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new('localhost:19123') dc.get('abc') end end end",True,Ruby,'handle read timeouts',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3722,"it 'handle no server available' do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new 'localhost:19333' dc.get 'foo' end end",True,Ruby,'handle no server available',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3724,"it 'handle connection reset' do memcached_mock(->(sock) { sock.close }) do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new('localhost:19123') dc.get('abc') end end end",True,Ruby,'handle connection reset',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3726,"it 'handle connect timeouts' do memcached_mock(lambda { |sock| sleep(0.6) sock.close }, :delayed_start) do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new('localhost:19123') dc.get('abc') end end end",True,Ruby,'handle connect timeouts',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3729,"it 'handle connection reset with unix socket' do socket_path = MemcachedMock::UNIX_SOCKET_PATH memcached_mock(->(sock) { sock.close }, :start_unix, socket_path) do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new(socket_path) dc.get('abc') end end end",True,Ruby,'handle connection reset with unix socket',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3730,"it 'handle malformed response' do memcached_mock(->(sock) { sock.write('123') }) do assert_raises Dalli::RingError, message: 'No server available' do dc = Dalli::Client.new('localhost:19123') dc.get('abc') end end end",True,Ruby,'handle malformed response',test_network.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3744,"it 'returns incorporates CAS when passed cas' do assert_equal ""md #{key} C#{cas}\r\n"", Dalli::Protocol::Meta::RequestFormatter.meta_delete(key: key, cas: cas) end",True,Ruby,'returns incorporates CAS when passed cas',test_request_formatter.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3746,"it 'connects to existing server' do assert_silent do rsd = Rack::Session::Dalli.new(incrementor, namespace: 'test:rack:session') rsd.data.with { |c| c.set('ping', '') } end end",True,Ruby,'connects to existing server',test_rack_session.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3748,"it 'faults on no connection' do assert_raises Dalli::RingError do rsd = Rack::Session::Dalli.new(incrementor, memcache_server: 'nosuchserver') rsd.data.with { |c| c.set('ping', '') } end end",True,Ruby,'faults on no connection',test_rack_session.rb,https://github.com/petergoldstein/dalli,petergoldstein,GitHub,2022-10-27 17:58:52-04:00,"Fixes #932 (#933)

Do some input sanitization for the meta protocol. Since this protocol uses raw test, it is possible to execute an injection attack against unsanitized inputs.

This commit explicitly sanitizes the CAS arguments and the ttl passed to flush.

I also added some missing tests for meta_arithmetic and fixed a few lints.",CWE-74,Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection'),"The product constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/74.html,CVE-2022-4064,
3758,"def incoming account = Account.find_by_id_or_name(params[:account_name]) channel = account.geopoll_channels.find_by_name(params[:channel_name]) auth_token = channel.configuration[:auth_token].to_s.split(' ')[1] identifier = params[:Identifier] signature = Digest::MD5.hexdigest(auth_token + identifier) if signature != params[:Signature] return render text: ""Error"", status: :unauthorized end msg = AtMessage.new msg.from = ""sms://#{params[:SourceAddress]}"" msg.to = ""sms://#{channel.configuration[:from]}"" msg.body = params[:MessageText] msg.channel_relative_id = params[:Identifier] account.route_at msg, channel render text: ""Accepted"" end",True,Ruby,incoming,geopoll_controller.rb,https://github.com/instedd/nuntium,instedd,GitHub,2022-11-23 19:35:07-03:00,"Detect GeoPoll AT's to: number (#88)

* Securely check GeoPoll incoming signature

This avoids timing attacks

* Log unknown GeoPoll requests parameters

To avoid losing data upon API changes

See #76

* Show GeoPoll channels in Interactions tab

* Detect GeoPoll AT's to: numbers

Fixes #76",CWE-203,Observable Discrepancy,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.",https://cwe.mitre.org/data/definitions/203.html,CVE-2022-4823,
3759,"def to_plain(argv1 = '', loose = false) return nil if argv1.empty? plain = argv1 if loose || plain =~ Match[:html] || plain =~ Match[:body] # 1. Remove <head>...</head> # 2. Remove <style>...</style> # 3. <a href = 'http://...'>...</a> to "" http://... "" # 4. <a href = 'mailto:...'>...</a> to "" Value <mailto:...> "" plain.scrub!('?') plain.gsub!(%r|<head>.+</head>|im, '') plain.gsub!(%r|<style.+?>.+</style>|im, '') plain.gsub!(%r|<a\s+href\s*=\s*['""](https?://.+?)['""].*?>(.*?)</a>|i, '[\2](\1)') plain.gsub!(%r|<a\s+href\s*=\s*[""']mailto:([^\s]+?)[""']>(.*?)</a>|i, '[\2](mailto:\1)') plain = plain.gsub(/<[^<@>]+?>\s*/, ' ') # Delete HTML tags except <neko@example.jp> plain = plain.gsub(/&lt;/, '<').gsub(/&gt;/, '>') # Convert to angle brackets plain = plain.gsub(/&amp;/, '&').gsub(/&nbsp;/, ' ') # Convert to ""&"" plain = plain.gsub(/&quot;/, '""').gsub(/&apos;/, ""'"") # Convert to "" and ' if argv1.size > plain.size plain = plain.squeeze(' ') plain << ""\n"" end end return plain end",True,Ruby,to_plain,string.rb,https://github.com/sisimai/rb-sisimai,sisimai,Gonçalo Cabrita,2022-11-28 20:07:49+00:00,Prevent Regex Denial of Service in Sisimai::String.to_plain,CWE-1333,Inefficient Regular Expression Complexity,"The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",https://cwe.mitre.org/data/definitions/1333.html,CVE-2022-4891,
3762,"def avatar_image(username, uploaded_avatar_id) template = User.avatar_template(username, uploaded_avatar_id).gsub(/{size}/, ""50"") ""![avatar\\|25x25](#{template})"" end",True,Ruby,avatar_image,yearly_review_helper.rb,https://github.com/discourse/discourse-yearly-review,discourse,GitHub,2023-02-15 03:51:38+05:18,"SECURITY: update old username when the user is anonymized. (#55)

Previously, when a user is anonymized their new username is not updated in the yearly review topic.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-25169,
3763,"def create_category_posts(view, review_start, review_end, topic_id) review_categories = review_categories_from_settings review_categories.each do |category_id| category_post_topics = category_post_topics category_id, review_start, review_end if category_post_topics[:topics] view.assign(category_topics: category_post_topics) raw = view.render partial: ""yearly_review_category"", layout: false unless raw.empty? post_opts = { topic_id: topic_id, raw: raw, skip_validations: true } PostCreator.create!(Discourse.system_user, post_opts) end end end end",True,Ruby,create_category_posts,yearly_review.rb,https://github.com/discourse/discourse-yearly-review,discourse,GitHub,2023-02-15 03:51:38+05:18,"SECURITY: update old username when the user is anonymized. (#55)

Previously, when a user is anonymized their new username is not updated in the yearly review topic.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-25169,
3768,"it ""should rank likes given and received correctly"" do Jobs::YearlyReview.new.execute({}) topic = Topic.last raw = Post.where(topic_id: topic.id).first.raw expect(raw).to have_tag(""div.likes-given"") { with_text(/\@top_review_user\|11/) } expect(raw).to have_tag(""div.likes-given"") { with_text(/\@reviewed_user\|10/) } expect(raw).to have_tag(""div.likes-received"") { with_text(/\@reviewed_user\|11/) } expect(raw).to have_tag(""div.likes-received"") { with_text(/\@top_review_user\|10/) } end",True,Ruby,"""should rank likes given and received correctly""",yearly_review_spec.rb,https://github.com/discourse/discourse-yearly-review,discourse,GitHub,2023-02-15 03:51:38+05:18,"SECURITY: update old username when the user is anonymized. (#55)

Previously, when a user is anonymized their new username is not updated in the yearly review topic.",NVD-CWE-noinfo,Insufficient Information,There is insufficient information about the issue to classify it; details are unkown or unspecified.,https://nvd.nist.gov/vuln/categories,CVE-2023-25169,
3771,"def encode_io(io, options = '') command = ""#{ffmpeg_command} -loglevel 0 -i - #{options} -f s16le -ar 48000 -ac 2 #{filter_volume_argument} pipe:1"" IO.popen(command, in: io) end",True,Ruby,encode_io,encoder.rb,https://github.com/shardlab/discordrb,shardlab,Matthew Carey,2023-03-08 15:33:54-05:00,fix: switch popen to use an array invocation,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2023-28102,
3773,def ffmpeg_command @use_avconv ? 'avconv' : 'ffmpeg' end,True,Ruby,ffmpeg_command,encoder.rb,https://github.com/shardlab/discordrb,shardlab,Matthew Carey,2023-03-08 15:33:54-05:00,fix: switch popen to use an array invocation,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2023-28102,
3776,"def encode_file(file, options = '') command = ""#{ffmpeg_command} -loglevel 0 -i \""#{file}\"" #{options} -f s16le -ar 48000 -ac 2 #{filter_volume_argument} pipe:1"" IO.popen(command) end",True,Ruby,encode_file,encoder.rb,https://github.com/shardlab/discordrb,shardlab,Matthew Carey,2023-03-08 15:33:54-05:00,fix: switch popen to use an array invocation,CWE-78,Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection'),"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",https://cwe.mitre.org/data/definitions/78.html,CVE-2023-28102,
3777,def set_up_request_echo_headers response.headers['X-Up-Location'] = up.request_url_without_up_params response.headers['X-Up-Method'] = request.method end,True,Ruby,set_up_request_echo_headers,request_echo_headers.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3780,it 'removes _up-* params' do get '/binding_test/text?_up_1=x&foo=bar&_up_2=y' expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo=bar') end,True,Ruby,'removes _up-* params',controller_spec.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3783,it 'does not mangle array params (BUGFIX)' do get '/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux&_up_location=up_location' expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo%5B%5D=bar&foo%5B%5D=qux') end,True,Ruby,'does not mangle array params (BUGFIX)',controller_spec.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3784,it 'echoes the current path after a redirect' do get '/binding_test/redirect1' expect(response).to be_redirect follow_redirect! expect(response.headers['X-Up-Location']).to end_with('/binding_test/redirect2') end,True,Ruby,'echoes the current path after a redirect',controller_spec.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3785,it 'echoes the current path with query params' do get '/binding_test/text?foo=bar' expect(response.headers['X-Up-Location']).to end_with('/binding_test/text?foo=bar') end,True,Ruby,'echoes the current path with query params',controller_spec.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3786,it 'echoes the current path in an X-Up-Location response header' do get '/binding_test/text' expect(response.headers['X-Up-Location']).to end_with('/binding_test/text') end,True,Ruby,'echoes the current path in an X-Up-Location response header',controller_spec.rb,https://github.com/unpoly/unpoly-rails,unpoly,Henning Koch,2023-03-30 13:00:06+02:00,"Only echo the request URL as X-Up-Location if it contains query params prefixed with ""_up""",CWE-400,Uncontrolled Resource Consumption,"The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.",https://cwe.mitre.org/data/definitions/400.html,CVE-2023-28846,
3788,def show @redirect_to = params[:back].presence || root_path @payment = Payment.from_id(params[:id]) end,True,Ruby,show,payments_controller.rb,https://github.com/pay-rails/pay,pay-rails,Chris Oliver,2023-04-19 11:39:59-05:00,Fix XSS vulnerability on Stripe payment page,CWE-79,Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'),The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,https://cwe.mitre.org/data/definitions/79.html,CVE-2023-30614,
3790,"def call(state) driver = instance.driver transport = driver.transport ::Kitchen::Terraform::Provisioner::Converge.new( config: driver.send(:config), connection: transport.connection({}), debug_connection: transport.connection(logger: ::Kitchen::Terraform::DebugLogger.new(logger: logger)), logger: logger, version_requirement: version_requirement, workspace_name: workspace_name, ).call state: state rescue => error ::Kitchen::Terraform::Raise::ActionFailed.new(logger: logger).call message: error.message end",True,Ruby,call,terraform.rb,https://github.com/newcontext-oss/kitchen-terraform,newcontext-oss,GitHub,2023-04-21 01:36:19+00:00,"Fix Converge Debug Logging and Prepare 7.0.1 (#522)

* Fix connection debug logging

* Add entry to changelog

* Prepare 7.0.1

---------

Co-authored-by: Aaron Lane <2400330-aaron-lane@users.noreply.gitlab.com>",CWE-532,Insertion of Sensitive Information into Log File,Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.,https://cwe.mitre.org/data/definitions/532.html,CVE-2023-30618,
3794,"def value self.value = ::Gem::Version.new ""7.0.0"" if not @value @value end",True,Ruby,value,version.rb,https://github.com/newcontext-oss/kitchen-terraform,newcontext-oss,GitHub,2023-04-21 01:36:19+00:00,"Fix Converge Debug Logging and Prepare 7.0.1 (#522)

* Fix connection debug logging

* Add entry to changelog

* Prepare 7.0.1

---------

Co-authored-by: Aaron Lane <2400330-aaron-lane@users.noreply.gitlab.com>",CWE-532,Insertion of Sensitive Information into Log File,Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.,https://cwe.mitre.org/data/definitions/532.html,CVE-2023-30618,
3796,"it ""equals the gem version"" do expect(described_class.instance_variable_get(:@plugin_version)).to eq ""7.0.0"" end",True,Ruby,"""equals the gem version""",configurable_examples.rb,https://github.com/newcontext-oss/kitchen-terraform,newcontext-oss,GitHub,2023-04-21 01:36:19+00:00,"Fix Converge Debug Logging and Prepare 7.0.1 (#522)

* Fix connection debug logging

* Add entry to changelog

* Prepare 7.0.1

---------

Co-authored-by: Aaron Lane <2400330-aaron-lane@users.noreply.gitlab.com>",CWE-532,Insertion of Sensitive Information into Log File,Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.,https://cwe.mitre.org/data/definitions/532.html,CVE-2023-30618,
3797,"def extract_tar_for_moss(tmp_dir, external_tar, archive) return unless external_tar # Directory to hold tar ball and all individual files. extTarDir = File.join(tmp_dir, ""external_input"") baseFilesDir = File.join(tmp_dir, ""basefiles"") begin Dir.mkdir(extTarDir) Dir.mkdir(baseFilesDir) # To hold all basefiles rescue StandardError nil end # Read in the tarfile from the given source. extTarPath = File.join(extTarDir, ""input_file"") external_tar.rewind File.open(extTarPath, ""wb"") { |f| f.write(external_tar.read) } # Write tar file. # Directory to hold all external individual submission. extFilesDir = File.join(extTarDir, ""submissions"") begin Dir.mkdir(extFilesDir) # To hold all submissions rescue StandardError nil end # Untar the given Tar file. begin archive_extract = Archive.get_archive(extTarPath) # write each file, renaming nested files archive_extract.each do |entry| pathname = Archive.get_entry_name(entry) next if Archive.looks_like_directory?(pathname) destination = if archive File.join(extFilesDir, pathname) else File.join(baseFilesDir, pathname) end pathname.gsub!(%r{/}, ""-"") # make sure all subdirectories are there File.open(destination, ""wb"") do |out| out.write Archive.read_entry_file(entry) begin out.fsync rescue StandardError nil end end end rescue StandardError @failures << ""External Tar"" end",True,Ruby,extract_tar_for_moss,courses_controller.rb,https://github.com/autolab/Autolab,autolab,GitHub,2023-05-17 02:32:33-04:00,Merge pull request from GHSA-h8g5-vhm4-wx6g,CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2023-32317,
3801,"def importAsmtFromTar tarFile = params[""tarFile""] if tarFile.nil? flash[:error] = ""Please select an assessment tarball for uploading."" redirect_to(action: ""install_assessment"") return end begin tarFile = File.new(tarFile.open, ""rb"") tar_extract = Gem::Package::TarReader.new(tarFile) tar_extract.rewind is_valid_tar, asmt_name = valid_asmt_tar(tar_extract) tar_extract.close unless is_valid_tar flash[:error] += ""<br>Invalid tarball. A valid assessment tar has a single root ""\ ""directory that's named after the assessment, containing an ""\ ""assessment yaml file and an assessment ruby file."" flash[:html_safe] = true redirect_to(action: ""install_assessment"") && return end rescue SyntaxError => e flash[:error] = ""Error parsing assessment configuration file:"" # escape so that <compiled> doesn't get treated as a html tag flash[:error] += ""<br><pre>#{CGI.escapeHTML e.to_s}</pre>"" flash[:html_safe] = true redirect_to(action: ""install_assessment"") && return rescue StandardError => e flash[:error] = ""Error while reading the tarball -- #{e.message}."" redirect_to(action: ""install_assessment"") && return end # Check if the assessment already exists. unless @course.assessments.find_by(name: asmt_name).nil? flash[:error] = ""An assessment with the same name already exists for the course. ""\ ""Please use a different name."" redirect_to(action: ""install_assessment"") && return end # If all requirements are satisfied, extract assessment files. begin course_root = Rails.root.join(""courses"", @course.name) tar_extract.rewind tar_extract.each do |entry| relative_pathname = entry.full_name if entry.directory? FileUtils.mkdir_p(File.join(course_root, relative_pathname), mode: entry.header.mode, verbose: false) elsif entry.file? FileUtils.mkdir_p(File.join(course_root, File.dirname(relative_pathname)), mode: entry.header.mode, verbose: false) File.open(File.join(course_root, relative_pathname), ""wb"") do |f| f.write entry.read end FileUtils.chmod entry.header.mode, File.join(course_root, relative_pathname), verbose: false elsif entry.header.typeflag == ""2"" File.symlink entry.header.linkname, File.join(course_root, relative_pathname) end end tar_extract.close rescue StandardError => e flash[:error] = ""Error while extracting tarball to server -- #{e.message}."" redirect_to(action: ""install_assessment"") && return end params[:assessment_name] = asmt_name importAssessment && return end",True,Ruby,importAsmtFromTar,assessments_controller.rb,https://github.com/autolab/Autolab,autolab,GitHub,2023-05-18 14:23:46-07:00,"Merge pull request from GHSA-x9hj-r9q4-832c

* use Archive.in_dir? to check entry files in archive stay within archive

* run rubocop

* check that file is specifically within assessment directory

* address PR comment",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2023-32676,
3803,"def extract_tar_for_moss(tmp_dir, external_tar, archive) return unless external_tar # Directory to hold tar ball and all individual files. extTarDir = File.join(tmp_dir, ""external_input"") baseFilesDir = File.join(tmp_dir, ""basefiles"") begin Dir.mkdir(extTarDir) Dir.mkdir(baseFilesDir) # To hold all basefiles rescue StandardError nil end # Read in the tarfile from the given source. extTarPath = File.join(extTarDir, ""input_file"") external_tar.rewind File.open(extTarPath, ""wb"") { |f| f.write(external_tar.read) } # Write tar file. # Directory to hold all external individual submission. extFilesDir = File.join(extTarDir, ""submissions"") begin Dir.mkdir(extFilesDir) # To hold all submissions rescue StandardError nil end # Untar the given Tar file. begin archive_extract = Archive.get_archive(extTarPath) # write each file, renaming nested files archive_extract.each do |entry| pathname = Archive.get_entry_name(entry) next if Archive.looks_like_directory?(pathname) output_dir = if archive extFilesDir else baseFilesDir end output_file = File.join(output_dir, pathname) # skip if the file lies outside the archive next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir)) # make sure all subdirectories are there File.open(output_file, ""wb"") do |out| out.write Archive.read_entry_file(entry) begin out.fsync rescue StandardError nil end end end rescue StandardError @failures << ""External Tar"" end",True,Ruby,extract_tar_for_moss,courses_controller.rb,https://github.com/autolab/Autolab,autolab,GitHub,2023-05-18 14:23:46-07:00,"Merge pull request from GHSA-x9hj-r9q4-832c

* use Archive.in_dir? to check entry files in archive stay within archive

* run rubocop

* check that file is specifically within assessment directory

* address PR comment",CWE-22,Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal'),"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",https://cwe.mitre.org/data/definitions/22.html,CVE-2023-32676,
3804,"def fill_field(model, key, value, params) return model unless model.methods.include? key.to_sym if polymorphic_as.present? model.send(""#{polymorphic_as}_type="", params[""#{polymorphic_as}_type""]) # If the type is blank, reset the id too. if params[""#{polymorphic_as}_type""].blank? model.send(""#{polymorphic_as}_id="", nil) else model.send(""#{polymorphic_as}_id="", params[""#{polymorphic_as}_id""]) end else model.send(""#{key}="", value) end model end",True,Ruby,fill_field,belongs_to_field.rb,https://github.com/avo-hq/avo,avo-hq,GitHub,2023-06-06 01:06:58+03:00,"Merge pull request from GHSA-86h2-2g4g-29qx

* fix vuln

* wip",CWE-470,Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection'),"The product uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.",https://cwe.mitre.org/data/definitions/470.html,CVE-2023-34102,
3807,"def read return nil if @finished # It is possible this line contains chunk extension, so we use `to_i` to only consider the initial integral part: length = read_line.to_i(16) if length == 0 @finished = true read_trailer return nil end # Read trailing CRLF: chunk = @stream.read(length + 2) # ...and chomp it off: chunk.chomp!(CRLF) @length += length @count += 1 return chunk end",True,Ruby,read,chunked.rb,https://github.com/socketry/protocol-http1,socketry,GitHub,2023-07-30 12:46:58+12:00,Strict validation of content length and chunk length. (#20),CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-38697,
3810,"def extract_content_length(headers) if content_length = headers.delete(CONTENT_LENGTH) if length = Integer(content_length, exception: false) and length >= 0 yield length else raise BadRequest, ""Invalid content length: #{content_length}"" end end end",True,Ruby,extract_content_length,connection.rb,https://github.com/socketry/protocol-http1,socketry,GitHub,2023-07-30 12:46:58+12:00,Strict validation of content length and chunk length. (#20),CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-38697,
3812,"it ""can read length of head response"" do body = client.read_response_body(""HEAD"", 200, {'content-length' => 3773}) expect(body).to be_a ::Protocol::HTTP::Body::Head expect(body.length).to be == 3773 expect(body.read).to be_nil end",True,Ruby,"""can read length of head response""",connection.rb,https://github.com/socketry/protocol-http1,socketry,GitHub,2023-07-30 12:46:58+12:00,Strict validation of content length and chunk length. (#20),CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-38697,
3814,"it ""ignores zero length body"" do body = client.read_response_body(""HEAD"", 200, {'content-length' => 0}) expect(body).to be_nil end",True,Ruby,"""ignores zero length body""",connection.rb,https://github.com/socketry/protocol-http1,socketry,GitHub,2023-07-30 12:46:58+12:00,Strict validation of content length and chunk length. (#20),CWE-444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),"The product acts as an intermediary HTTP agent
         (such as a proxy or firewall) in the data flow between two
         entities such as a client and server, but it does not
         interpret malformed HTTP requests or responses in ways that
         are consistent with how the messages will be processed by
         those entities that are at the ultimate destination.",https://cwe.mitre.org/data/definitions/444.html,CVE-2023-38697,
